
/**
 * Client
**/

import * as runtime from '@prisma/client/runtime/index';
declare const prisma: unique symbol
export type PrismaPromise<A> = Promise<A> & {[prisma]: true}
type UnwrapPromise<P extends any> = P extends Promise<infer R> ? R : P
type UnwrapTuple<Tuple extends readonly unknown[]> = {
  [K in keyof Tuple]: K extends `${number}` ? Tuple[K] extends PrismaPromise<infer X> ? X : UnwrapPromise<Tuple[K]> : UnwrapPromise<Tuple[K]>
};


/**
 * Model academic_year
 * 
 */
export type academic_year = {
  ac_year_ID: number
  no_of_student: number
  year: number
}

/**
 * Model admission
 * 
 */
export type admission = {
  admission_id: number
  exam_hall: string
  course_name: string
  course_code: string
  exan_date: Date
  exam_time: Date
  attendence_verify: string
}

/**
 * Model announcement
 * 
 */
export type announcement = {
  annou_id: number
  content: string
  admin_id: number
}

/**
 * Model assign_marks
 * 
 */
export type assign_marks = {
  assigment_id: number
  sub_marks: number
  total_marks: number
  assign_precentage: number
  mark_id: number
}

/**
 * Model assignments
 * 
 */
export type assignments = {
  assignment_id: number
  name: string
  description: string
  contribution: number
  lecturer_id: number
  course_id: number
}

/**
 * Model confirm
 * 
 */
export type confirm = {
  confirm_id: number
  letter_id: number
}

/**
 * Model course
 * 
 */
export type course = {
  course_id: number
  year: number
  semester: string
  course_name: string
  course_code: string
  lecture_name: string
  ac_year_ID: number
}

/**
 * Model director
 * 
 */
export type director = {
  director_id: number
  user_id: number
}

/**
 * Model exam
 * 
 */
export type exam = {
  exam_sem_id: number
  semester: number
  year: number
}

/**
 * Model exam_mark
 * 
 */
export type exam_mark = {
  mark_id: number
  course_code: string
  course_name: string
  grade: string
  total_mark: number
  director_status: string
  head_of_exam_status: string
  exam_sem_id: number
  director_id: number
  head_of_exam_id: number
  index_no: number
}

/**
 * Model exam_timetable
 * 
 */
export type exam_timetable = {
  timetable_id: number
  exam_date: Date
  exam_time: Date
  course_code: string
  course_name: string
  exam_sem_id: number
}

/**
 * Model head_of_exam_board
 * 
 */
export type head_of_exam_board = {
  head_of_exam_ID: number
  user_id: number
  staff_id: number
}

/**
 * Model lecture_question
 * 
 */
export type lecture_question = {
  exam_paper_id: number
  lecture_id: number
}

/**
 * Model lecturer
 * 
 */
export type lecturer = {
  lecturer_id: number
  degree: string
  user_id: number
}

/**
 * Model lecturer_courses
 * 
 */
export type lecturer_courses = {
  user_id: number
  course_id: number
}

/**
 * Model letter
 * 
 */
export type letter = {
  letter_id: number
  email: string
  another_email: string
  final_quali: string
  id_no: string
  duration: number
  degree_status: string
  study_year: number
  index_no: number
  reg_no: string
  degree_prog: string
  address: string
  contact_no: string
  another_cont_no: string
  payment_voucher: string
}

/**
 * Model ma
 * 
 */
export type ma = {
  MA_id: number
  user_id: number
  staff_id: number
  office_id: string
  letter_id: number
}

/**
 * Model mis_report
 * 
 */
export type mis_report = {
  mis_id: number
  report_id: number
}

/**
 * Model paper_marks
 * 
 */
export type paper_marks = {
  paper_id: number
  sub_marks: number
  total_marks: number
  paper_precentage: number
  mark_id: number
}

/**
 * Model paper_question
 * 
 */
export type paper_question = {
  exam_paper_id: number
  course_code: string
  course_name: string
  question_no: number
  exam_sem_id: number
}

/**
 * Model payment
 * 
 */
export type payment = {
  payment_id: number
  payment_date: Date
  amount: number
  status: string
  index_no: number
  ac_year_ID: number
}

/**
 * Model repeat_course
 * 
 */
export type repeat_course = {
  rc_id: number
  course_code: string
  course_name: string
  year: number
  semester: string
}

/**
 * Model report
 * 
 */
export type report = {
  report_id: number
  course_name: string
  course_code: string
  year: number
  semester: string
  exam_sem_id: number
}

/**
 * Model sar
 * 
 */
export type sar = {
  SAR_id: number
  user_id: number
  staff_id: number
  office_id: number
}

/**
 * Model staff
 * 
 */
export type staff = {
  staff_id: number
  user_id: number
}

/**
 * Model student
 * 
 */
export type student = {
  index_no: number
  user_id: number
  nic: string
  gender: string
  initials: string
  title: string
  general_eng: string
  district_no: string
  intake: string
  reg_no: string
  telep_1: string
  telep_2: string
  address_no: string
  address_city: string
  address_street: string
  address_4: string
  student_temp_no: number
  district_name: string
  name_initial: string
  full_name: string
  syllabus: string
  AL_index_no: number
  rank: number
  GPA: number
  ac_year_ID: number
}

/**
 * Model subject_report
 * 
 */
export type subject_report = {
  subject_id: number
  no_of_student: number
  report_id: number
}

/**
 * Model system_pages
 * 
 */
export type system_pages = {
  page_id: number
  content: string
  admin_id: number
}

/**
 * Model transcript
 * 
 */
export type transcript = {
  transcript_id: number
  letter_id: number
}

/**
 * Model user
 * 
 */
export type user = {
  user_id: number
  user_name: string
  password: string
  email: string
  user_type: string
  f_name: string
  l_name: string
  profile_pic: string | null
}


/**
 * ##  Prisma Client ʲˢ
 * 
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Academic_years
 * const academic_years = await prisma.academic_year.findMany()
 * ```
 *
 * 
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  T extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof T ? T['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<T['log']> : never : never,
  GlobalReject = 'rejectOnNotFound' extends keyof T
    ? T['rejectOnNotFound']
    : false
      > {
      /**
       * @private
       */
      private fetcher;
      /**
       * @private
       */
      private readonly dmmf;
      /**
       * @private
       */
      private connectionPromise?;
      /**
       * @private
       */
      private disconnectionPromise?;
      /**
       * @private
       */
      private readonly engineConfig;
      /**
       * @private
       */
      private readonly measurePerformance;

    /**
   * ##  Prisma Client ʲˢ
   * 
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Academic_years
   * const academic_years = await prisma.academic_year.findMany()
   * ```
   *
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<T, Prisma.PrismaClientOptions>);
  $on<V extends (U | 'beforeExit')>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : V extends 'beforeExit' ? () => Promise<void> : Prisma.LogEvent) => void): void;

  /**
   * Connect with the database
   */
  $connect(): Promise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): Promise<void>;

  /**
   * Add a middleware
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): PrismaPromise<T>;

  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends PrismaPromise<any>[]>(arg: [...P]): Promise<UnwrapTuple<P>>;

      /**
   * `prisma.academic_year`: Exposes CRUD operations for the **academic_year** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Academic_years
    * const academic_years = await prisma.academic_year.findMany()
    * ```
    */
  get academic_year(): Prisma.academic_yearDelegate<GlobalReject>;

  /**
   * `prisma.admission`: Exposes CRUD operations for the **admission** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Admissions
    * const admissions = await prisma.admission.findMany()
    * ```
    */
  get admission(): Prisma.admissionDelegate<GlobalReject>;

  /**
   * `prisma.announcement`: Exposes CRUD operations for the **announcement** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Announcements
    * const announcements = await prisma.announcement.findMany()
    * ```
    */
  get announcement(): Prisma.announcementDelegate<GlobalReject>;

  /**
   * `prisma.assign_marks`: Exposes CRUD operations for the **assign_marks** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Assign_marks
    * const assign_marks = await prisma.assign_marks.findMany()
    * ```
    */
  get assign_marks(): Prisma.assign_marksDelegate<GlobalReject>;

  /**
   * `prisma.assignments`: Exposes CRUD operations for the **assignments** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Assignments
    * const assignments = await prisma.assignments.findMany()
    * ```
    */
  get assignments(): Prisma.assignmentsDelegate<GlobalReject>;

  /**
   * `prisma.confirm`: Exposes CRUD operations for the **confirm** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Confirms
    * const confirms = await prisma.confirm.findMany()
    * ```
    */
  get confirm(): Prisma.confirmDelegate<GlobalReject>;

  /**
   * `prisma.course`: Exposes CRUD operations for the **course** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Courses
    * const courses = await prisma.course.findMany()
    * ```
    */
  get course(): Prisma.courseDelegate<GlobalReject>;

  /**
   * `prisma.director`: Exposes CRUD operations for the **director** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Directors
    * const directors = await prisma.director.findMany()
    * ```
    */
  get director(): Prisma.directorDelegate<GlobalReject>;

  /**
   * `prisma.exam`: Exposes CRUD operations for the **exam** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Exams
    * const exams = await prisma.exam.findMany()
    * ```
    */
  get exam(): Prisma.examDelegate<GlobalReject>;

  /**
   * `prisma.exam_mark`: Exposes CRUD operations for the **exam_mark** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Exam_marks
    * const exam_marks = await prisma.exam_mark.findMany()
    * ```
    */
  get exam_mark(): Prisma.exam_markDelegate<GlobalReject>;

  /**
   * `prisma.exam_timetable`: Exposes CRUD operations for the **exam_timetable** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Exam_timetables
    * const exam_timetables = await prisma.exam_timetable.findMany()
    * ```
    */
  get exam_timetable(): Prisma.exam_timetableDelegate<GlobalReject>;

  /**
   * `prisma.head_of_exam_board`: Exposes CRUD operations for the **head_of_exam_board** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Head_of_exam_boards
    * const head_of_exam_boards = await prisma.head_of_exam_board.findMany()
    * ```
    */
  get head_of_exam_board(): Prisma.head_of_exam_boardDelegate<GlobalReject>;

  /**
   * `prisma.lecture_question`: Exposes CRUD operations for the **lecture_question** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Lecture_questions
    * const lecture_questions = await prisma.lecture_question.findMany()
    * ```
    */
  get lecture_question(): Prisma.lecture_questionDelegate<GlobalReject>;

  /**
   * `prisma.lecturer`: Exposes CRUD operations for the **lecturer** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Lecturers
    * const lecturers = await prisma.lecturer.findMany()
    * ```
    */
  get lecturer(): Prisma.lecturerDelegate<GlobalReject>;

  /**
   * `prisma.lecturer_courses`: Exposes CRUD operations for the **lecturer_courses** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Lecturer_courses
    * const lecturer_courses = await prisma.lecturer_courses.findMany()
    * ```
    */
  get lecturer_courses(): Prisma.lecturer_coursesDelegate<GlobalReject>;

  /**
   * `prisma.letter`: Exposes CRUD operations for the **letter** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Letters
    * const letters = await prisma.letter.findMany()
    * ```
    */
  get letter(): Prisma.letterDelegate<GlobalReject>;

  /**
   * `prisma.ma`: Exposes CRUD operations for the **ma** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Mas
    * const mas = await prisma.ma.findMany()
    * ```
    */
  get ma(): Prisma.maDelegate<GlobalReject>;

  /**
   * `prisma.mis_report`: Exposes CRUD operations for the **mis_report** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Mis_reports
    * const mis_reports = await prisma.mis_report.findMany()
    * ```
    */
  get mis_report(): Prisma.mis_reportDelegate<GlobalReject>;

  /**
   * `prisma.paper_marks`: Exposes CRUD operations for the **paper_marks** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Paper_marks
    * const paper_marks = await prisma.paper_marks.findMany()
    * ```
    */
  get paper_marks(): Prisma.paper_marksDelegate<GlobalReject>;

  /**
   * `prisma.paper_question`: Exposes CRUD operations for the **paper_question** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Paper_questions
    * const paper_questions = await prisma.paper_question.findMany()
    * ```
    */
  get paper_question(): Prisma.paper_questionDelegate<GlobalReject>;

  /**
   * `prisma.payment`: Exposes CRUD operations for the **payment** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Payments
    * const payments = await prisma.payment.findMany()
    * ```
    */
  get payment(): Prisma.paymentDelegate<GlobalReject>;

  /**
   * `prisma.repeat_course`: Exposes CRUD operations for the **repeat_course** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Repeat_courses
    * const repeat_courses = await prisma.repeat_course.findMany()
    * ```
    */
  get repeat_course(): Prisma.repeat_courseDelegate<GlobalReject>;

  /**
   * `prisma.report`: Exposes CRUD operations for the **report** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Reports
    * const reports = await prisma.report.findMany()
    * ```
    */
  get report(): Prisma.reportDelegate<GlobalReject>;

  /**
   * `prisma.sar`: Exposes CRUD operations for the **sar** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Sars
    * const sars = await prisma.sar.findMany()
    * ```
    */
  get sar(): Prisma.sarDelegate<GlobalReject>;

  /**
   * `prisma.staff`: Exposes CRUD operations for the **staff** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Staff
    * const staff = await prisma.staff.findMany()
    * ```
    */
  get staff(): Prisma.staffDelegate<GlobalReject>;

  /**
   * `prisma.student`: Exposes CRUD operations for the **student** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Students
    * const students = await prisma.student.findMany()
    * ```
    */
  get student(): Prisma.studentDelegate<GlobalReject>;

  /**
   * `prisma.subject_report`: Exposes CRUD operations for the **subject_report** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Subject_reports
    * const subject_reports = await prisma.subject_report.findMany()
    * ```
    */
  get subject_report(): Prisma.subject_reportDelegate<GlobalReject>;

  /**
   * `prisma.system_pages`: Exposes CRUD operations for the **system_pages** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more System_pages
    * const system_pages = await prisma.system_pages.findMany()
    * ```
    */
  get system_pages(): Prisma.system_pagesDelegate<GlobalReject>;

  /**
   * `prisma.transcript`: Exposes CRUD operations for the **transcript** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Transcripts
    * const transcripts = await prisma.transcript.findMany()
    * ```
    */
  get transcript(): Prisma.transcriptDelegate<GlobalReject>;

  /**
   * `prisma.user`: Exposes CRUD operations for the **user** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.user.findMany()
    * ```
    */
  get user(): Prisma.userDelegate<GlobalReject>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError
  export import NotFoundError = runtime.NotFoundError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql

  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics 
   */
  export import Metrics = runtime.Metrics
  export import Metric = runtime.Metric
  export import MetricHistogram = runtime.MetricHistogram
  export import MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
   * Prisma Client JS version: 4.2.1
   * Query Engine version: 2920a97877e12e055c1333079b8d19cee7f33826
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion 

  /**
   * Utility Types
   */

  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches a JSON object.
   * This type can be useful to enforce some input to be JSON-compatible or as a super-type to be extended from. 
   */
  export type JsonObject = {[Key in string]?: JsonValue}

  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches a JSON array.
   */
  export interface JsonArray extends Array<JsonValue> {}

  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches any valid JSON value.
   */
  export type JsonValue = string | number | boolean | JsonObject | JsonArray | null

  /**
   * Matches a JSON object.
   * Unlike `JsonObject`, this type allows undefined and read-only properties.
   */
  export type InputJsonObject = {readonly [Key in string]?: InputJsonValue | null}

  /**
   * Matches a JSON array.
   * Unlike `JsonArray`, readonly arrays are assignable to this type.
   */
  export interface InputJsonArray extends ReadonlyArray<InputJsonValue | null> {}

  /**
   * Matches any valid value that can be used as an input for operations like
   * create and update as the value of a JSON field. Unlike `JsonValue`, this
   * type allows read-only arrays and read-only object properties and disallows
   * `null` at the top level.
   *
   * `null` cannot be used as the value of a JSON field because its meaning
   * would be ambiguous. Use `Prisma.JsonNull` to store the JSON null value or
   * `Prisma.DbNull` to clear the JSON value and set the field to the database
   * NULL value instead.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-by-null-values
   */
  export type InputJsonValue = string | number | boolean | InputJsonObject | InputJsonArray

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }
  type HasSelect = {
    select: any
  }
  type HasInclude = {
    include: any
  }
  type CheckSelect<T, S, U> = T extends SelectAndInclude
    ? 'Please either choose `select` or `include`'
    : T extends HasSelect
    ? U
    : T extends HasInclude
    ? U
    : S

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => Promise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = {
    [key in keyof T]: T[key] extends false | undefined | null ? never : key
  }[keyof T]

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Buffer
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Exact<A, W = unknown> = 
  W extends unknown ? A extends Narrowable ? Cast<A, W> : Cast<
  {[K in keyof A]: K extends keyof W ? Exact<A[K], W[K]> : never},
  {[K in keyof W]: K extends keyof A ? Exact<A[K], W[K]> : W[K]}>
  : never;

  type Narrowable = string | number | boolean | bigint;

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;

  export function validator<V>(): <S>(select: Exact<S, V>) => S;

  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but with an array
   */
  type PickArray<T, K extends Array<keyof T>> = Prisma__Pick<T, TupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T

  class PrismaClientFetcher {
    private readonly prisma;
    private readonly debug;
    private readonly hooks?;
    constructor(prisma: PrismaClient<any, any>, debug?: boolean, hooks?: Hooks | undefined);
    request<T>(document: any, dataPath?: string[], rootField?: string, typeName?: string, isList?: boolean, callsite?: string): Promise<T>;
    sanitizeMessage(message: string): string;
    protected unpack(document: any, data: any, path: string[], rootField?: string, isList?: boolean): any;
  }

  export const ModelName: {
    academic_year: 'academic_year',
    admission: 'admission',
    announcement: 'announcement',
    assign_marks: 'assign_marks',
    assignments: 'assignments',
    confirm: 'confirm',
    course: 'course',
    director: 'director',
    exam: 'exam',
    exam_mark: 'exam_mark',
    exam_timetable: 'exam_timetable',
    head_of_exam_board: 'head_of_exam_board',
    lecture_question: 'lecture_question',
    lecturer: 'lecturer',
    lecturer_courses: 'lecturer_courses',
    letter: 'letter',
    ma: 'ma',
    mis_report: 'mis_report',
    paper_marks: 'paper_marks',
    paper_question: 'paper_question',
    payment: 'payment',
    repeat_course: 'repeat_course',
    report: 'report',
    sar: 'sar',
    staff: 'staff',
    student: 'student',
    subject_report: 'subject_report',
    system_pages: 'system_pages',
    transcript: 'transcript',
    user: 'user'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  export type RejectOnNotFound = boolean | ((error: Error) => Error)
  export type RejectPerModel = { [P in ModelName]?: RejectOnNotFound }
  export type RejectPerOperation =  { [P in "findUnique" | "findFirst"]?: RejectPerModel | RejectOnNotFound } 
  type IsReject<T> = T extends true ? True : T extends (err: Error) => Error ? True : False
  export type HasReject<
    GlobalRejectSettings extends Prisma.PrismaClientOptions['rejectOnNotFound'],
    LocalRejectSettings,
    Action extends PrismaAction,
    Model extends ModelName
  > = LocalRejectSettings extends RejectOnNotFound
    ? IsReject<LocalRejectSettings>
    : GlobalRejectSettings extends RejectPerOperation
    ? Action extends keyof GlobalRejectSettings
      ? GlobalRejectSettings[Action] extends RejectOnNotFound
        ? IsReject<GlobalRejectSettings[Action]>
        : GlobalRejectSettings[Action] extends RejectPerModel
        ? Model extends keyof GlobalRejectSettings[Action]
          ? IsReject<GlobalRejectSettings[Action][Model]>
          : False
        : False
      : False
    : IsReject<GlobalRejectSettings>
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'

  export interface PrismaClientOptions {
    /**
     * Configure findUnique/findFirst to throw an error if the query returns null. 
     * @deprecated since 4.0.0. Use `findUniqueOrThrow`/`findFirstOrThrow` methods instead.
     * @example
     * ```
     * // Reject on both findUnique/findFirst
     * rejectOnNotFound: true
     * // Reject only on findFirst with a custom error
     * rejectOnNotFound: { findFirst: (err) => new Error("Custom Error")}
     * // Reject on user.findUnique with a custom error
     * rejectOnNotFound: { findUnique: {User: (err) => new Error("User not found")}}
     * ```
     */
    rejectOnNotFound?: RejectOnNotFound | RejectPerOperation
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources

    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat

    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *  { emit: 'stdout', level: 'query' },
     *  { emit: 'stdout', level: 'info' },
     *  { emit: 'stdout', level: 'warn' }
     *  { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: Array<LogLevel | LogDefinition>
  }

  export type Hooks = {
    beforeRequest?: (options: { query: string, path: string[], rootField?: string, typeName?: string, document: any }) => any
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findMany'
    | 'findFirst'
    | 'create'
    | 'createMany'
    | 'update'
    | 'updateMany'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'

  /**
   * These options are being passed in to the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => Promise<T>,
  ) => Promise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */



  /**
   * Models
   */

  /**
   * Model academic_year
   */


  export type AggregateAcademic_year = {
    _count: Academic_yearCountAggregateOutputType | null
    _avg: Academic_yearAvgAggregateOutputType | null
    _sum: Academic_yearSumAggregateOutputType | null
    _min: Academic_yearMinAggregateOutputType | null
    _max: Academic_yearMaxAggregateOutputType | null
  }

  export type Academic_yearAvgAggregateOutputType = {
    ac_year_ID: number | null
    no_of_student: number | null
    year: number | null
  }

  export type Academic_yearSumAggregateOutputType = {
    ac_year_ID: number | null
    no_of_student: number | null
    year: number | null
  }

  export type Academic_yearMinAggregateOutputType = {
    ac_year_ID: number | null
    no_of_student: number | null
    year: number | null
  }

  export type Academic_yearMaxAggregateOutputType = {
    ac_year_ID: number | null
    no_of_student: number | null
    year: number | null
  }

  export type Academic_yearCountAggregateOutputType = {
    ac_year_ID: number
    no_of_student: number
    year: number
    _all: number
  }


  export type Academic_yearAvgAggregateInputType = {
    ac_year_ID?: true
    no_of_student?: true
    year?: true
  }

  export type Academic_yearSumAggregateInputType = {
    ac_year_ID?: true
    no_of_student?: true
    year?: true
  }

  export type Academic_yearMinAggregateInputType = {
    ac_year_ID?: true
    no_of_student?: true
    year?: true
  }

  export type Academic_yearMaxAggregateInputType = {
    ac_year_ID?: true
    no_of_student?: true
    year?: true
  }

  export type Academic_yearCountAggregateInputType = {
    ac_year_ID?: true
    no_of_student?: true
    year?: true
    _all?: true
  }

  export type Academic_yearAggregateArgs = {
    /**
     * Filter which academic_year to aggregate.
     * 
    **/
    where?: academic_yearWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of academic_years to fetch.
     * 
    **/
    orderBy?: Enumerable<academic_yearOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: academic_yearWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` academic_years from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` academic_years.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned academic_years
    **/
    _count?: true | Academic_yearCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Academic_yearAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Academic_yearSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Academic_yearMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Academic_yearMaxAggregateInputType
  }

  export type GetAcademic_yearAggregateType<T extends Academic_yearAggregateArgs> = {
        [P in keyof T & keyof AggregateAcademic_year]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAcademic_year[P]>
      : GetScalarType<T[P], AggregateAcademic_year[P]>
  }




  export type Academic_yearGroupByArgs = {
    where?: academic_yearWhereInput
    orderBy?: Enumerable<academic_yearOrderByWithAggregationInput>
    by: Array<Academic_yearScalarFieldEnum>
    having?: academic_yearScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Academic_yearCountAggregateInputType | true
    _avg?: Academic_yearAvgAggregateInputType
    _sum?: Academic_yearSumAggregateInputType
    _min?: Academic_yearMinAggregateInputType
    _max?: Academic_yearMaxAggregateInputType
  }


  export type Academic_yearGroupByOutputType = {
    ac_year_ID: number
    no_of_student: number
    year: number
    _count: Academic_yearCountAggregateOutputType | null
    _avg: Academic_yearAvgAggregateOutputType | null
    _sum: Academic_yearSumAggregateOutputType | null
    _min: Academic_yearMinAggregateOutputType | null
    _max: Academic_yearMaxAggregateOutputType | null
  }

  type GetAcademic_yearGroupByPayload<T extends Academic_yearGroupByArgs> = PrismaPromise<
    Array<
      PickArray<Academic_yearGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Academic_yearGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Academic_yearGroupByOutputType[P]>
            : GetScalarType<T[P], Academic_yearGroupByOutputType[P]>
        }
      >
    >


  export type academic_yearSelect = {
    ac_year_ID?: boolean
    no_of_student?: boolean
    year?: boolean
  }

  export type academic_yearGetPayload<
    S extends boolean | null | undefined | academic_yearArgs,
    U = keyof S
      > = S extends true
        ? academic_year
    : S extends undefined
    ? never
    : S extends academic_yearArgs | academic_yearFindManyArgs
    ?'include' extends U
    ? academic_year 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
    P extends keyof academic_year ? academic_year[P] : never
  } 
    : academic_year
  : academic_year


  type academic_yearCountArgs = Merge<
    Omit<academic_yearFindManyArgs, 'select' | 'include'> & {
      select?: Academic_yearCountAggregateInputType | true
    }
  >

  export interface academic_yearDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one Academic_year that matches the filter.
     * @param {academic_yearFindUniqueArgs} args - Arguments to find a Academic_year
     * @example
     * // Get one Academic_year
     * const academic_year = await prisma.academic_year.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends academic_yearFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, academic_yearFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'academic_year'> extends True ? CheckSelect<T, Prisma__academic_yearClient<academic_year>, Prisma__academic_yearClient<academic_yearGetPayload<T>>> : CheckSelect<T, Prisma__academic_yearClient<academic_year | null >, Prisma__academic_yearClient<academic_yearGetPayload<T> | null >>

    /**
     * Find the first Academic_year that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {academic_yearFindFirstArgs} args - Arguments to find a Academic_year
     * @example
     * // Get one Academic_year
     * const academic_year = await prisma.academic_year.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends academic_yearFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, academic_yearFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'academic_year'> extends True ? CheckSelect<T, Prisma__academic_yearClient<academic_year>, Prisma__academic_yearClient<academic_yearGetPayload<T>>> : CheckSelect<T, Prisma__academic_yearClient<academic_year | null >, Prisma__academic_yearClient<academic_yearGetPayload<T> | null >>

    /**
     * Find zero or more Academic_years that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {academic_yearFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Academic_years
     * const academic_years = await prisma.academic_year.findMany()
     * 
     * // Get first 10 Academic_years
     * const academic_years = await prisma.academic_year.findMany({ take: 10 })
     * 
     * // Only select the `ac_year_ID`
     * const academic_yearWithAc_year_IDOnly = await prisma.academic_year.findMany({ select: { ac_year_ID: true } })
     * 
    **/
    findMany<T extends academic_yearFindManyArgs>(
      args?: SelectSubset<T, academic_yearFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<academic_year>>, PrismaPromise<Array<academic_yearGetPayload<T>>>>

    /**
     * Create a Academic_year.
     * @param {academic_yearCreateArgs} args - Arguments to create a Academic_year.
     * @example
     * // Create one Academic_year
     * const Academic_year = await prisma.academic_year.create({
     *   data: {
     *     // ... data to create a Academic_year
     *   }
     * })
     * 
    **/
    create<T extends academic_yearCreateArgs>(
      args: SelectSubset<T, academic_yearCreateArgs>
    ): CheckSelect<T, Prisma__academic_yearClient<academic_year>, Prisma__academic_yearClient<academic_yearGetPayload<T>>>

    /**
     * Create many Academic_years.
     *     @param {academic_yearCreateManyArgs} args - Arguments to create many Academic_years.
     *     @example
     *     // Create many Academic_years
     *     const academic_year = await prisma.academic_year.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends academic_yearCreateManyArgs>(
      args?: SelectSubset<T, academic_yearCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Academic_year.
     * @param {academic_yearDeleteArgs} args - Arguments to delete one Academic_year.
     * @example
     * // Delete one Academic_year
     * const Academic_year = await prisma.academic_year.delete({
     *   where: {
     *     // ... filter to delete one Academic_year
     *   }
     * })
     * 
    **/
    delete<T extends academic_yearDeleteArgs>(
      args: SelectSubset<T, academic_yearDeleteArgs>
    ): CheckSelect<T, Prisma__academic_yearClient<academic_year>, Prisma__academic_yearClient<academic_yearGetPayload<T>>>

    /**
     * Update one Academic_year.
     * @param {academic_yearUpdateArgs} args - Arguments to update one Academic_year.
     * @example
     * // Update one Academic_year
     * const academic_year = await prisma.academic_year.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends academic_yearUpdateArgs>(
      args: SelectSubset<T, academic_yearUpdateArgs>
    ): CheckSelect<T, Prisma__academic_yearClient<academic_year>, Prisma__academic_yearClient<academic_yearGetPayload<T>>>

    /**
     * Delete zero or more Academic_years.
     * @param {academic_yearDeleteManyArgs} args - Arguments to filter Academic_years to delete.
     * @example
     * // Delete a few Academic_years
     * const { count } = await prisma.academic_year.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends academic_yearDeleteManyArgs>(
      args?: SelectSubset<T, academic_yearDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Academic_years.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {academic_yearUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Academic_years
     * const academic_year = await prisma.academic_year.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends academic_yearUpdateManyArgs>(
      args: SelectSubset<T, academic_yearUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Academic_year.
     * @param {academic_yearUpsertArgs} args - Arguments to update or create a Academic_year.
     * @example
     * // Update or create a Academic_year
     * const academic_year = await prisma.academic_year.upsert({
     *   create: {
     *     // ... data to create a Academic_year
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Academic_year we want to update
     *   }
     * })
    **/
    upsert<T extends academic_yearUpsertArgs>(
      args: SelectSubset<T, academic_yearUpsertArgs>
    ): CheckSelect<T, Prisma__academic_yearClient<academic_year>, Prisma__academic_yearClient<academic_yearGetPayload<T>>>

    /**
     * Find one Academic_year that matches the filter or throw
     * `NotFoundError` if no matches were found.
     * @param {academic_yearFindUniqueOrThrowArgs} args - Arguments to find a Academic_year
     * @example
     * // Get one Academic_year
     * const academic_year = await prisma.academic_year.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends academic_yearFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, academic_yearFindUniqueOrThrowArgs>
    ): CheckSelect<T, Prisma__academic_yearClient<academic_year>, Prisma__academic_yearClient<academic_yearGetPayload<T>>>

    /**
     * Find the first Academic_year that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {academic_yearFindFirstOrThrowArgs} args - Arguments to find a Academic_year
     * @example
     * // Get one Academic_year
     * const academic_year = await prisma.academic_year.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends academic_yearFindFirstOrThrowArgs>(
      args?: SelectSubset<T, academic_yearFindFirstOrThrowArgs>
    ): CheckSelect<T, Prisma__academic_yearClient<academic_year>, Prisma__academic_yearClient<academic_yearGetPayload<T>>>

    /**
     * Count the number of Academic_years.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {academic_yearCountArgs} args - Arguments to filter Academic_years to count.
     * @example
     * // Count the number of Academic_years
     * const count = await prisma.academic_year.count({
     *   where: {
     *     // ... the filter for the Academic_years we want to count
     *   }
     * })
    **/
    count<T extends academic_yearCountArgs>(
      args?: Subset<T, academic_yearCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Academic_yearCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Academic_year.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Academic_yearAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Academic_yearAggregateArgs>(args: Subset<T, Academic_yearAggregateArgs>): PrismaPromise<GetAcademic_yearAggregateType<T>>

    /**
     * Group by Academic_year.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Academic_yearGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends Academic_yearGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: Academic_yearGroupByArgs['orderBy'] }
        : { orderBy?: Academic_yearGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, Academic_yearGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAcademic_yearGroupByPayload<T> : PrismaPromise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for academic_year.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__academic_yearClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * academic_year base type for findUnique actions
   */
  export type academic_yearFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the academic_year
     * 
    **/
    select?: academic_yearSelect | null
    /**
     * Filter, which academic_year to fetch.
     * 
    **/
    where: academic_yearWhereUniqueInput
  }

  /**
   * academic_year: findUnique
   */
  export interface academic_yearFindUniqueArgs extends academic_yearFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * academic_year base type for findFirst actions
   */
  export type academic_yearFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the academic_year
     * 
    **/
    select?: academic_yearSelect | null
    /**
     * Filter, which academic_year to fetch.
     * 
    **/
    where?: academic_yearWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of academic_years to fetch.
     * 
    **/
    orderBy?: Enumerable<academic_yearOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for academic_years.
     * 
    **/
    cursor?: academic_yearWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` academic_years from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` academic_years.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of academic_years.
     * 
    **/
    distinct?: Enumerable<Academic_yearScalarFieldEnum>
  }

  /**
   * academic_year: findFirst
   */
  export interface academic_yearFindFirstArgs extends academic_yearFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * academic_year findMany
   */
  export type academic_yearFindManyArgs = {
    /**
     * Select specific fields to fetch from the academic_year
     * 
    **/
    select?: academic_yearSelect | null
    /**
     * Filter, which academic_years to fetch.
     * 
    **/
    where?: academic_yearWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of academic_years to fetch.
     * 
    **/
    orderBy?: Enumerable<academic_yearOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing academic_years.
     * 
    **/
    cursor?: academic_yearWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` academic_years from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` academic_years.
     * 
    **/
    skip?: number
    distinct?: Enumerable<Academic_yearScalarFieldEnum>
  }


  /**
   * academic_year create
   */
  export type academic_yearCreateArgs = {
    /**
     * Select specific fields to fetch from the academic_year
     * 
    **/
    select?: academic_yearSelect | null
    /**
     * The data needed to create a academic_year.
     * 
    **/
    data: XOR<academic_yearCreateInput, academic_yearUncheckedCreateInput>
  }


  /**
   * academic_year createMany
   */
  export type academic_yearCreateManyArgs = {
    /**
     * The data used to create many academic_years.
     * 
    **/
    data: Enumerable<academic_yearCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * academic_year update
   */
  export type academic_yearUpdateArgs = {
    /**
     * Select specific fields to fetch from the academic_year
     * 
    **/
    select?: academic_yearSelect | null
    /**
     * The data needed to update a academic_year.
     * 
    **/
    data: XOR<academic_yearUpdateInput, academic_yearUncheckedUpdateInput>
    /**
     * Choose, which academic_year to update.
     * 
    **/
    where: academic_yearWhereUniqueInput
  }


  /**
   * academic_year updateMany
   */
  export type academic_yearUpdateManyArgs = {
    /**
     * The data used to update academic_years.
     * 
    **/
    data: XOR<academic_yearUpdateManyMutationInput, academic_yearUncheckedUpdateManyInput>
    /**
     * Filter which academic_years to update
     * 
    **/
    where?: academic_yearWhereInput
  }


  /**
   * academic_year upsert
   */
  export type academic_yearUpsertArgs = {
    /**
     * Select specific fields to fetch from the academic_year
     * 
    **/
    select?: academic_yearSelect | null
    /**
     * The filter to search for the academic_year to update in case it exists.
     * 
    **/
    where: academic_yearWhereUniqueInput
    /**
     * In case the academic_year found by the `where` argument doesn't exist, create a new academic_year with this data.
     * 
    **/
    create: XOR<academic_yearCreateInput, academic_yearUncheckedCreateInput>
    /**
     * In case the academic_year was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<academic_yearUpdateInput, academic_yearUncheckedUpdateInput>
  }


  /**
   * academic_year delete
   */
  export type academic_yearDeleteArgs = {
    /**
     * Select specific fields to fetch from the academic_year
     * 
    **/
    select?: academic_yearSelect | null
    /**
     * Filter which academic_year to delete.
     * 
    **/
    where: academic_yearWhereUniqueInput
  }


  /**
   * academic_year deleteMany
   */
  export type academic_yearDeleteManyArgs = {
    /**
     * Filter which academic_years to delete
     * 
    **/
    where?: academic_yearWhereInput
  }


  /**
   * academic_year: findUniqueOrThrow
   */
  export type academic_yearFindUniqueOrThrowArgs = academic_yearFindUniqueArgsBase
      

  /**
   * academic_year: findFirstOrThrow
   */
  export type academic_yearFindFirstOrThrowArgs = academic_yearFindFirstArgsBase
      

  /**
   * academic_year without action
   */
  export type academic_yearArgs = {
    /**
     * Select specific fields to fetch from the academic_year
     * 
    **/
    select?: academic_yearSelect | null
  }



  /**
   * Model admission
   */


  export type AggregateAdmission = {
    _count: AdmissionCountAggregateOutputType | null
    _avg: AdmissionAvgAggregateOutputType | null
    _sum: AdmissionSumAggregateOutputType | null
    _min: AdmissionMinAggregateOutputType | null
    _max: AdmissionMaxAggregateOutputType | null
  }

  export type AdmissionAvgAggregateOutputType = {
    admission_id: number | null
  }

  export type AdmissionSumAggregateOutputType = {
    admission_id: number | null
  }

  export type AdmissionMinAggregateOutputType = {
    admission_id: number | null
    exam_hall: string | null
    course_name: string | null
    course_code: string | null
    exan_date: Date | null
    exam_time: Date | null
    attendence_verify: string | null
  }

  export type AdmissionMaxAggregateOutputType = {
    admission_id: number | null
    exam_hall: string | null
    course_name: string | null
    course_code: string | null
    exan_date: Date | null
    exam_time: Date | null
    attendence_verify: string | null
  }

  export type AdmissionCountAggregateOutputType = {
    admission_id: number
    exam_hall: number
    course_name: number
    course_code: number
    exan_date: number
    exam_time: number
    attendence_verify: number
    _all: number
  }


  export type AdmissionAvgAggregateInputType = {
    admission_id?: true
  }

  export type AdmissionSumAggregateInputType = {
    admission_id?: true
  }

  export type AdmissionMinAggregateInputType = {
    admission_id?: true
    exam_hall?: true
    course_name?: true
    course_code?: true
    exan_date?: true
    exam_time?: true
    attendence_verify?: true
  }

  export type AdmissionMaxAggregateInputType = {
    admission_id?: true
    exam_hall?: true
    course_name?: true
    course_code?: true
    exan_date?: true
    exam_time?: true
    attendence_verify?: true
  }

  export type AdmissionCountAggregateInputType = {
    admission_id?: true
    exam_hall?: true
    course_name?: true
    course_code?: true
    exan_date?: true
    exam_time?: true
    attendence_verify?: true
    _all?: true
  }

  export type AdmissionAggregateArgs = {
    /**
     * Filter which admission to aggregate.
     * 
    **/
    where?: admissionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of admissions to fetch.
     * 
    **/
    orderBy?: Enumerable<admissionOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: admissionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` admissions from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` admissions.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned admissions
    **/
    _count?: true | AdmissionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AdmissionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AdmissionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AdmissionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AdmissionMaxAggregateInputType
  }

  export type GetAdmissionAggregateType<T extends AdmissionAggregateArgs> = {
        [P in keyof T & keyof AggregateAdmission]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAdmission[P]>
      : GetScalarType<T[P], AggregateAdmission[P]>
  }




  export type AdmissionGroupByArgs = {
    where?: admissionWhereInput
    orderBy?: Enumerable<admissionOrderByWithAggregationInput>
    by: Array<AdmissionScalarFieldEnum>
    having?: admissionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AdmissionCountAggregateInputType | true
    _avg?: AdmissionAvgAggregateInputType
    _sum?: AdmissionSumAggregateInputType
    _min?: AdmissionMinAggregateInputType
    _max?: AdmissionMaxAggregateInputType
  }


  export type AdmissionGroupByOutputType = {
    admission_id: number
    exam_hall: string
    course_name: string
    course_code: string
    exan_date: Date
    exam_time: Date
    attendence_verify: string
    _count: AdmissionCountAggregateOutputType | null
    _avg: AdmissionAvgAggregateOutputType | null
    _sum: AdmissionSumAggregateOutputType | null
    _min: AdmissionMinAggregateOutputType | null
    _max: AdmissionMaxAggregateOutputType | null
  }

  type GetAdmissionGroupByPayload<T extends AdmissionGroupByArgs> = PrismaPromise<
    Array<
      PickArray<AdmissionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AdmissionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AdmissionGroupByOutputType[P]>
            : GetScalarType<T[P], AdmissionGroupByOutputType[P]>
        }
      >
    >


  export type admissionSelect = {
    admission_id?: boolean
    exam_hall?: boolean
    course_name?: boolean
    course_code?: boolean
    exan_date?: boolean
    exam_time?: boolean
    attendence_verify?: boolean
  }

  export type admissionGetPayload<
    S extends boolean | null | undefined | admissionArgs,
    U = keyof S
      > = S extends true
        ? admission
    : S extends undefined
    ? never
    : S extends admissionArgs | admissionFindManyArgs
    ?'include' extends U
    ? admission 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
    P extends keyof admission ? admission[P] : never
  } 
    : admission
  : admission


  type admissionCountArgs = Merge<
    Omit<admissionFindManyArgs, 'select' | 'include'> & {
      select?: AdmissionCountAggregateInputType | true
    }
  >

  export interface admissionDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one Admission that matches the filter.
     * @param {admissionFindUniqueArgs} args - Arguments to find a Admission
     * @example
     * // Get one Admission
     * const admission = await prisma.admission.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends admissionFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, admissionFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'admission'> extends True ? CheckSelect<T, Prisma__admissionClient<admission>, Prisma__admissionClient<admissionGetPayload<T>>> : CheckSelect<T, Prisma__admissionClient<admission | null >, Prisma__admissionClient<admissionGetPayload<T> | null >>

    /**
     * Find the first Admission that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {admissionFindFirstArgs} args - Arguments to find a Admission
     * @example
     * // Get one Admission
     * const admission = await prisma.admission.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends admissionFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, admissionFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'admission'> extends True ? CheckSelect<T, Prisma__admissionClient<admission>, Prisma__admissionClient<admissionGetPayload<T>>> : CheckSelect<T, Prisma__admissionClient<admission | null >, Prisma__admissionClient<admissionGetPayload<T> | null >>

    /**
     * Find zero or more Admissions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {admissionFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Admissions
     * const admissions = await prisma.admission.findMany()
     * 
     * // Get first 10 Admissions
     * const admissions = await prisma.admission.findMany({ take: 10 })
     * 
     * // Only select the `admission_id`
     * const admissionWithAdmission_idOnly = await prisma.admission.findMany({ select: { admission_id: true } })
     * 
    **/
    findMany<T extends admissionFindManyArgs>(
      args?: SelectSubset<T, admissionFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<admission>>, PrismaPromise<Array<admissionGetPayload<T>>>>

    /**
     * Create a Admission.
     * @param {admissionCreateArgs} args - Arguments to create a Admission.
     * @example
     * // Create one Admission
     * const Admission = await prisma.admission.create({
     *   data: {
     *     // ... data to create a Admission
     *   }
     * })
     * 
    **/
    create<T extends admissionCreateArgs>(
      args: SelectSubset<T, admissionCreateArgs>
    ): CheckSelect<T, Prisma__admissionClient<admission>, Prisma__admissionClient<admissionGetPayload<T>>>

    /**
     * Create many Admissions.
     *     @param {admissionCreateManyArgs} args - Arguments to create many Admissions.
     *     @example
     *     // Create many Admissions
     *     const admission = await prisma.admission.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends admissionCreateManyArgs>(
      args?: SelectSubset<T, admissionCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Admission.
     * @param {admissionDeleteArgs} args - Arguments to delete one Admission.
     * @example
     * // Delete one Admission
     * const Admission = await prisma.admission.delete({
     *   where: {
     *     // ... filter to delete one Admission
     *   }
     * })
     * 
    **/
    delete<T extends admissionDeleteArgs>(
      args: SelectSubset<T, admissionDeleteArgs>
    ): CheckSelect<T, Prisma__admissionClient<admission>, Prisma__admissionClient<admissionGetPayload<T>>>

    /**
     * Update one Admission.
     * @param {admissionUpdateArgs} args - Arguments to update one Admission.
     * @example
     * // Update one Admission
     * const admission = await prisma.admission.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends admissionUpdateArgs>(
      args: SelectSubset<T, admissionUpdateArgs>
    ): CheckSelect<T, Prisma__admissionClient<admission>, Prisma__admissionClient<admissionGetPayload<T>>>

    /**
     * Delete zero or more Admissions.
     * @param {admissionDeleteManyArgs} args - Arguments to filter Admissions to delete.
     * @example
     * // Delete a few Admissions
     * const { count } = await prisma.admission.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends admissionDeleteManyArgs>(
      args?: SelectSubset<T, admissionDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Admissions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {admissionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Admissions
     * const admission = await prisma.admission.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends admissionUpdateManyArgs>(
      args: SelectSubset<T, admissionUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Admission.
     * @param {admissionUpsertArgs} args - Arguments to update or create a Admission.
     * @example
     * // Update or create a Admission
     * const admission = await prisma.admission.upsert({
     *   create: {
     *     // ... data to create a Admission
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Admission we want to update
     *   }
     * })
    **/
    upsert<T extends admissionUpsertArgs>(
      args: SelectSubset<T, admissionUpsertArgs>
    ): CheckSelect<T, Prisma__admissionClient<admission>, Prisma__admissionClient<admissionGetPayload<T>>>

    /**
     * Find one Admission that matches the filter or throw
     * `NotFoundError` if no matches were found.
     * @param {admissionFindUniqueOrThrowArgs} args - Arguments to find a Admission
     * @example
     * // Get one Admission
     * const admission = await prisma.admission.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends admissionFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, admissionFindUniqueOrThrowArgs>
    ): CheckSelect<T, Prisma__admissionClient<admission>, Prisma__admissionClient<admissionGetPayload<T>>>

    /**
     * Find the first Admission that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {admissionFindFirstOrThrowArgs} args - Arguments to find a Admission
     * @example
     * // Get one Admission
     * const admission = await prisma.admission.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends admissionFindFirstOrThrowArgs>(
      args?: SelectSubset<T, admissionFindFirstOrThrowArgs>
    ): CheckSelect<T, Prisma__admissionClient<admission>, Prisma__admissionClient<admissionGetPayload<T>>>

    /**
     * Count the number of Admissions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {admissionCountArgs} args - Arguments to filter Admissions to count.
     * @example
     * // Count the number of Admissions
     * const count = await prisma.admission.count({
     *   where: {
     *     // ... the filter for the Admissions we want to count
     *   }
     * })
    **/
    count<T extends admissionCountArgs>(
      args?: Subset<T, admissionCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AdmissionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Admission.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdmissionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AdmissionAggregateArgs>(args: Subset<T, AdmissionAggregateArgs>): PrismaPromise<GetAdmissionAggregateType<T>>

    /**
     * Group by Admission.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdmissionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AdmissionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AdmissionGroupByArgs['orderBy'] }
        : { orderBy?: AdmissionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AdmissionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAdmissionGroupByPayload<T> : PrismaPromise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for admission.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__admissionClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * admission base type for findUnique actions
   */
  export type admissionFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the admission
     * 
    **/
    select?: admissionSelect | null
    /**
     * Filter, which admission to fetch.
     * 
    **/
    where: admissionWhereUniqueInput
  }

  /**
   * admission: findUnique
   */
  export interface admissionFindUniqueArgs extends admissionFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * admission base type for findFirst actions
   */
  export type admissionFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the admission
     * 
    **/
    select?: admissionSelect | null
    /**
     * Filter, which admission to fetch.
     * 
    **/
    where?: admissionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of admissions to fetch.
     * 
    **/
    orderBy?: Enumerable<admissionOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for admissions.
     * 
    **/
    cursor?: admissionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` admissions from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` admissions.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of admissions.
     * 
    **/
    distinct?: Enumerable<AdmissionScalarFieldEnum>
  }

  /**
   * admission: findFirst
   */
  export interface admissionFindFirstArgs extends admissionFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * admission findMany
   */
  export type admissionFindManyArgs = {
    /**
     * Select specific fields to fetch from the admission
     * 
    **/
    select?: admissionSelect | null
    /**
     * Filter, which admissions to fetch.
     * 
    **/
    where?: admissionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of admissions to fetch.
     * 
    **/
    orderBy?: Enumerable<admissionOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing admissions.
     * 
    **/
    cursor?: admissionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` admissions from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` admissions.
     * 
    **/
    skip?: number
    distinct?: Enumerable<AdmissionScalarFieldEnum>
  }


  /**
   * admission create
   */
  export type admissionCreateArgs = {
    /**
     * Select specific fields to fetch from the admission
     * 
    **/
    select?: admissionSelect | null
    /**
     * The data needed to create a admission.
     * 
    **/
    data: XOR<admissionCreateInput, admissionUncheckedCreateInput>
  }


  /**
   * admission createMany
   */
  export type admissionCreateManyArgs = {
    /**
     * The data used to create many admissions.
     * 
    **/
    data: Enumerable<admissionCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * admission update
   */
  export type admissionUpdateArgs = {
    /**
     * Select specific fields to fetch from the admission
     * 
    **/
    select?: admissionSelect | null
    /**
     * The data needed to update a admission.
     * 
    **/
    data: XOR<admissionUpdateInput, admissionUncheckedUpdateInput>
    /**
     * Choose, which admission to update.
     * 
    **/
    where: admissionWhereUniqueInput
  }


  /**
   * admission updateMany
   */
  export type admissionUpdateManyArgs = {
    /**
     * The data used to update admissions.
     * 
    **/
    data: XOR<admissionUpdateManyMutationInput, admissionUncheckedUpdateManyInput>
    /**
     * Filter which admissions to update
     * 
    **/
    where?: admissionWhereInput
  }


  /**
   * admission upsert
   */
  export type admissionUpsertArgs = {
    /**
     * Select specific fields to fetch from the admission
     * 
    **/
    select?: admissionSelect | null
    /**
     * The filter to search for the admission to update in case it exists.
     * 
    **/
    where: admissionWhereUniqueInput
    /**
     * In case the admission found by the `where` argument doesn't exist, create a new admission with this data.
     * 
    **/
    create: XOR<admissionCreateInput, admissionUncheckedCreateInput>
    /**
     * In case the admission was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<admissionUpdateInput, admissionUncheckedUpdateInput>
  }


  /**
   * admission delete
   */
  export type admissionDeleteArgs = {
    /**
     * Select specific fields to fetch from the admission
     * 
    **/
    select?: admissionSelect | null
    /**
     * Filter which admission to delete.
     * 
    **/
    where: admissionWhereUniqueInput
  }


  /**
   * admission deleteMany
   */
  export type admissionDeleteManyArgs = {
    /**
     * Filter which admissions to delete
     * 
    **/
    where?: admissionWhereInput
  }


  /**
   * admission: findUniqueOrThrow
   */
  export type admissionFindUniqueOrThrowArgs = admissionFindUniqueArgsBase
      

  /**
   * admission: findFirstOrThrow
   */
  export type admissionFindFirstOrThrowArgs = admissionFindFirstArgsBase
      

  /**
   * admission without action
   */
  export type admissionArgs = {
    /**
     * Select specific fields to fetch from the admission
     * 
    **/
    select?: admissionSelect | null
  }



  /**
   * Model announcement
   */


  export type AggregateAnnouncement = {
    _count: AnnouncementCountAggregateOutputType | null
    _avg: AnnouncementAvgAggregateOutputType | null
    _sum: AnnouncementSumAggregateOutputType | null
    _min: AnnouncementMinAggregateOutputType | null
    _max: AnnouncementMaxAggregateOutputType | null
  }

  export type AnnouncementAvgAggregateOutputType = {
    annou_id: number | null
    admin_id: number | null
  }

  export type AnnouncementSumAggregateOutputType = {
    annou_id: number | null
    admin_id: number | null
  }

  export type AnnouncementMinAggregateOutputType = {
    annou_id: number | null
    content: string | null
    admin_id: number | null
  }

  export type AnnouncementMaxAggregateOutputType = {
    annou_id: number | null
    content: string | null
    admin_id: number | null
  }

  export type AnnouncementCountAggregateOutputType = {
    annou_id: number
    content: number
    admin_id: number
    _all: number
  }


  export type AnnouncementAvgAggregateInputType = {
    annou_id?: true
    admin_id?: true
  }

  export type AnnouncementSumAggregateInputType = {
    annou_id?: true
    admin_id?: true
  }

  export type AnnouncementMinAggregateInputType = {
    annou_id?: true
    content?: true
    admin_id?: true
  }

  export type AnnouncementMaxAggregateInputType = {
    annou_id?: true
    content?: true
    admin_id?: true
  }

  export type AnnouncementCountAggregateInputType = {
    annou_id?: true
    content?: true
    admin_id?: true
    _all?: true
  }

  export type AnnouncementAggregateArgs = {
    /**
     * Filter which announcement to aggregate.
     * 
    **/
    where?: announcementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of announcements to fetch.
     * 
    **/
    orderBy?: Enumerable<announcementOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: announcementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` announcements from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` announcements.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned announcements
    **/
    _count?: true | AnnouncementCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AnnouncementAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AnnouncementSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AnnouncementMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AnnouncementMaxAggregateInputType
  }

  export type GetAnnouncementAggregateType<T extends AnnouncementAggregateArgs> = {
        [P in keyof T & keyof AggregateAnnouncement]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAnnouncement[P]>
      : GetScalarType<T[P], AggregateAnnouncement[P]>
  }




  export type AnnouncementGroupByArgs = {
    where?: announcementWhereInput
    orderBy?: Enumerable<announcementOrderByWithAggregationInput>
    by: Array<AnnouncementScalarFieldEnum>
    having?: announcementScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AnnouncementCountAggregateInputType | true
    _avg?: AnnouncementAvgAggregateInputType
    _sum?: AnnouncementSumAggregateInputType
    _min?: AnnouncementMinAggregateInputType
    _max?: AnnouncementMaxAggregateInputType
  }


  export type AnnouncementGroupByOutputType = {
    annou_id: number
    content: string
    admin_id: number
    _count: AnnouncementCountAggregateOutputType | null
    _avg: AnnouncementAvgAggregateOutputType | null
    _sum: AnnouncementSumAggregateOutputType | null
    _min: AnnouncementMinAggregateOutputType | null
    _max: AnnouncementMaxAggregateOutputType | null
  }

  type GetAnnouncementGroupByPayload<T extends AnnouncementGroupByArgs> = PrismaPromise<
    Array<
      PickArray<AnnouncementGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AnnouncementGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AnnouncementGroupByOutputType[P]>
            : GetScalarType<T[P], AnnouncementGroupByOutputType[P]>
        }
      >
    >


  export type announcementSelect = {
    annou_id?: boolean
    content?: boolean
    admin_id?: boolean
  }

  export type announcementGetPayload<
    S extends boolean | null | undefined | announcementArgs,
    U = keyof S
      > = S extends true
        ? announcement
    : S extends undefined
    ? never
    : S extends announcementArgs | announcementFindManyArgs
    ?'include' extends U
    ? announcement 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
    P extends keyof announcement ? announcement[P] : never
  } 
    : announcement
  : announcement


  type announcementCountArgs = Merge<
    Omit<announcementFindManyArgs, 'select' | 'include'> & {
      select?: AnnouncementCountAggregateInputType | true
    }
  >

  export interface announcementDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one Announcement that matches the filter.
     * @param {announcementFindUniqueArgs} args - Arguments to find a Announcement
     * @example
     * // Get one Announcement
     * const announcement = await prisma.announcement.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends announcementFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, announcementFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'announcement'> extends True ? CheckSelect<T, Prisma__announcementClient<announcement>, Prisma__announcementClient<announcementGetPayload<T>>> : CheckSelect<T, Prisma__announcementClient<announcement | null >, Prisma__announcementClient<announcementGetPayload<T> | null >>

    /**
     * Find the first Announcement that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {announcementFindFirstArgs} args - Arguments to find a Announcement
     * @example
     * // Get one Announcement
     * const announcement = await prisma.announcement.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends announcementFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, announcementFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'announcement'> extends True ? CheckSelect<T, Prisma__announcementClient<announcement>, Prisma__announcementClient<announcementGetPayload<T>>> : CheckSelect<T, Prisma__announcementClient<announcement | null >, Prisma__announcementClient<announcementGetPayload<T> | null >>

    /**
     * Find zero or more Announcements that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {announcementFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Announcements
     * const announcements = await prisma.announcement.findMany()
     * 
     * // Get first 10 Announcements
     * const announcements = await prisma.announcement.findMany({ take: 10 })
     * 
     * // Only select the `annou_id`
     * const announcementWithAnnou_idOnly = await prisma.announcement.findMany({ select: { annou_id: true } })
     * 
    **/
    findMany<T extends announcementFindManyArgs>(
      args?: SelectSubset<T, announcementFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<announcement>>, PrismaPromise<Array<announcementGetPayload<T>>>>

    /**
     * Create a Announcement.
     * @param {announcementCreateArgs} args - Arguments to create a Announcement.
     * @example
     * // Create one Announcement
     * const Announcement = await prisma.announcement.create({
     *   data: {
     *     // ... data to create a Announcement
     *   }
     * })
     * 
    **/
    create<T extends announcementCreateArgs>(
      args: SelectSubset<T, announcementCreateArgs>
    ): CheckSelect<T, Prisma__announcementClient<announcement>, Prisma__announcementClient<announcementGetPayload<T>>>

    /**
     * Create many Announcements.
     *     @param {announcementCreateManyArgs} args - Arguments to create many Announcements.
     *     @example
     *     // Create many Announcements
     *     const announcement = await prisma.announcement.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends announcementCreateManyArgs>(
      args?: SelectSubset<T, announcementCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Announcement.
     * @param {announcementDeleteArgs} args - Arguments to delete one Announcement.
     * @example
     * // Delete one Announcement
     * const Announcement = await prisma.announcement.delete({
     *   where: {
     *     // ... filter to delete one Announcement
     *   }
     * })
     * 
    **/
    delete<T extends announcementDeleteArgs>(
      args: SelectSubset<T, announcementDeleteArgs>
    ): CheckSelect<T, Prisma__announcementClient<announcement>, Prisma__announcementClient<announcementGetPayload<T>>>

    /**
     * Update one Announcement.
     * @param {announcementUpdateArgs} args - Arguments to update one Announcement.
     * @example
     * // Update one Announcement
     * const announcement = await prisma.announcement.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends announcementUpdateArgs>(
      args: SelectSubset<T, announcementUpdateArgs>
    ): CheckSelect<T, Prisma__announcementClient<announcement>, Prisma__announcementClient<announcementGetPayload<T>>>

    /**
     * Delete zero or more Announcements.
     * @param {announcementDeleteManyArgs} args - Arguments to filter Announcements to delete.
     * @example
     * // Delete a few Announcements
     * const { count } = await prisma.announcement.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends announcementDeleteManyArgs>(
      args?: SelectSubset<T, announcementDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Announcements.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {announcementUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Announcements
     * const announcement = await prisma.announcement.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends announcementUpdateManyArgs>(
      args: SelectSubset<T, announcementUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Announcement.
     * @param {announcementUpsertArgs} args - Arguments to update or create a Announcement.
     * @example
     * // Update or create a Announcement
     * const announcement = await prisma.announcement.upsert({
     *   create: {
     *     // ... data to create a Announcement
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Announcement we want to update
     *   }
     * })
    **/
    upsert<T extends announcementUpsertArgs>(
      args: SelectSubset<T, announcementUpsertArgs>
    ): CheckSelect<T, Prisma__announcementClient<announcement>, Prisma__announcementClient<announcementGetPayload<T>>>

    /**
     * Find one Announcement that matches the filter or throw
     * `NotFoundError` if no matches were found.
     * @param {announcementFindUniqueOrThrowArgs} args - Arguments to find a Announcement
     * @example
     * // Get one Announcement
     * const announcement = await prisma.announcement.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends announcementFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, announcementFindUniqueOrThrowArgs>
    ): CheckSelect<T, Prisma__announcementClient<announcement>, Prisma__announcementClient<announcementGetPayload<T>>>

    /**
     * Find the first Announcement that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {announcementFindFirstOrThrowArgs} args - Arguments to find a Announcement
     * @example
     * // Get one Announcement
     * const announcement = await prisma.announcement.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends announcementFindFirstOrThrowArgs>(
      args?: SelectSubset<T, announcementFindFirstOrThrowArgs>
    ): CheckSelect<T, Prisma__announcementClient<announcement>, Prisma__announcementClient<announcementGetPayload<T>>>

    /**
     * Count the number of Announcements.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {announcementCountArgs} args - Arguments to filter Announcements to count.
     * @example
     * // Count the number of Announcements
     * const count = await prisma.announcement.count({
     *   where: {
     *     // ... the filter for the Announcements we want to count
     *   }
     * })
    **/
    count<T extends announcementCountArgs>(
      args?: Subset<T, announcementCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AnnouncementCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Announcement.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AnnouncementAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AnnouncementAggregateArgs>(args: Subset<T, AnnouncementAggregateArgs>): PrismaPromise<GetAnnouncementAggregateType<T>>

    /**
     * Group by Announcement.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AnnouncementGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AnnouncementGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AnnouncementGroupByArgs['orderBy'] }
        : { orderBy?: AnnouncementGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AnnouncementGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAnnouncementGroupByPayload<T> : PrismaPromise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for announcement.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__announcementClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * announcement base type for findUnique actions
   */
  export type announcementFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the announcement
     * 
    **/
    select?: announcementSelect | null
    /**
     * Filter, which announcement to fetch.
     * 
    **/
    where: announcementWhereUniqueInput
  }

  /**
   * announcement: findUnique
   */
  export interface announcementFindUniqueArgs extends announcementFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * announcement base type for findFirst actions
   */
  export type announcementFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the announcement
     * 
    **/
    select?: announcementSelect | null
    /**
     * Filter, which announcement to fetch.
     * 
    **/
    where?: announcementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of announcements to fetch.
     * 
    **/
    orderBy?: Enumerable<announcementOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for announcements.
     * 
    **/
    cursor?: announcementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` announcements from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` announcements.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of announcements.
     * 
    **/
    distinct?: Enumerable<AnnouncementScalarFieldEnum>
  }

  /**
   * announcement: findFirst
   */
  export interface announcementFindFirstArgs extends announcementFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * announcement findMany
   */
  export type announcementFindManyArgs = {
    /**
     * Select specific fields to fetch from the announcement
     * 
    **/
    select?: announcementSelect | null
    /**
     * Filter, which announcements to fetch.
     * 
    **/
    where?: announcementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of announcements to fetch.
     * 
    **/
    orderBy?: Enumerable<announcementOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing announcements.
     * 
    **/
    cursor?: announcementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` announcements from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` announcements.
     * 
    **/
    skip?: number
    distinct?: Enumerable<AnnouncementScalarFieldEnum>
  }


  /**
   * announcement create
   */
  export type announcementCreateArgs = {
    /**
     * Select specific fields to fetch from the announcement
     * 
    **/
    select?: announcementSelect | null
    /**
     * The data needed to create a announcement.
     * 
    **/
    data: XOR<announcementCreateInput, announcementUncheckedCreateInput>
  }


  /**
   * announcement createMany
   */
  export type announcementCreateManyArgs = {
    /**
     * The data used to create many announcements.
     * 
    **/
    data: Enumerable<announcementCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * announcement update
   */
  export type announcementUpdateArgs = {
    /**
     * Select specific fields to fetch from the announcement
     * 
    **/
    select?: announcementSelect | null
    /**
     * The data needed to update a announcement.
     * 
    **/
    data: XOR<announcementUpdateInput, announcementUncheckedUpdateInput>
    /**
     * Choose, which announcement to update.
     * 
    **/
    where: announcementWhereUniqueInput
  }


  /**
   * announcement updateMany
   */
  export type announcementUpdateManyArgs = {
    /**
     * The data used to update announcements.
     * 
    **/
    data: XOR<announcementUpdateManyMutationInput, announcementUncheckedUpdateManyInput>
    /**
     * Filter which announcements to update
     * 
    **/
    where?: announcementWhereInput
  }


  /**
   * announcement upsert
   */
  export type announcementUpsertArgs = {
    /**
     * Select specific fields to fetch from the announcement
     * 
    **/
    select?: announcementSelect | null
    /**
     * The filter to search for the announcement to update in case it exists.
     * 
    **/
    where: announcementWhereUniqueInput
    /**
     * In case the announcement found by the `where` argument doesn't exist, create a new announcement with this data.
     * 
    **/
    create: XOR<announcementCreateInput, announcementUncheckedCreateInput>
    /**
     * In case the announcement was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<announcementUpdateInput, announcementUncheckedUpdateInput>
  }


  /**
   * announcement delete
   */
  export type announcementDeleteArgs = {
    /**
     * Select specific fields to fetch from the announcement
     * 
    **/
    select?: announcementSelect | null
    /**
     * Filter which announcement to delete.
     * 
    **/
    where: announcementWhereUniqueInput
  }


  /**
   * announcement deleteMany
   */
  export type announcementDeleteManyArgs = {
    /**
     * Filter which announcements to delete
     * 
    **/
    where?: announcementWhereInput
  }


  /**
   * announcement: findUniqueOrThrow
   */
  export type announcementFindUniqueOrThrowArgs = announcementFindUniqueArgsBase
      

  /**
   * announcement: findFirstOrThrow
   */
  export type announcementFindFirstOrThrowArgs = announcementFindFirstArgsBase
      

  /**
   * announcement without action
   */
  export type announcementArgs = {
    /**
     * Select specific fields to fetch from the announcement
     * 
    **/
    select?: announcementSelect | null
  }



  /**
   * Model assign_marks
   */


  export type AggregateAssign_marks = {
    _count: Assign_marksCountAggregateOutputType | null
    _avg: Assign_marksAvgAggregateOutputType | null
    _sum: Assign_marksSumAggregateOutputType | null
    _min: Assign_marksMinAggregateOutputType | null
    _max: Assign_marksMaxAggregateOutputType | null
  }

  export type Assign_marksAvgAggregateOutputType = {
    assigment_id: number | null
    sub_marks: number | null
    total_marks: number | null
    assign_precentage: number | null
    mark_id: number | null
  }

  export type Assign_marksSumAggregateOutputType = {
    assigment_id: number | null
    sub_marks: number | null
    total_marks: number | null
    assign_precentage: number | null
    mark_id: number | null
  }

  export type Assign_marksMinAggregateOutputType = {
    assigment_id: number | null
    sub_marks: number | null
    total_marks: number | null
    assign_precentage: number | null
    mark_id: number | null
  }

  export type Assign_marksMaxAggregateOutputType = {
    assigment_id: number | null
    sub_marks: number | null
    total_marks: number | null
    assign_precentage: number | null
    mark_id: number | null
  }

  export type Assign_marksCountAggregateOutputType = {
    assigment_id: number
    sub_marks: number
    total_marks: number
    assign_precentage: number
    mark_id: number
    _all: number
  }


  export type Assign_marksAvgAggregateInputType = {
    assigment_id?: true
    sub_marks?: true
    total_marks?: true
    assign_precentage?: true
    mark_id?: true
  }

  export type Assign_marksSumAggregateInputType = {
    assigment_id?: true
    sub_marks?: true
    total_marks?: true
    assign_precentage?: true
    mark_id?: true
  }

  export type Assign_marksMinAggregateInputType = {
    assigment_id?: true
    sub_marks?: true
    total_marks?: true
    assign_precentage?: true
    mark_id?: true
  }

  export type Assign_marksMaxAggregateInputType = {
    assigment_id?: true
    sub_marks?: true
    total_marks?: true
    assign_precentage?: true
    mark_id?: true
  }

  export type Assign_marksCountAggregateInputType = {
    assigment_id?: true
    sub_marks?: true
    total_marks?: true
    assign_precentage?: true
    mark_id?: true
    _all?: true
  }

  export type Assign_marksAggregateArgs = {
    /**
     * Filter which assign_marks to aggregate.
     * 
    **/
    where?: assign_marksWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of assign_marks to fetch.
     * 
    **/
    orderBy?: Enumerable<assign_marksOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: assign_marksWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` assign_marks from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` assign_marks.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned assign_marks
    **/
    _count?: true | Assign_marksCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Assign_marksAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Assign_marksSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Assign_marksMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Assign_marksMaxAggregateInputType
  }

  export type GetAssign_marksAggregateType<T extends Assign_marksAggregateArgs> = {
        [P in keyof T & keyof AggregateAssign_marks]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAssign_marks[P]>
      : GetScalarType<T[P], AggregateAssign_marks[P]>
  }




  export type Assign_marksGroupByArgs = {
    where?: assign_marksWhereInput
    orderBy?: Enumerable<assign_marksOrderByWithAggregationInput>
    by: Array<Assign_marksScalarFieldEnum>
    having?: assign_marksScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Assign_marksCountAggregateInputType | true
    _avg?: Assign_marksAvgAggregateInputType
    _sum?: Assign_marksSumAggregateInputType
    _min?: Assign_marksMinAggregateInputType
    _max?: Assign_marksMaxAggregateInputType
  }


  export type Assign_marksGroupByOutputType = {
    assigment_id: number
    sub_marks: number
    total_marks: number
    assign_precentage: number
    mark_id: number
    _count: Assign_marksCountAggregateOutputType | null
    _avg: Assign_marksAvgAggregateOutputType | null
    _sum: Assign_marksSumAggregateOutputType | null
    _min: Assign_marksMinAggregateOutputType | null
    _max: Assign_marksMaxAggregateOutputType | null
  }

  type GetAssign_marksGroupByPayload<T extends Assign_marksGroupByArgs> = PrismaPromise<
    Array<
      PickArray<Assign_marksGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Assign_marksGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Assign_marksGroupByOutputType[P]>
            : GetScalarType<T[P], Assign_marksGroupByOutputType[P]>
        }
      >
    >


  export type assign_marksSelect = {
    assigment_id?: boolean
    sub_marks?: boolean
    total_marks?: boolean
    assign_precentage?: boolean
    mark_id?: boolean
  }

  export type assign_marksGetPayload<
    S extends boolean | null | undefined | assign_marksArgs,
    U = keyof S
      > = S extends true
        ? assign_marks
    : S extends undefined
    ? never
    : S extends assign_marksArgs | assign_marksFindManyArgs
    ?'include' extends U
    ? assign_marks 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
    P extends keyof assign_marks ? assign_marks[P] : never
  } 
    : assign_marks
  : assign_marks


  type assign_marksCountArgs = Merge<
    Omit<assign_marksFindManyArgs, 'select' | 'include'> & {
      select?: Assign_marksCountAggregateInputType | true
    }
  >

  export interface assign_marksDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one Assign_marks that matches the filter.
     * @param {assign_marksFindUniqueArgs} args - Arguments to find a Assign_marks
     * @example
     * // Get one Assign_marks
     * const assign_marks = await prisma.assign_marks.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends assign_marksFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, assign_marksFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'assign_marks'> extends True ? CheckSelect<T, Prisma__assign_marksClient<assign_marks>, Prisma__assign_marksClient<assign_marksGetPayload<T>>> : CheckSelect<T, Prisma__assign_marksClient<assign_marks | null >, Prisma__assign_marksClient<assign_marksGetPayload<T> | null >>

    /**
     * Find the first Assign_marks that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {assign_marksFindFirstArgs} args - Arguments to find a Assign_marks
     * @example
     * // Get one Assign_marks
     * const assign_marks = await prisma.assign_marks.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends assign_marksFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, assign_marksFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'assign_marks'> extends True ? CheckSelect<T, Prisma__assign_marksClient<assign_marks>, Prisma__assign_marksClient<assign_marksGetPayload<T>>> : CheckSelect<T, Prisma__assign_marksClient<assign_marks | null >, Prisma__assign_marksClient<assign_marksGetPayload<T> | null >>

    /**
     * Find zero or more Assign_marks that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {assign_marksFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Assign_marks
     * const assign_marks = await prisma.assign_marks.findMany()
     * 
     * // Get first 10 Assign_marks
     * const assign_marks = await prisma.assign_marks.findMany({ take: 10 })
     * 
     * // Only select the `assigment_id`
     * const assign_marksWithAssigment_idOnly = await prisma.assign_marks.findMany({ select: { assigment_id: true } })
     * 
    **/
    findMany<T extends assign_marksFindManyArgs>(
      args?: SelectSubset<T, assign_marksFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<assign_marks>>, PrismaPromise<Array<assign_marksGetPayload<T>>>>

    /**
     * Create a Assign_marks.
     * @param {assign_marksCreateArgs} args - Arguments to create a Assign_marks.
     * @example
     * // Create one Assign_marks
     * const Assign_marks = await prisma.assign_marks.create({
     *   data: {
     *     // ... data to create a Assign_marks
     *   }
     * })
     * 
    **/
    create<T extends assign_marksCreateArgs>(
      args: SelectSubset<T, assign_marksCreateArgs>
    ): CheckSelect<T, Prisma__assign_marksClient<assign_marks>, Prisma__assign_marksClient<assign_marksGetPayload<T>>>

    /**
     * Create many Assign_marks.
     *     @param {assign_marksCreateManyArgs} args - Arguments to create many Assign_marks.
     *     @example
     *     // Create many Assign_marks
     *     const assign_marks = await prisma.assign_marks.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends assign_marksCreateManyArgs>(
      args?: SelectSubset<T, assign_marksCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Assign_marks.
     * @param {assign_marksDeleteArgs} args - Arguments to delete one Assign_marks.
     * @example
     * // Delete one Assign_marks
     * const Assign_marks = await prisma.assign_marks.delete({
     *   where: {
     *     // ... filter to delete one Assign_marks
     *   }
     * })
     * 
    **/
    delete<T extends assign_marksDeleteArgs>(
      args: SelectSubset<T, assign_marksDeleteArgs>
    ): CheckSelect<T, Prisma__assign_marksClient<assign_marks>, Prisma__assign_marksClient<assign_marksGetPayload<T>>>

    /**
     * Update one Assign_marks.
     * @param {assign_marksUpdateArgs} args - Arguments to update one Assign_marks.
     * @example
     * // Update one Assign_marks
     * const assign_marks = await prisma.assign_marks.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends assign_marksUpdateArgs>(
      args: SelectSubset<T, assign_marksUpdateArgs>
    ): CheckSelect<T, Prisma__assign_marksClient<assign_marks>, Prisma__assign_marksClient<assign_marksGetPayload<T>>>

    /**
     * Delete zero or more Assign_marks.
     * @param {assign_marksDeleteManyArgs} args - Arguments to filter Assign_marks to delete.
     * @example
     * // Delete a few Assign_marks
     * const { count } = await prisma.assign_marks.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends assign_marksDeleteManyArgs>(
      args?: SelectSubset<T, assign_marksDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Assign_marks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {assign_marksUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Assign_marks
     * const assign_marks = await prisma.assign_marks.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends assign_marksUpdateManyArgs>(
      args: SelectSubset<T, assign_marksUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Assign_marks.
     * @param {assign_marksUpsertArgs} args - Arguments to update or create a Assign_marks.
     * @example
     * // Update or create a Assign_marks
     * const assign_marks = await prisma.assign_marks.upsert({
     *   create: {
     *     // ... data to create a Assign_marks
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Assign_marks we want to update
     *   }
     * })
    **/
    upsert<T extends assign_marksUpsertArgs>(
      args: SelectSubset<T, assign_marksUpsertArgs>
    ): CheckSelect<T, Prisma__assign_marksClient<assign_marks>, Prisma__assign_marksClient<assign_marksGetPayload<T>>>

    /**
     * Find one Assign_marks that matches the filter or throw
     * `NotFoundError` if no matches were found.
     * @param {assign_marksFindUniqueOrThrowArgs} args - Arguments to find a Assign_marks
     * @example
     * // Get one Assign_marks
     * const assign_marks = await prisma.assign_marks.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends assign_marksFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, assign_marksFindUniqueOrThrowArgs>
    ): CheckSelect<T, Prisma__assign_marksClient<assign_marks>, Prisma__assign_marksClient<assign_marksGetPayload<T>>>

    /**
     * Find the first Assign_marks that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {assign_marksFindFirstOrThrowArgs} args - Arguments to find a Assign_marks
     * @example
     * // Get one Assign_marks
     * const assign_marks = await prisma.assign_marks.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends assign_marksFindFirstOrThrowArgs>(
      args?: SelectSubset<T, assign_marksFindFirstOrThrowArgs>
    ): CheckSelect<T, Prisma__assign_marksClient<assign_marks>, Prisma__assign_marksClient<assign_marksGetPayload<T>>>

    /**
     * Count the number of Assign_marks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {assign_marksCountArgs} args - Arguments to filter Assign_marks to count.
     * @example
     * // Count the number of Assign_marks
     * const count = await prisma.assign_marks.count({
     *   where: {
     *     // ... the filter for the Assign_marks we want to count
     *   }
     * })
    **/
    count<T extends assign_marksCountArgs>(
      args?: Subset<T, assign_marksCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Assign_marksCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Assign_marks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Assign_marksAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Assign_marksAggregateArgs>(args: Subset<T, Assign_marksAggregateArgs>): PrismaPromise<GetAssign_marksAggregateType<T>>

    /**
     * Group by Assign_marks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Assign_marksGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends Assign_marksGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: Assign_marksGroupByArgs['orderBy'] }
        : { orderBy?: Assign_marksGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, Assign_marksGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAssign_marksGroupByPayload<T> : PrismaPromise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for assign_marks.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__assign_marksClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * assign_marks base type for findUnique actions
   */
  export type assign_marksFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the assign_marks
     * 
    **/
    select?: assign_marksSelect | null
    /**
     * Filter, which assign_marks to fetch.
     * 
    **/
    where: assign_marksWhereUniqueInput
  }

  /**
   * assign_marks: findUnique
   */
  export interface assign_marksFindUniqueArgs extends assign_marksFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * assign_marks base type for findFirst actions
   */
  export type assign_marksFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the assign_marks
     * 
    **/
    select?: assign_marksSelect | null
    /**
     * Filter, which assign_marks to fetch.
     * 
    **/
    where?: assign_marksWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of assign_marks to fetch.
     * 
    **/
    orderBy?: Enumerable<assign_marksOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for assign_marks.
     * 
    **/
    cursor?: assign_marksWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` assign_marks from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` assign_marks.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of assign_marks.
     * 
    **/
    distinct?: Enumerable<Assign_marksScalarFieldEnum>
  }

  /**
   * assign_marks: findFirst
   */
  export interface assign_marksFindFirstArgs extends assign_marksFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * assign_marks findMany
   */
  export type assign_marksFindManyArgs = {
    /**
     * Select specific fields to fetch from the assign_marks
     * 
    **/
    select?: assign_marksSelect | null
    /**
     * Filter, which assign_marks to fetch.
     * 
    **/
    where?: assign_marksWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of assign_marks to fetch.
     * 
    **/
    orderBy?: Enumerable<assign_marksOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing assign_marks.
     * 
    **/
    cursor?: assign_marksWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` assign_marks from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` assign_marks.
     * 
    **/
    skip?: number
    distinct?: Enumerable<Assign_marksScalarFieldEnum>
  }


  /**
   * assign_marks create
   */
  export type assign_marksCreateArgs = {
    /**
     * Select specific fields to fetch from the assign_marks
     * 
    **/
    select?: assign_marksSelect | null
    /**
     * The data needed to create a assign_marks.
     * 
    **/
    data: XOR<assign_marksCreateInput, assign_marksUncheckedCreateInput>
  }


  /**
   * assign_marks createMany
   */
  export type assign_marksCreateManyArgs = {
    /**
     * The data used to create many assign_marks.
     * 
    **/
    data: Enumerable<assign_marksCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * assign_marks update
   */
  export type assign_marksUpdateArgs = {
    /**
     * Select specific fields to fetch from the assign_marks
     * 
    **/
    select?: assign_marksSelect | null
    /**
     * The data needed to update a assign_marks.
     * 
    **/
    data: XOR<assign_marksUpdateInput, assign_marksUncheckedUpdateInput>
    /**
     * Choose, which assign_marks to update.
     * 
    **/
    where: assign_marksWhereUniqueInput
  }


  /**
   * assign_marks updateMany
   */
  export type assign_marksUpdateManyArgs = {
    /**
     * The data used to update assign_marks.
     * 
    **/
    data: XOR<assign_marksUpdateManyMutationInput, assign_marksUncheckedUpdateManyInput>
    /**
     * Filter which assign_marks to update
     * 
    **/
    where?: assign_marksWhereInput
  }


  /**
   * assign_marks upsert
   */
  export type assign_marksUpsertArgs = {
    /**
     * Select specific fields to fetch from the assign_marks
     * 
    **/
    select?: assign_marksSelect | null
    /**
     * The filter to search for the assign_marks to update in case it exists.
     * 
    **/
    where: assign_marksWhereUniqueInput
    /**
     * In case the assign_marks found by the `where` argument doesn't exist, create a new assign_marks with this data.
     * 
    **/
    create: XOR<assign_marksCreateInput, assign_marksUncheckedCreateInput>
    /**
     * In case the assign_marks was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<assign_marksUpdateInput, assign_marksUncheckedUpdateInput>
  }


  /**
   * assign_marks delete
   */
  export type assign_marksDeleteArgs = {
    /**
     * Select specific fields to fetch from the assign_marks
     * 
    **/
    select?: assign_marksSelect | null
    /**
     * Filter which assign_marks to delete.
     * 
    **/
    where: assign_marksWhereUniqueInput
  }


  /**
   * assign_marks deleteMany
   */
  export type assign_marksDeleteManyArgs = {
    /**
     * Filter which assign_marks to delete
     * 
    **/
    where?: assign_marksWhereInput
  }


  /**
   * assign_marks: findUniqueOrThrow
   */
  export type assign_marksFindUniqueOrThrowArgs = assign_marksFindUniqueArgsBase
      

  /**
   * assign_marks: findFirstOrThrow
   */
  export type assign_marksFindFirstOrThrowArgs = assign_marksFindFirstArgsBase
      

  /**
   * assign_marks without action
   */
  export type assign_marksArgs = {
    /**
     * Select specific fields to fetch from the assign_marks
     * 
    **/
    select?: assign_marksSelect | null
  }



  /**
   * Model assignments
   */


  export type AggregateAssignments = {
    _count: AssignmentsCountAggregateOutputType | null
    _avg: AssignmentsAvgAggregateOutputType | null
    _sum: AssignmentsSumAggregateOutputType | null
    _min: AssignmentsMinAggregateOutputType | null
    _max: AssignmentsMaxAggregateOutputType | null
  }

  export type AssignmentsAvgAggregateOutputType = {
    assignment_id: number | null
    contribution: number | null
    lecturer_id: number | null
    course_id: number | null
  }

  export type AssignmentsSumAggregateOutputType = {
    assignment_id: number | null
    contribution: number | null
    lecturer_id: number | null
    course_id: number | null
  }

  export type AssignmentsMinAggregateOutputType = {
    assignment_id: number | null
    name: string | null
    description: string | null
    contribution: number | null
    lecturer_id: number | null
    course_id: number | null
  }

  export type AssignmentsMaxAggregateOutputType = {
    assignment_id: number | null
    name: string | null
    description: string | null
    contribution: number | null
    lecturer_id: number | null
    course_id: number | null
  }

  export type AssignmentsCountAggregateOutputType = {
    assignment_id: number
    name: number
    description: number
    contribution: number
    lecturer_id: number
    course_id: number
    _all: number
  }


  export type AssignmentsAvgAggregateInputType = {
    assignment_id?: true
    contribution?: true
    lecturer_id?: true
    course_id?: true
  }

  export type AssignmentsSumAggregateInputType = {
    assignment_id?: true
    contribution?: true
    lecturer_id?: true
    course_id?: true
  }

  export type AssignmentsMinAggregateInputType = {
    assignment_id?: true
    name?: true
    description?: true
    contribution?: true
    lecturer_id?: true
    course_id?: true
  }

  export type AssignmentsMaxAggregateInputType = {
    assignment_id?: true
    name?: true
    description?: true
    contribution?: true
    lecturer_id?: true
    course_id?: true
  }

  export type AssignmentsCountAggregateInputType = {
    assignment_id?: true
    name?: true
    description?: true
    contribution?: true
    lecturer_id?: true
    course_id?: true
    _all?: true
  }

  export type AssignmentsAggregateArgs = {
    /**
     * Filter which assignments to aggregate.
     * 
    **/
    where?: assignmentsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of assignments to fetch.
     * 
    **/
    orderBy?: Enumerable<assignmentsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: assignmentsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` assignments from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` assignments.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned assignments
    **/
    _count?: true | AssignmentsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AssignmentsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AssignmentsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AssignmentsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AssignmentsMaxAggregateInputType
  }

  export type GetAssignmentsAggregateType<T extends AssignmentsAggregateArgs> = {
        [P in keyof T & keyof AggregateAssignments]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAssignments[P]>
      : GetScalarType<T[P], AggregateAssignments[P]>
  }




  export type AssignmentsGroupByArgs = {
    where?: assignmentsWhereInput
    orderBy?: Enumerable<assignmentsOrderByWithAggregationInput>
    by: Array<AssignmentsScalarFieldEnum>
    having?: assignmentsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AssignmentsCountAggregateInputType | true
    _avg?: AssignmentsAvgAggregateInputType
    _sum?: AssignmentsSumAggregateInputType
    _min?: AssignmentsMinAggregateInputType
    _max?: AssignmentsMaxAggregateInputType
  }


  export type AssignmentsGroupByOutputType = {
    assignment_id: number
    name: string
    description: string
    contribution: number
    lecturer_id: number
    course_id: number
    _count: AssignmentsCountAggregateOutputType | null
    _avg: AssignmentsAvgAggregateOutputType | null
    _sum: AssignmentsSumAggregateOutputType | null
    _min: AssignmentsMinAggregateOutputType | null
    _max: AssignmentsMaxAggregateOutputType | null
  }

  type GetAssignmentsGroupByPayload<T extends AssignmentsGroupByArgs> = PrismaPromise<
    Array<
      PickArray<AssignmentsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AssignmentsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AssignmentsGroupByOutputType[P]>
            : GetScalarType<T[P], AssignmentsGroupByOutputType[P]>
        }
      >
    >


  export type assignmentsSelect = {
    assignment_id?: boolean
    name?: boolean
    description?: boolean
    contribution?: boolean
    lecturer_id?: boolean
    course_id?: boolean
  }

  export type assignmentsGetPayload<
    S extends boolean | null | undefined | assignmentsArgs,
    U = keyof S
      > = S extends true
        ? assignments
    : S extends undefined
    ? never
    : S extends assignmentsArgs | assignmentsFindManyArgs
    ?'include' extends U
    ? assignments 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
    P extends keyof assignments ? assignments[P] : never
  } 
    : assignments
  : assignments


  type assignmentsCountArgs = Merge<
    Omit<assignmentsFindManyArgs, 'select' | 'include'> & {
      select?: AssignmentsCountAggregateInputType | true
    }
  >

  export interface assignmentsDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one Assignments that matches the filter.
     * @param {assignmentsFindUniqueArgs} args - Arguments to find a Assignments
     * @example
     * // Get one Assignments
     * const assignments = await prisma.assignments.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends assignmentsFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, assignmentsFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'assignments'> extends True ? CheckSelect<T, Prisma__assignmentsClient<assignments>, Prisma__assignmentsClient<assignmentsGetPayload<T>>> : CheckSelect<T, Prisma__assignmentsClient<assignments | null >, Prisma__assignmentsClient<assignmentsGetPayload<T> | null >>

    /**
     * Find the first Assignments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {assignmentsFindFirstArgs} args - Arguments to find a Assignments
     * @example
     * // Get one Assignments
     * const assignments = await prisma.assignments.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends assignmentsFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, assignmentsFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'assignments'> extends True ? CheckSelect<T, Prisma__assignmentsClient<assignments>, Prisma__assignmentsClient<assignmentsGetPayload<T>>> : CheckSelect<T, Prisma__assignmentsClient<assignments | null >, Prisma__assignmentsClient<assignmentsGetPayload<T> | null >>

    /**
     * Find zero or more Assignments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {assignmentsFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Assignments
     * const assignments = await prisma.assignments.findMany()
     * 
     * // Get first 10 Assignments
     * const assignments = await prisma.assignments.findMany({ take: 10 })
     * 
     * // Only select the `assignment_id`
     * const assignmentsWithAssignment_idOnly = await prisma.assignments.findMany({ select: { assignment_id: true } })
     * 
    **/
    findMany<T extends assignmentsFindManyArgs>(
      args?: SelectSubset<T, assignmentsFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<assignments>>, PrismaPromise<Array<assignmentsGetPayload<T>>>>

    /**
     * Create a Assignments.
     * @param {assignmentsCreateArgs} args - Arguments to create a Assignments.
     * @example
     * // Create one Assignments
     * const Assignments = await prisma.assignments.create({
     *   data: {
     *     // ... data to create a Assignments
     *   }
     * })
     * 
    **/
    create<T extends assignmentsCreateArgs>(
      args: SelectSubset<T, assignmentsCreateArgs>
    ): CheckSelect<T, Prisma__assignmentsClient<assignments>, Prisma__assignmentsClient<assignmentsGetPayload<T>>>

    /**
     * Create many Assignments.
     *     @param {assignmentsCreateManyArgs} args - Arguments to create many Assignments.
     *     @example
     *     // Create many Assignments
     *     const assignments = await prisma.assignments.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends assignmentsCreateManyArgs>(
      args?: SelectSubset<T, assignmentsCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Assignments.
     * @param {assignmentsDeleteArgs} args - Arguments to delete one Assignments.
     * @example
     * // Delete one Assignments
     * const Assignments = await prisma.assignments.delete({
     *   where: {
     *     // ... filter to delete one Assignments
     *   }
     * })
     * 
    **/
    delete<T extends assignmentsDeleteArgs>(
      args: SelectSubset<T, assignmentsDeleteArgs>
    ): CheckSelect<T, Prisma__assignmentsClient<assignments>, Prisma__assignmentsClient<assignmentsGetPayload<T>>>

    /**
     * Update one Assignments.
     * @param {assignmentsUpdateArgs} args - Arguments to update one Assignments.
     * @example
     * // Update one Assignments
     * const assignments = await prisma.assignments.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends assignmentsUpdateArgs>(
      args: SelectSubset<T, assignmentsUpdateArgs>
    ): CheckSelect<T, Prisma__assignmentsClient<assignments>, Prisma__assignmentsClient<assignmentsGetPayload<T>>>

    /**
     * Delete zero or more Assignments.
     * @param {assignmentsDeleteManyArgs} args - Arguments to filter Assignments to delete.
     * @example
     * // Delete a few Assignments
     * const { count } = await prisma.assignments.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends assignmentsDeleteManyArgs>(
      args?: SelectSubset<T, assignmentsDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Assignments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {assignmentsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Assignments
     * const assignments = await prisma.assignments.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends assignmentsUpdateManyArgs>(
      args: SelectSubset<T, assignmentsUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Assignments.
     * @param {assignmentsUpsertArgs} args - Arguments to update or create a Assignments.
     * @example
     * // Update or create a Assignments
     * const assignments = await prisma.assignments.upsert({
     *   create: {
     *     // ... data to create a Assignments
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Assignments we want to update
     *   }
     * })
    **/
    upsert<T extends assignmentsUpsertArgs>(
      args: SelectSubset<T, assignmentsUpsertArgs>
    ): CheckSelect<T, Prisma__assignmentsClient<assignments>, Prisma__assignmentsClient<assignmentsGetPayload<T>>>

    /**
     * Find one Assignments that matches the filter or throw
     * `NotFoundError` if no matches were found.
     * @param {assignmentsFindUniqueOrThrowArgs} args - Arguments to find a Assignments
     * @example
     * // Get one Assignments
     * const assignments = await prisma.assignments.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends assignmentsFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, assignmentsFindUniqueOrThrowArgs>
    ): CheckSelect<T, Prisma__assignmentsClient<assignments>, Prisma__assignmentsClient<assignmentsGetPayload<T>>>

    /**
     * Find the first Assignments that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {assignmentsFindFirstOrThrowArgs} args - Arguments to find a Assignments
     * @example
     * // Get one Assignments
     * const assignments = await prisma.assignments.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends assignmentsFindFirstOrThrowArgs>(
      args?: SelectSubset<T, assignmentsFindFirstOrThrowArgs>
    ): CheckSelect<T, Prisma__assignmentsClient<assignments>, Prisma__assignmentsClient<assignmentsGetPayload<T>>>

    /**
     * Count the number of Assignments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {assignmentsCountArgs} args - Arguments to filter Assignments to count.
     * @example
     * // Count the number of Assignments
     * const count = await prisma.assignments.count({
     *   where: {
     *     // ... the filter for the Assignments we want to count
     *   }
     * })
    **/
    count<T extends assignmentsCountArgs>(
      args?: Subset<T, assignmentsCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AssignmentsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Assignments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AssignmentsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AssignmentsAggregateArgs>(args: Subset<T, AssignmentsAggregateArgs>): PrismaPromise<GetAssignmentsAggregateType<T>>

    /**
     * Group by Assignments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AssignmentsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AssignmentsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AssignmentsGroupByArgs['orderBy'] }
        : { orderBy?: AssignmentsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AssignmentsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAssignmentsGroupByPayload<T> : PrismaPromise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for assignments.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__assignmentsClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * assignments base type for findUnique actions
   */
  export type assignmentsFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the assignments
     * 
    **/
    select?: assignmentsSelect | null
    /**
     * Filter, which assignments to fetch.
     * 
    **/
    where: assignmentsWhereUniqueInput
  }

  /**
   * assignments: findUnique
   */
  export interface assignmentsFindUniqueArgs extends assignmentsFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * assignments base type for findFirst actions
   */
  export type assignmentsFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the assignments
     * 
    **/
    select?: assignmentsSelect | null
    /**
     * Filter, which assignments to fetch.
     * 
    **/
    where?: assignmentsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of assignments to fetch.
     * 
    **/
    orderBy?: Enumerable<assignmentsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for assignments.
     * 
    **/
    cursor?: assignmentsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` assignments from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` assignments.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of assignments.
     * 
    **/
    distinct?: Enumerable<AssignmentsScalarFieldEnum>
  }

  /**
   * assignments: findFirst
   */
  export interface assignmentsFindFirstArgs extends assignmentsFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * assignments findMany
   */
  export type assignmentsFindManyArgs = {
    /**
     * Select specific fields to fetch from the assignments
     * 
    **/
    select?: assignmentsSelect | null
    /**
     * Filter, which assignments to fetch.
     * 
    **/
    where?: assignmentsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of assignments to fetch.
     * 
    **/
    orderBy?: Enumerable<assignmentsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing assignments.
     * 
    **/
    cursor?: assignmentsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` assignments from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` assignments.
     * 
    **/
    skip?: number
    distinct?: Enumerable<AssignmentsScalarFieldEnum>
  }


  /**
   * assignments create
   */
  export type assignmentsCreateArgs = {
    /**
     * Select specific fields to fetch from the assignments
     * 
    **/
    select?: assignmentsSelect | null
    /**
     * The data needed to create a assignments.
     * 
    **/
    data: XOR<assignmentsCreateInput, assignmentsUncheckedCreateInput>
  }


  /**
   * assignments createMany
   */
  export type assignmentsCreateManyArgs = {
    /**
     * The data used to create many assignments.
     * 
    **/
    data: Enumerable<assignmentsCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * assignments update
   */
  export type assignmentsUpdateArgs = {
    /**
     * Select specific fields to fetch from the assignments
     * 
    **/
    select?: assignmentsSelect | null
    /**
     * The data needed to update a assignments.
     * 
    **/
    data: XOR<assignmentsUpdateInput, assignmentsUncheckedUpdateInput>
    /**
     * Choose, which assignments to update.
     * 
    **/
    where: assignmentsWhereUniqueInput
  }


  /**
   * assignments updateMany
   */
  export type assignmentsUpdateManyArgs = {
    /**
     * The data used to update assignments.
     * 
    **/
    data: XOR<assignmentsUpdateManyMutationInput, assignmentsUncheckedUpdateManyInput>
    /**
     * Filter which assignments to update
     * 
    **/
    where?: assignmentsWhereInput
  }


  /**
   * assignments upsert
   */
  export type assignmentsUpsertArgs = {
    /**
     * Select specific fields to fetch from the assignments
     * 
    **/
    select?: assignmentsSelect | null
    /**
     * The filter to search for the assignments to update in case it exists.
     * 
    **/
    where: assignmentsWhereUniqueInput
    /**
     * In case the assignments found by the `where` argument doesn't exist, create a new assignments with this data.
     * 
    **/
    create: XOR<assignmentsCreateInput, assignmentsUncheckedCreateInput>
    /**
     * In case the assignments was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<assignmentsUpdateInput, assignmentsUncheckedUpdateInput>
  }


  /**
   * assignments delete
   */
  export type assignmentsDeleteArgs = {
    /**
     * Select specific fields to fetch from the assignments
     * 
    **/
    select?: assignmentsSelect | null
    /**
     * Filter which assignments to delete.
     * 
    **/
    where: assignmentsWhereUniqueInput
  }


  /**
   * assignments deleteMany
   */
  export type assignmentsDeleteManyArgs = {
    /**
     * Filter which assignments to delete
     * 
    **/
    where?: assignmentsWhereInput
  }


  /**
   * assignments: findUniqueOrThrow
   */
  export type assignmentsFindUniqueOrThrowArgs = assignmentsFindUniqueArgsBase
      

  /**
   * assignments: findFirstOrThrow
   */
  export type assignmentsFindFirstOrThrowArgs = assignmentsFindFirstArgsBase
      

  /**
   * assignments without action
   */
  export type assignmentsArgs = {
    /**
     * Select specific fields to fetch from the assignments
     * 
    **/
    select?: assignmentsSelect | null
  }



  /**
   * Model confirm
   */


  export type AggregateConfirm = {
    _count: ConfirmCountAggregateOutputType | null
    _avg: ConfirmAvgAggregateOutputType | null
    _sum: ConfirmSumAggregateOutputType | null
    _min: ConfirmMinAggregateOutputType | null
    _max: ConfirmMaxAggregateOutputType | null
  }

  export type ConfirmAvgAggregateOutputType = {
    confirm_id: number | null
    letter_id: number | null
  }

  export type ConfirmSumAggregateOutputType = {
    confirm_id: number | null
    letter_id: number | null
  }

  export type ConfirmMinAggregateOutputType = {
    confirm_id: number | null
    letter_id: number | null
  }

  export type ConfirmMaxAggregateOutputType = {
    confirm_id: number | null
    letter_id: number | null
  }

  export type ConfirmCountAggregateOutputType = {
    confirm_id: number
    letter_id: number
    _all: number
  }


  export type ConfirmAvgAggregateInputType = {
    confirm_id?: true
    letter_id?: true
  }

  export type ConfirmSumAggregateInputType = {
    confirm_id?: true
    letter_id?: true
  }

  export type ConfirmMinAggregateInputType = {
    confirm_id?: true
    letter_id?: true
  }

  export type ConfirmMaxAggregateInputType = {
    confirm_id?: true
    letter_id?: true
  }

  export type ConfirmCountAggregateInputType = {
    confirm_id?: true
    letter_id?: true
    _all?: true
  }

  export type ConfirmAggregateArgs = {
    /**
     * Filter which confirm to aggregate.
     * 
    **/
    where?: confirmWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of confirms to fetch.
     * 
    **/
    orderBy?: Enumerable<confirmOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: confirmWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` confirms from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` confirms.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned confirms
    **/
    _count?: true | ConfirmCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ConfirmAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ConfirmSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ConfirmMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ConfirmMaxAggregateInputType
  }

  export type GetConfirmAggregateType<T extends ConfirmAggregateArgs> = {
        [P in keyof T & keyof AggregateConfirm]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateConfirm[P]>
      : GetScalarType<T[P], AggregateConfirm[P]>
  }




  export type ConfirmGroupByArgs = {
    where?: confirmWhereInput
    orderBy?: Enumerable<confirmOrderByWithAggregationInput>
    by: Array<ConfirmScalarFieldEnum>
    having?: confirmScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ConfirmCountAggregateInputType | true
    _avg?: ConfirmAvgAggregateInputType
    _sum?: ConfirmSumAggregateInputType
    _min?: ConfirmMinAggregateInputType
    _max?: ConfirmMaxAggregateInputType
  }


  export type ConfirmGroupByOutputType = {
    confirm_id: number
    letter_id: number
    _count: ConfirmCountAggregateOutputType | null
    _avg: ConfirmAvgAggregateOutputType | null
    _sum: ConfirmSumAggregateOutputType | null
    _min: ConfirmMinAggregateOutputType | null
    _max: ConfirmMaxAggregateOutputType | null
  }

  type GetConfirmGroupByPayload<T extends ConfirmGroupByArgs> = PrismaPromise<
    Array<
      PickArray<ConfirmGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ConfirmGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ConfirmGroupByOutputType[P]>
            : GetScalarType<T[P], ConfirmGroupByOutputType[P]>
        }
      >
    >


  export type confirmSelect = {
    confirm_id?: boolean
    letter_id?: boolean
  }

  export type confirmGetPayload<
    S extends boolean | null | undefined | confirmArgs,
    U = keyof S
      > = S extends true
        ? confirm
    : S extends undefined
    ? never
    : S extends confirmArgs | confirmFindManyArgs
    ?'include' extends U
    ? confirm 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
    P extends keyof confirm ? confirm[P] : never
  } 
    : confirm
  : confirm


  type confirmCountArgs = Merge<
    Omit<confirmFindManyArgs, 'select' | 'include'> & {
      select?: ConfirmCountAggregateInputType | true
    }
  >

  export interface confirmDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one Confirm that matches the filter.
     * @param {confirmFindUniqueArgs} args - Arguments to find a Confirm
     * @example
     * // Get one Confirm
     * const confirm = await prisma.confirm.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends confirmFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, confirmFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'confirm'> extends True ? CheckSelect<T, Prisma__confirmClient<confirm>, Prisma__confirmClient<confirmGetPayload<T>>> : CheckSelect<T, Prisma__confirmClient<confirm | null >, Prisma__confirmClient<confirmGetPayload<T> | null >>

    /**
     * Find the first Confirm that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {confirmFindFirstArgs} args - Arguments to find a Confirm
     * @example
     * // Get one Confirm
     * const confirm = await prisma.confirm.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends confirmFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, confirmFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'confirm'> extends True ? CheckSelect<T, Prisma__confirmClient<confirm>, Prisma__confirmClient<confirmGetPayload<T>>> : CheckSelect<T, Prisma__confirmClient<confirm | null >, Prisma__confirmClient<confirmGetPayload<T> | null >>

    /**
     * Find zero or more Confirms that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {confirmFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Confirms
     * const confirms = await prisma.confirm.findMany()
     * 
     * // Get first 10 Confirms
     * const confirms = await prisma.confirm.findMany({ take: 10 })
     * 
     * // Only select the `confirm_id`
     * const confirmWithConfirm_idOnly = await prisma.confirm.findMany({ select: { confirm_id: true } })
     * 
    **/
    findMany<T extends confirmFindManyArgs>(
      args?: SelectSubset<T, confirmFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<confirm>>, PrismaPromise<Array<confirmGetPayload<T>>>>

    /**
     * Create a Confirm.
     * @param {confirmCreateArgs} args - Arguments to create a Confirm.
     * @example
     * // Create one Confirm
     * const Confirm = await prisma.confirm.create({
     *   data: {
     *     // ... data to create a Confirm
     *   }
     * })
     * 
    **/
    create<T extends confirmCreateArgs>(
      args: SelectSubset<T, confirmCreateArgs>
    ): CheckSelect<T, Prisma__confirmClient<confirm>, Prisma__confirmClient<confirmGetPayload<T>>>

    /**
     * Create many Confirms.
     *     @param {confirmCreateManyArgs} args - Arguments to create many Confirms.
     *     @example
     *     // Create many Confirms
     *     const confirm = await prisma.confirm.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends confirmCreateManyArgs>(
      args?: SelectSubset<T, confirmCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Confirm.
     * @param {confirmDeleteArgs} args - Arguments to delete one Confirm.
     * @example
     * // Delete one Confirm
     * const Confirm = await prisma.confirm.delete({
     *   where: {
     *     // ... filter to delete one Confirm
     *   }
     * })
     * 
    **/
    delete<T extends confirmDeleteArgs>(
      args: SelectSubset<T, confirmDeleteArgs>
    ): CheckSelect<T, Prisma__confirmClient<confirm>, Prisma__confirmClient<confirmGetPayload<T>>>

    /**
     * Update one Confirm.
     * @param {confirmUpdateArgs} args - Arguments to update one Confirm.
     * @example
     * // Update one Confirm
     * const confirm = await prisma.confirm.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends confirmUpdateArgs>(
      args: SelectSubset<T, confirmUpdateArgs>
    ): CheckSelect<T, Prisma__confirmClient<confirm>, Prisma__confirmClient<confirmGetPayload<T>>>

    /**
     * Delete zero or more Confirms.
     * @param {confirmDeleteManyArgs} args - Arguments to filter Confirms to delete.
     * @example
     * // Delete a few Confirms
     * const { count } = await prisma.confirm.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends confirmDeleteManyArgs>(
      args?: SelectSubset<T, confirmDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Confirms.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {confirmUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Confirms
     * const confirm = await prisma.confirm.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends confirmUpdateManyArgs>(
      args: SelectSubset<T, confirmUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Confirm.
     * @param {confirmUpsertArgs} args - Arguments to update or create a Confirm.
     * @example
     * // Update or create a Confirm
     * const confirm = await prisma.confirm.upsert({
     *   create: {
     *     // ... data to create a Confirm
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Confirm we want to update
     *   }
     * })
    **/
    upsert<T extends confirmUpsertArgs>(
      args: SelectSubset<T, confirmUpsertArgs>
    ): CheckSelect<T, Prisma__confirmClient<confirm>, Prisma__confirmClient<confirmGetPayload<T>>>

    /**
     * Find one Confirm that matches the filter or throw
     * `NotFoundError` if no matches were found.
     * @param {confirmFindUniqueOrThrowArgs} args - Arguments to find a Confirm
     * @example
     * // Get one Confirm
     * const confirm = await prisma.confirm.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends confirmFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, confirmFindUniqueOrThrowArgs>
    ): CheckSelect<T, Prisma__confirmClient<confirm>, Prisma__confirmClient<confirmGetPayload<T>>>

    /**
     * Find the first Confirm that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {confirmFindFirstOrThrowArgs} args - Arguments to find a Confirm
     * @example
     * // Get one Confirm
     * const confirm = await prisma.confirm.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends confirmFindFirstOrThrowArgs>(
      args?: SelectSubset<T, confirmFindFirstOrThrowArgs>
    ): CheckSelect<T, Prisma__confirmClient<confirm>, Prisma__confirmClient<confirmGetPayload<T>>>

    /**
     * Count the number of Confirms.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {confirmCountArgs} args - Arguments to filter Confirms to count.
     * @example
     * // Count the number of Confirms
     * const count = await prisma.confirm.count({
     *   where: {
     *     // ... the filter for the Confirms we want to count
     *   }
     * })
    **/
    count<T extends confirmCountArgs>(
      args?: Subset<T, confirmCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ConfirmCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Confirm.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConfirmAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ConfirmAggregateArgs>(args: Subset<T, ConfirmAggregateArgs>): PrismaPromise<GetConfirmAggregateType<T>>

    /**
     * Group by Confirm.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConfirmGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ConfirmGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ConfirmGroupByArgs['orderBy'] }
        : { orderBy?: ConfirmGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ConfirmGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetConfirmGroupByPayload<T> : PrismaPromise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for confirm.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__confirmClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * confirm base type for findUnique actions
   */
  export type confirmFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the confirm
     * 
    **/
    select?: confirmSelect | null
    /**
     * Filter, which confirm to fetch.
     * 
    **/
    where: confirmWhereUniqueInput
  }

  /**
   * confirm: findUnique
   */
  export interface confirmFindUniqueArgs extends confirmFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * confirm base type for findFirst actions
   */
  export type confirmFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the confirm
     * 
    **/
    select?: confirmSelect | null
    /**
     * Filter, which confirm to fetch.
     * 
    **/
    where?: confirmWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of confirms to fetch.
     * 
    **/
    orderBy?: Enumerable<confirmOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for confirms.
     * 
    **/
    cursor?: confirmWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` confirms from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` confirms.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of confirms.
     * 
    **/
    distinct?: Enumerable<ConfirmScalarFieldEnum>
  }

  /**
   * confirm: findFirst
   */
  export interface confirmFindFirstArgs extends confirmFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * confirm findMany
   */
  export type confirmFindManyArgs = {
    /**
     * Select specific fields to fetch from the confirm
     * 
    **/
    select?: confirmSelect | null
    /**
     * Filter, which confirms to fetch.
     * 
    **/
    where?: confirmWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of confirms to fetch.
     * 
    **/
    orderBy?: Enumerable<confirmOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing confirms.
     * 
    **/
    cursor?: confirmWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` confirms from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` confirms.
     * 
    **/
    skip?: number
    distinct?: Enumerable<ConfirmScalarFieldEnum>
  }


  /**
   * confirm create
   */
  export type confirmCreateArgs = {
    /**
     * Select specific fields to fetch from the confirm
     * 
    **/
    select?: confirmSelect | null
    /**
     * The data needed to create a confirm.
     * 
    **/
    data: XOR<confirmCreateInput, confirmUncheckedCreateInput>
  }


  /**
   * confirm createMany
   */
  export type confirmCreateManyArgs = {
    /**
     * The data used to create many confirms.
     * 
    **/
    data: Enumerable<confirmCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * confirm update
   */
  export type confirmUpdateArgs = {
    /**
     * Select specific fields to fetch from the confirm
     * 
    **/
    select?: confirmSelect | null
    /**
     * The data needed to update a confirm.
     * 
    **/
    data: XOR<confirmUpdateInput, confirmUncheckedUpdateInput>
    /**
     * Choose, which confirm to update.
     * 
    **/
    where: confirmWhereUniqueInput
  }


  /**
   * confirm updateMany
   */
  export type confirmUpdateManyArgs = {
    /**
     * The data used to update confirms.
     * 
    **/
    data: XOR<confirmUpdateManyMutationInput, confirmUncheckedUpdateManyInput>
    /**
     * Filter which confirms to update
     * 
    **/
    where?: confirmWhereInput
  }


  /**
   * confirm upsert
   */
  export type confirmUpsertArgs = {
    /**
     * Select specific fields to fetch from the confirm
     * 
    **/
    select?: confirmSelect | null
    /**
     * The filter to search for the confirm to update in case it exists.
     * 
    **/
    where: confirmWhereUniqueInput
    /**
     * In case the confirm found by the `where` argument doesn't exist, create a new confirm with this data.
     * 
    **/
    create: XOR<confirmCreateInput, confirmUncheckedCreateInput>
    /**
     * In case the confirm was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<confirmUpdateInput, confirmUncheckedUpdateInput>
  }


  /**
   * confirm delete
   */
  export type confirmDeleteArgs = {
    /**
     * Select specific fields to fetch from the confirm
     * 
    **/
    select?: confirmSelect | null
    /**
     * Filter which confirm to delete.
     * 
    **/
    where: confirmWhereUniqueInput
  }


  /**
   * confirm deleteMany
   */
  export type confirmDeleteManyArgs = {
    /**
     * Filter which confirms to delete
     * 
    **/
    where?: confirmWhereInput
  }


  /**
   * confirm: findUniqueOrThrow
   */
  export type confirmFindUniqueOrThrowArgs = confirmFindUniqueArgsBase
      

  /**
   * confirm: findFirstOrThrow
   */
  export type confirmFindFirstOrThrowArgs = confirmFindFirstArgsBase
      

  /**
   * confirm without action
   */
  export type confirmArgs = {
    /**
     * Select specific fields to fetch from the confirm
     * 
    **/
    select?: confirmSelect | null
  }



  /**
   * Model course
   */


  export type AggregateCourse = {
    _count: CourseCountAggregateOutputType | null
    _avg: CourseAvgAggregateOutputType | null
    _sum: CourseSumAggregateOutputType | null
    _min: CourseMinAggregateOutputType | null
    _max: CourseMaxAggregateOutputType | null
  }

  export type CourseAvgAggregateOutputType = {
    course_id: number | null
    year: number | null
    ac_year_ID: number | null
  }

  export type CourseSumAggregateOutputType = {
    course_id: number | null
    year: number | null
    ac_year_ID: number | null
  }

  export type CourseMinAggregateOutputType = {
    course_id: number | null
    year: number | null
    semester: string | null
    course_name: string | null
    course_code: string | null
    lecture_name: string | null
    ac_year_ID: number | null
  }

  export type CourseMaxAggregateOutputType = {
    course_id: number | null
    year: number | null
    semester: string | null
    course_name: string | null
    course_code: string | null
    lecture_name: string | null
    ac_year_ID: number | null
  }

  export type CourseCountAggregateOutputType = {
    course_id: number
    year: number
    semester: number
    course_name: number
    course_code: number
    lecture_name: number
    ac_year_ID: number
    _all: number
  }


  export type CourseAvgAggregateInputType = {
    course_id?: true
    year?: true
    ac_year_ID?: true
  }

  export type CourseSumAggregateInputType = {
    course_id?: true
    year?: true
    ac_year_ID?: true
  }

  export type CourseMinAggregateInputType = {
    course_id?: true
    year?: true
    semester?: true
    course_name?: true
    course_code?: true
    lecture_name?: true
    ac_year_ID?: true
  }

  export type CourseMaxAggregateInputType = {
    course_id?: true
    year?: true
    semester?: true
    course_name?: true
    course_code?: true
    lecture_name?: true
    ac_year_ID?: true
  }

  export type CourseCountAggregateInputType = {
    course_id?: true
    year?: true
    semester?: true
    course_name?: true
    course_code?: true
    lecture_name?: true
    ac_year_ID?: true
    _all?: true
  }

  export type CourseAggregateArgs = {
    /**
     * Filter which course to aggregate.
     * 
    **/
    where?: courseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of courses to fetch.
     * 
    **/
    orderBy?: Enumerable<courseOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: courseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` courses from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` courses.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned courses
    **/
    _count?: true | CourseCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CourseAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CourseSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CourseMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CourseMaxAggregateInputType
  }

  export type GetCourseAggregateType<T extends CourseAggregateArgs> = {
        [P in keyof T & keyof AggregateCourse]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCourse[P]>
      : GetScalarType<T[P], AggregateCourse[P]>
  }




  export type CourseGroupByArgs = {
    where?: courseWhereInput
    orderBy?: Enumerable<courseOrderByWithAggregationInput>
    by: Array<CourseScalarFieldEnum>
    having?: courseScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CourseCountAggregateInputType | true
    _avg?: CourseAvgAggregateInputType
    _sum?: CourseSumAggregateInputType
    _min?: CourseMinAggregateInputType
    _max?: CourseMaxAggregateInputType
  }


  export type CourseGroupByOutputType = {
    course_id: number
    year: number
    semester: string
    course_name: string
    course_code: string
    lecture_name: string
    ac_year_ID: number
    _count: CourseCountAggregateOutputType | null
    _avg: CourseAvgAggregateOutputType | null
    _sum: CourseSumAggregateOutputType | null
    _min: CourseMinAggregateOutputType | null
    _max: CourseMaxAggregateOutputType | null
  }

  type GetCourseGroupByPayload<T extends CourseGroupByArgs> = PrismaPromise<
    Array<
      PickArray<CourseGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CourseGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CourseGroupByOutputType[P]>
            : GetScalarType<T[P], CourseGroupByOutputType[P]>
        }
      >
    >


  export type courseSelect = {
    course_id?: boolean
    year?: boolean
    semester?: boolean
    course_name?: boolean
    course_code?: boolean
    lecture_name?: boolean
    ac_year_ID?: boolean
  }

  export type courseGetPayload<
    S extends boolean | null | undefined | courseArgs,
    U = keyof S
      > = S extends true
        ? course
    : S extends undefined
    ? never
    : S extends courseArgs | courseFindManyArgs
    ?'include' extends U
    ? course 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
    P extends keyof course ? course[P] : never
  } 
    : course
  : course


  type courseCountArgs = Merge<
    Omit<courseFindManyArgs, 'select' | 'include'> & {
      select?: CourseCountAggregateInputType | true
    }
  >

  export interface courseDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one Course that matches the filter.
     * @param {courseFindUniqueArgs} args - Arguments to find a Course
     * @example
     * // Get one Course
     * const course = await prisma.course.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends courseFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, courseFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'course'> extends True ? CheckSelect<T, Prisma__courseClient<course>, Prisma__courseClient<courseGetPayload<T>>> : CheckSelect<T, Prisma__courseClient<course | null >, Prisma__courseClient<courseGetPayload<T> | null >>

    /**
     * Find the first Course that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {courseFindFirstArgs} args - Arguments to find a Course
     * @example
     * // Get one Course
     * const course = await prisma.course.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends courseFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, courseFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'course'> extends True ? CheckSelect<T, Prisma__courseClient<course>, Prisma__courseClient<courseGetPayload<T>>> : CheckSelect<T, Prisma__courseClient<course | null >, Prisma__courseClient<courseGetPayload<T> | null >>

    /**
     * Find zero or more Courses that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {courseFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Courses
     * const courses = await prisma.course.findMany()
     * 
     * // Get first 10 Courses
     * const courses = await prisma.course.findMany({ take: 10 })
     * 
     * // Only select the `course_id`
     * const courseWithCourse_idOnly = await prisma.course.findMany({ select: { course_id: true } })
     * 
    **/
    findMany<T extends courseFindManyArgs>(
      args?: SelectSubset<T, courseFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<course>>, PrismaPromise<Array<courseGetPayload<T>>>>

    /**
     * Create a Course.
     * @param {courseCreateArgs} args - Arguments to create a Course.
     * @example
     * // Create one Course
     * const Course = await prisma.course.create({
     *   data: {
     *     // ... data to create a Course
     *   }
     * })
     * 
    **/
    create<T extends courseCreateArgs>(
      args: SelectSubset<T, courseCreateArgs>
    ): CheckSelect<T, Prisma__courseClient<course>, Prisma__courseClient<courseGetPayload<T>>>

    /**
     * Create many Courses.
     *     @param {courseCreateManyArgs} args - Arguments to create many Courses.
     *     @example
     *     // Create many Courses
     *     const course = await prisma.course.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends courseCreateManyArgs>(
      args?: SelectSubset<T, courseCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Course.
     * @param {courseDeleteArgs} args - Arguments to delete one Course.
     * @example
     * // Delete one Course
     * const Course = await prisma.course.delete({
     *   where: {
     *     // ... filter to delete one Course
     *   }
     * })
     * 
    **/
    delete<T extends courseDeleteArgs>(
      args: SelectSubset<T, courseDeleteArgs>
    ): CheckSelect<T, Prisma__courseClient<course>, Prisma__courseClient<courseGetPayload<T>>>

    /**
     * Update one Course.
     * @param {courseUpdateArgs} args - Arguments to update one Course.
     * @example
     * // Update one Course
     * const course = await prisma.course.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends courseUpdateArgs>(
      args: SelectSubset<T, courseUpdateArgs>
    ): CheckSelect<T, Prisma__courseClient<course>, Prisma__courseClient<courseGetPayload<T>>>

    /**
     * Delete zero or more Courses.
     * @param {courseDeleteManyArgs} args - Arguments to filter Courses to delete.
     * @example
     * // Delete a few Courses
     * const { count } = await prisma.course.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends courseDeleteManyArgs>(
      args?: SelectSubset<T, courseDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Courses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {courseUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Courses
     * const course = await prisma.course.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends courseUpdateManyArgs>(
      args: SelectSubset<T, courseUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Course.
     * @param {courseUpsertArgs} args - Arguments to update or create a Course.
     * @example
     * // Update or create a Course
     * const course = await prisma.course.upsert({
     *   create: {
     *     // ... data to create a Course
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Course we want to update
     *   }
     * })
    **/
    upsert<T extends courseUpsertArgs>(
      args: SelectSubset<T, courseUpsertArgs>
    ): CheckSelect<T, Prisma__courseClient<course>, Prisma__courseClient<courseGetPayload<T>>>

    /**
     * Find one Course that matches the filter or throw
     * `NotFoundError` if no matches were found.
     * @param {courseFindUniqueOrThrowArgs} args - Arguments to find a Course
     * @example
     * // Get one Course
     * const course = await prisma.course.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends courseFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, courseFindUniqueOrThrowArgs>
    ): CheckSelect<T, Prisma__courseClient<course>, Prisma__courseClient<courseGetPayload<T>>>

    /**
     * Find the first Course that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {courseFindFirstOrThrowArgs} args - Arguments to find a Course
     * @example
     * // Get one Course
     * const course = await prisma.course.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends courseFindFirstOrThrowArgs>(
      args?: SelectSubset<T, courseFindFirstOrThrowArgs>
    ): CheckSelect<T, Prisma__courseClient<course>, Prisma__courseClient<courseGetPayload<T>>>

    /**
     * Count the number of Courses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {courseCountArgs} args - Arguments to filter Courses to count.
     * @example
     * // Count the number of Courses
     * const count = await prisma.course.count({
     *   where: {
     *     // ... the filter for the Courses we want to count
     *   }
     * })
    **/
    count<T extends courseCountArgs>(
      args?: Subset<T, courseCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CourseCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Course.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CourseAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CourseAggregateArgs>(args: Subset<T, CourseAggregateArgs>): PrismaPromise<GetCourseAggregateType<T>>

    /**
     * Group by Course.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CourseGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CourseGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CourseGroupByArgs['orderBy'] }
        : { orderBy?: CourseGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CourseGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCourseGroupByPayload<T> : PrismaPromise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for course.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__courseClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * course base type for findUnique actions
   */
  export type courseFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the course
     * 
    **/
    select?: courseSelect | null
    /**
     * Filter, which course to fetch.
     * 
    **/
    where: courseWhereUniqueInput
  }

  /**
   * course: findUnique
   */
  export interface courseFindUniqueArgs extends courseFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * course base type for findFirst actions
   */
  export type courseFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the course
     * 
    **/
    select?: courseSelect | null
    /**
     * Filter, which course to fetch.
     * 
    **/
    where?: courseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of courses to fetch.
     * 
    **/
    orderBy?: Enumerable<courseOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for courses.
     * 
    **/
    cursor?: courseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` courses from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` courses.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of courses.
     * 
    **/
    distinct?: Enumerable<CourseScalarFieldEnum>
  }

  /**
   * course: findFirst
   */
  export interface courseFindFirstArgs extends courseFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * course findMany
   */
  export type courseFindManyArgs = {
    /**
     * Select specific fields to fetch from the course
     * 
    **/
    select?: courseSelect | null
    /**
     * Filter, which courses to fetch.
     * 
    **/
    where?: courseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of courses to fetch.
     * 
    **/
    orderBy?: Enumerable<courseOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing courses.
     * 
    **/
    cursor?: courseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` courses from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` courses.
     * 
    **/
    skip?: number
    distinct?: Enumerable<CourseScalarFieldEnum>
  }


  /**
   * course create
   */
  export type courseCreateArgs = {
    /**
     * Select specific fields to fetch from the course
     * 
    **/
    select?: courseSelect | null
    /**
     * The data needed to create a course.
     * 
    **/
    data: XOR<courseCreateInput, courseUncheckedCreateInput>
  }


  /**
   * course createMany
   */
  export type courseCreateManyArgs = {
    /**
     * The data used to create many courses.
     * 
    **/
    data: Enumerable<courseCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * course update
   */
  export type courseUpdateArgs = {
    /**
     * Select specific fields to fetch from the course
     * 
    **/
    select?: courseSelect | null
    /**
     * The data needed to update a course.
     * 
    **/
    data: XOR<courseUpdateInput, courseUncheckedUpdateInput>
    /**
     * Choose, which course to update.
     * 
    **/
    where: courseWhereUniqueInput
  }


  /**
   * course updateMany
   */
  export type courseUpdateManyArgs = {
    /**
     * The data used to update courses.
     * 
    **/
    data: XOR<courseUpdateManyMutationInput, courseUncheckedUpdateManyInput>
    /**
     * Filter which courses to update
     * 
    **/
    where?: courseWhereInput
  }


  /**
   * course upsert
   */
  export type courseUpsertArgs = {
    /**
     * Select specific fields to fetch from the course
     * 
    **/
    select?: courseSelect | null
    /**
     * The filter to search for the course to update in case it exists.
     * 
    **/
    where: courseWhereUniqueInput
    /**
     * In case the course found by the `where` argument doesn't exist, create a new course with this data.
     * 
    **/
    create: XOR<courseCreateInput, courseUncheckedCreateInput>
    /**
     * In case the course was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<courseUpdateInput, courseUncheckedUpdateInput>
  }


  /**
   * course delete
   */
  export type courseDeleteArgs = {
    /**
     * Select specific fields to fetch from the course
     * 
    **/
    select?: courseSelect | null
    /**
     * Filter which course to delete.
     * 
    **/
    where: courseWhereUniqueInput
  }


  /**
   * course deleteMany
   */
  export type courseDeleteManyArgs = {
    /**
     * Filter which courses to delete
     * 
    **/
    where?: courseWhereInput
  }


  /**
   * course: findUniqueOrThrow
   */
  export type courseFindUniqueOrThrowArgs = courseFindUniqueArgsBase
      

  /**
   * course: findFirstOrThrow
   */
  export type courseFindFirstOrThrowArgs = courseFindFirstArgsBase
      

  /**
   * course without action
   */
  export type courseArgs = {
    /**
     * Select specific fields to fetch from the course
     * 
    **/
    select?: courseSelect | null
  }



  /**
   * Model director
   */


  export type AggregateDirector = {
    _count: DirectorCountAggregateOutputType | null
    _avg: DirectorAvgAggregateOutputType | null
    _sum: DirectorSumAggregateOutputType | null
    _min: DirectorMinAggregateOutputType | null
    _max: DirectorMaxAggregateOutputType | null
  }

  export type DirectorAvgAggregateOutputType = {
    director_id: number | null
    user_id: number | null
  }

  export type DirectorSumAggregateOutputType = {
    director_id: number | null
    user_id: number | null
  }

  export type DirectorMinAggregateOutputType = {
    director_id: number | null
    user_id: number | null
  }

  export type DirectorMaxAggregateOutputType = {
    director_id: number | null
    user_id: number | null
  }

  export type DirectorCountAggregateOutputType = {
    director_id: number
    user_id: number
    _all: number
  }


  export type DirectorAvgAggregateInputType = {
    director_id?: true
    user_id?: true
  }

  export type DirectorSumAggregateInputType = {
    director_id?: true
    user_id?: true
  }

  export type DirectorMinAggregateInputType = {
    director_id?: true
    user_id?: true
  }

  export type DirectorMaxAggregateInputType = {
    director_id?: true
    user_id?: true
  }

  export type DirectorCountAggregateInputType = {
    director_id?: true
    user_id?: true
    _all?: true
  }

  export type DirectorAggregateArgs = {
    /**
     * Filter which director to aggregate.
     * 
    **/
    where?: directorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of directors to fetch.
     * 
    **/
    orderBy?: Enumerable<directorOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: directorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` directors from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` directors.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned directors
    **/
    _count?: true | DirectorCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: DirectorAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: DirectorSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DirectorMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DirectorMaxAggregateInputType
  }

  export type GetDirectorAggregateType<T extends DirectorAggregateArgs> = {
        [P in keyof T & keyof AggregateDirector]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDirector[P]>
      : GetScalarType<T[P], AggregateDirector[P]>
  }




  export type DirectorGroupByArgs = {
    where?: directorWhereInput
    orderBy?: Enumerable<directorOrderByWithAggregationInput>
    by: Array<DirectorScalarFieldEnum>
    having?: directorScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DirectorCountAggregateInputType | true
    _avg?: DirectorAvgAggregateInputType
    _sum?: DirectorSumAggregateInputType
    _min?: DirectorMinAggregateInputType
    _max?: DirectorMaxAggregateInputType
  }


  export type DirectorGroupByOutputType = {
    director_id: number
    user_id: number
    _count: DirectorCountAggregateOutputType | null
    _avg: DirectorAvgAggregateOutputType | null
    _sum: DirectorSumAggregateOutputType | null
    _min: DirectorMinAggregateOutputType | null
    _max: DirectorMaxAggregateOutputType | null
  }

  type GetDirectorGroupByPayload<T extends DirectorGroupByArgs> = PrismaPromise<
    Array<
      PickArray<DirectorGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DirectorGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DirectorGroupByOutputType[P]>
            : GetScalarType<T[P], DirectorGroupByOutputType[P]>
        }
      >
    >


  export type directorSelect = {
    director_id?: boolean
    user_id?: boolean
  }

  export type directorGetPayload<
    S extends boolean | null | undefined | directorArgs,
    U = keyof S
      > = S extends true
        ? director
    : S extends undefined
    ? never
    : S extends directorArgs | directorFindManyArgs
    ?'include' extends U
    ? director 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
    P extends keyof director ? director[P] : never
  } 
    : director
  : director


  type directorCountArgs = Merge<
    Omit<directorFindManyArgs, 'select' | 'include'> & {
      select?: DirectorCountAggregateInputType | true
    }
  >

  export interface directorDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one Director that matches the filter.
     * @param {directorFindUniqueArgs} args - Arguments to find a Director
     * @example
     * // Get one Director
     * const director = await prisma.director.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends directorFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, directorFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'director'> extends True ? CheckSelect<T, Prisma__directorClient<director>, Prisma__directorClient<directorGetPayload<T>>> : CheckSelect<T, Prisma__directorClient<director | null >, Prisma__directorClient<directorGetPayload<T> | null >>

    /**
     * Find the first Director that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {directorFindFirstArgs} args - Arguments to find a Director
     * @example
     * // Get one Director
     * const director = await prisma.director.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends directorFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, directorFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'director'> extends True ? CheckSelect<T, Prisma__directorClient<director>, Prisma__directorClient<directorGetPayload<T>>> : CheckSelect<T, Prisma__directorClient<director | null >, Prisma__directorClient<directorGetPayload<T> | null >>

    /**
     * Find zero or more Directors that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {directorFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Directors
     * const directors = await prisma.director.findMany()
     * 
     * // Get first 10 Directors
     * const directors = await prisma.director.findMany({ take: 10 })
     * 
     * // Only select the `director_id`
     * const directorWithDirector_idOnly = await prisma.director.findMany({ select: { director_id: true } })
     * 
    **/
    findMany<T extends directorFindManyArgs>(
      args?: SelectSubset<T, directorFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<director>>, PrismaPromise<Array<directorGetPayload<T>>>>

    /**
     * Create a Director.
     * @param {directorCreateArgs} args - Arguments to create a Director.
     * @example
     * // Create one Director
     * const Director = await prisma.director.create({
     *   data: {
     *     // ... data to create a Director
     *   }
     * })
     * 
    **/
    create<T extends directorCreateArgs>(
      args: SelectSubset<T, directorCreateArgs>
    ): CheckSelect<T, Prisma__directorClient<director>, Prisma__directorClient<directorGetPayload<T>>>

    /**
     * Create many Directors.
     *     @param {directorCreateManyArgs} args - Arguments to create many Directors.
     *     @example
     *     // Create many Directors
     *     const director = await prisma.director.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends directorCreateManyArgs>(
      args?: SelectSubset<T, directorCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Director.
     * @param {directorDeleteArgs} args - Arguments to delete one Director.
     * @example
     * // Delete one Director
     * const Director = await prisma.director.delete({
     *   where: {
     *     // ... filter to delete one Director
     *   }
     * })
     * 
    **/
    delete<T extends directorDeleteArgs>(
      args: SelectSubset<T, directorDeleteArgs>
    ): CheckSelect<T, Prisma__directorClient<director>, Prisma__directorClient<directorGetPayload<T>>>

    /**
     * Update one Director.
     * @param {directorUpdateArgs} args - Arguments to update one Director.
     * @example
     * // Update one Director
     * const director = await prisma.director.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends directorUpdateArgs>(
      args: SelectSubset<T, directorUpdateArgs>
    ): CheckSelect<T, Prisma__directorClient<director>, Prisma__directorClient<directorGetPayload<T>>>

    /**
     * Delete zero or more Directors.
     * @param {directorDeleteManyArgs} args - Arguments to filter Directors to delete.
     * @example
     * // Delete a few Directors
     * const { count } = await prisma.director.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends directorDeleteManyArgs>(
      args?: SelectSubset<T, directorDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Directors.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {directorUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Directors
     * const director = await prisma.director.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends directorUpdateManyArgs>(
      args: SelectSubset<T, directorUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Director.
     * @param {directorUpsertArgs} args - Arguments to update or create a Director.
     * @example
     * // Update or create a Director
     * const director = await prisma.director.upsert({
     *   create: {
     *     // ... data to create a Director
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Director we want to update
     *   }
     * })
    **/
    upsert<T extends directorUpsertArgs>(
      args: SelectSubset<T, directorUpsertArgs>
    ): CheckSelect<T, Prisma__directorClient<director>, Prisma__directorClient<directorGetPayload<T>>>

    /**
     * Find one Director that matches the filter or throw
     * `NotFoundError` if no matches were found.
     * @param {directorFindUniqueOrThrowArgs} args - Arguments to find a Director
     * @example
     * // Get one Director
     * const director = await prisma.director.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends directorFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, directorFindUniqueOrThrowArgs>
    ): CheckSelect<T, Prisma__directorClient<director>, Prisma__directorClient<directorGetPayload<T>>>

    /**
     * Find the first Director that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {directorFindFirstOrThrowArgs} args - Arguments to find a Director
     * @example
     * // Get one Director
     * const director = await prisma.director.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends directorFindFirstOrThrowArgs>(
      args?: SelectSubset<T, directorFindFirstOrThrowArgs>
    ): CheckSelect<T, Prisma__directorClient<director>, Prisma__directorClient<directorGetPayload<T>>>

    /**
     * Count the number of Directors.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {directorCountArgs} args - Arguments to filter Directors to count.
     * @example
     * // Count the number of Directors
     * const count = await prisma.director.count({
     *   where: {
     *     // ... the filter for the Directors we want to count
     *   }
     * })
    **/
    count<T extends directorCountArgs>(
      args?: Subset<T, directorCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DirectorCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Director.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DirectorAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DirectorAggregateArgs>(args: Subset<T, DirectorAggregateArgs>): PrismaPromise<GetDirectorAggregateType<T>>

    /**
     * Group by Director.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DirectorGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DirectorGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DirectorGroupByArgs['orderBy'] }
        : { orderBy?: DirectorGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DirectorGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDirectorGroupByPayload<T> : PrismaPromise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for director.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__directorClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * director base type for findUnique actions
   */
  export type directorFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the director
     * 
    **/
    select?: directorSelect | null
    /**
     * Filter, which director to fetch.
     * 
    **/
    where: directorWhereUniqueInput
  }

  /**
   * director: findUnique
   */
  export interface directorFindUniqueArgs extends directorFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * director base type for findFirst actions
   */
  export type directorFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the director
     * 
    **/
    select?: directorSelect | null
    /**
     * Filter, which director to fetch.
     * 
    **/
    where?: directorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of directors to fetch.
     * 
    **/
    orderBy?: Enumerable<directorOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for directors.
     * 
    **/
    cursor?: directorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` directors from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` directors.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of directors.
     * 
    **/
    distinct?: Enumerable<DirectorScalarFieldEnum>
  }

  /**
   * director: findFirst
   */
  export interface directorFindFirstArgs extends directorFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * director findMany
   */
  export type directorFindManyArgs = {
    /**
     * Select specific fields to fetch from the director
     * 
    **/
    select?: directorSelect | null
    /**
     * Filter, which directors to fetch.
     * 
    **/
    where?: directorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of directors to fetch.
     * 
    **/
    orderBy?: Enumerable<directorOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing directors.
     * 
    **/
    cursor?: directorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` directors from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` directors.
     * 
    **/
    skip?: number
    distinct?: Enumerable<DirectorScalarFieldEnum>
  }


  /**
   * director create
   */
  export type directorCreateArgs = {
    /**
     * Select specific fields to fetch from the director
     * 
    **/
    select?: directorSelect | null
    /**
     * The data needed to create a director.
     * 
    **/
    data: XOR<directorCreateInput, directorUncheckedCreateInput>
  }


  /**
   * director createMany
   */
  export type directorCreateManyArgs = {
    /**
     * The data used to create many directors.
     * 
    **/
    data: Enumerable<directorCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * director update
   */
  export type directorUpdateArgs = {
    /**
     * Select specific fields to fetch from the director
     * 
    **/
    select?: directorSelect | null
    /**
     * The data needed to update a director.
     * 
    **/
    data: XOR<directorUpdateInput, directorUncheckedUpdateInput>
    /**
     * Choose, which director to update.
     * 
    **/
    where: directorWhereUniqueInput
  }


  /**
   * director updateMany
   */
  export type directorUpdateManyArgs = {
    /**
     * The data used to update directors.
     * 
    **/
    data: XOR<directorUpdateManyMutationInput, directorUncheckedUpdateManyInput>
    /**
     * Filter which directors to update
     * 
    **/
    where?: directorWhereInput
  }


  /**
   * director upsert
   */
  export type directorUpsertArgs = {
    /**
     * Select specific fields to fetch from the director
     * 
    **/
    select?: directorSelect | null
    /**
     * The filter to search for the director to update in case it exists.
     * 
    **/
    where: directorWhereUniqueInput
    /**
     * In case the director found by the `where` argument doesn't exist, create a new director with this data.
     * 
    **/
    create: XOR<directorCreateInput, directorUncheckedCreateInput>
    /**
     * In case the director was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<directorUpdateInput, directorUncheckedUpdateInput>
  }


  /**
   * director delete
   */
  export type directorDeleteArgs = {
    /**
     * Select specific fields to fetch from the director
     * 
    **/
    select?: directorSelect | null
    /**
     * Filter which director to delete.
     * 
    **/
    where: directorWhereUniqueInput
  }


  /**
   * director deleteMany
   */
  export type directorDeleteManyArgs = {
    /**
     * Filter which directors to delete
     * 
    **/
    where?: directorWhereInput
  }


  /**
   * director: findUniqueOrThrow
   */
  export type directorFindUniqueOrThrowArgs = directorFindUniqueArgsBase
      

  /**
   * director: findFirstOrThrow
   */
  export type directorFindFirstOrThrowArgs = directorFindFirstArgsBase
      

  /**
   * director without action
   */
  export type directorArgs = {
    /**
     * Select specific fields to fetch from the director
     * 
    **/
    select?: directorSelect | null
  }



  /**
   * Model exam
   */


  export type AggregateExam = {
    _count: ExamCountAggregateOutputType | null
    _avg: ExamAvgAggregateOutputType | null
    _sum: ExamSumAggregateOutputType | null
    _min: ExamMinAggregateOutputType | null
    _max: ExamMaxAggregateOutputType | null
  }

  export type ExamAvgAggregateOutputType = {
    exam_sem_id: number | null
    semester: number | null
    year: number | null
  }

  export type ExamSumAggregateOutputType = {
    exam_sem_id: number | null
    semester: number | null
    year: number | null
  }

  export type ExamMinAggregateOutputType = {
    exam_sem_id: number | null
    semester: number | null
    year: number | null
  }

  export type ExamMaxAggregateOutputType = {
    exam_sem_id: number | null
    semester: number | null
    year: number | null
  }

  export type ExamCountAggregateOutputType = {
    exam_sem_id: number
    semester: number
    year: number
    _all: number
  }


  export type ExamAvgAggregateInputType = {
    exam_sem_id?: true
    semester?: true
    year?: true
  }

  export type ExamSumAggregateInputType = {
    exam_sem_id?: true
    semester?: true
    year?: true
  }

  export type ExamMinAggregateInputType = {
    exam_sem_id?: true
    semester?: true
    year?: true
  }

  export type ExamMaxAggregateInputType = {
    exam_sem_id?: true
    semester?: true
    year?: true
  }

  export type ExamCountAggregateInputType = {
    exam_sem_id?: true
    semester?: true
    year?: true
    _all?: true
  }

  export type ExamAggregateArgs = {
    /**
     * Filter which exam to aggregate.
     * 
    **/
    where?: examWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of exams to fetch.
     * 
    **/
    orderBy?: Enumerable<examOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: examWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` exams from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` exams.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned exams
    **/
    _count?: true | ExamCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ExamAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ExamSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ExamMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ExamMaxAggregateInputType
  }

  export type GetExamAggregateType<T extends ExamAggregateArgs> = {
        [P in keyof T & keyof AggregateExam]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateExam[P]>
      : GetScalarType<T[P], AggregateExam[P]>
  }




  export type ExamGroupByArgs = {
    where?: examWhereInput
    orderBy?: Enumerable<examOrderByWithAggregationInput>
    by: Array<ExamScalarFieldEnum>
    having?: examScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ExamCountAggregateInputType | true
    _avg?: ExamAvgAggregateInputType
    _sum?: ExamSumAggregateInputType
    _min?: ExamMinAggregateInputType
    _max?: ExamMaxAggregateInputType
  }


  export type ExamGroupByOutputType = {
    exam_sem_id: number
    semester: number
    year: number
    _count: ExamCountAggregateOutputType | null
    _avg: ExamAvgAggregateOutputType | null
    _sum: ExamSumAggregateOutputType | null
    _min: ExamMinAggregateOutputType | null
    _max: ExamMaxAggregateOutputType | null
  }

  type GetExamGroupByPayload<T extends ExamGroupByArgs> = PrismaPromise<
    Array<
      PickArray<ExamGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ExamGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ExamGroupByOutputType[P]>
            : GetScalarType<T[P], ExamGroupByOutputType[P]>
        }
      >
    >


  export type examSelect = {
    exam_sem_id?: boolean
    semester?: boolean
    year?: boolean
  }

  export type examGetPayload<
    S extends boolean | null | undefined | examArgs,
    U = keyof S
      > = S extends true
        ? exam
    : S extends undefined
    ? never
    : S extends examArgs | examFindManyArgs
    ?'include' extends U
    ? exam 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
    P extends keyof exam ? exam[P] : never
  } 
    : exam
  : exam


  type examCountArgs = Merge<
    Omit<examFindManyArgs, 'select' | 'include'> & {
      select?: ExamCountAggregateInputType | true
    }
  >

  export interface examDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one Exam that matches the filter.
     * @param {examFindUniqueArgs} args - Arguments to find a Exam
     * @example
     * // Get one Exam
     * const exam = await prisma.exam.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends examFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, examFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'exam'> extends True ? CheckSelect<T, Prisma__examClient<exam>, Prisma__examClient<examGetPayload<T>>> : CheckSelect<T, Prisma__examClient<exam | null >, Prisma__examClient<examGetPayload<T> | null >>

    /**
     * Find the first Exam that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {examFindFirstArgs} args - Arguments to find a Exam
     * @example
     * // Get one Exam
     * const exam = await prisma.exam.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends examFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, examFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'exam'> extends True ? CheckSelect<T, Prisma__examClient<exam>, Prisma__examClient<examGetPayload<T>>> : CheckSelect<T, Prisma__examClient<exam | null >, Prisma__examClient<examGetPayload<T> | null >>

    /**
     * Find zero or more Exams that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {examFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Exams
     * const exams = await prisma.exam.findMany()
     * 
     * // Get first 10 Exams
     * const exams = await prisma.exam.findMany({ take: 10 })
     * 
     * // Only select the `exam_sem_id`
     * const examWithExam_sem_idOnly = await prisma.exam.findMany({ select: { exam_sem_id: true } })
     * 
    **/
    findMany<T extends examFindManyArgs>(
      args?: SelectSubset<T, examFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<exam>>, PrismaPromise<Array<examGetPayload<T>>>>

    /**
     * Create a Exam.
     * @param {examCreateArgs} args - Arguments to create a Exam.
     * @example
     * // Create one Exam
     * const Exam = await prisma.exam.create({
     *   data: {
     *     // ... data to create a Exam
     *   }
     * })
     * 
    **/
    create<T extends examCreateArgs>(
      args: SelectSubset<T, examCreateArgs>
    ): CheckSelect<T, Prisma__examClient<exam>, Prisma__examClient<examGetPayload<T>>>

    /**
     * Create many Exams.
     *     @param {examCreateManyArgs} args - Arguments to create many Exams.
     *     @example
     *     // Create many Exams
     *     const exam = await prisma.exam.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends examCreateManyArgs>(
      args?: SelectSubset<T, examCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Exam.
     * @param {examDeleteArgs} args - Arguments to delete one Exam.
     * @example
     * // Delete one Exam
     * const Exam = await prisma.exam.delete({
     *   where: {
     *     // ... filter to delete one Exam
     *   }
     * })
     * 
    **/
    delete<T extends examDeleteArgs>(
      args: SelectSubset<T, examDeleteArgs>
    ): CheckSelect<T, Prisma__examClient<exam>, Prisma__examClient<examGetPayload<T>>>

    /**
     * Update one Exam.
     * @param {examUpdateArgs} args - Arguments to update one Exam.
     * @example
     * // Update one Exam
     * const exam = await prisma.exam.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends examUpdateArgs>(
      args: SelectSubset<T, examUpdateArgs>
    ): CheckSelect<T, Prisma__examClient<exam>, Prisma__examClient<examGetPayload<T>>>

    /**
     * Delete zero or more Exams.
     * @param {examDeleteManyArgs} args - Arguments to filter Exams to delete.
     * @example
     * // Delete a few Exams
     * const { count } = await prisma.exam.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends examDeleteManyArgs>(
      args?: SelectSubset<T, examDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Exams.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {examUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Exams
     * const exam = await prisma.exam.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends examUpdateManyArgs>(
      args: SelectSubset<T, examUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Exam.
     * @param {examUpsertArgs} args - Arguments to update or create a Exam.
     * @example
     * // Update or create a Exam
     * const exam = await prisma.exam.upsert({
     *   create: {
     *     // ... data to create a Exam
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Exam we want to update
     *   }
     * })
    **/
    upsert<T extends examUpsertArgs>(
      args: SelectSubset<T, examUpsertArgs>
    ): CheckSelect<T, Prisma__examClient<exam>, Prisma__examClient<examGetPayload<T>>>

    /**
     * Find one Exam that matches the filter or throw
     * `NotFoundError` if no matches were found.
     * @param {examFindUniqueOrThrowArgs} args - Arguments to find a Exam
     * @example
     * // Get one Exam
     * const exam = await prisma.exam.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends examFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, examFindUniqueOrThrowArgs>
    ): CheckSelect<T, Prisma__examClient<exam>, Prisma__examClient<examGetPayload<T>>>

    /**
     * Find the first Exam that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {examFindFirstOrThrowArgs} args - Arguments to find a Exam
     * @example
     * // Get one Exam
     * const exam = await prisma.exam.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends examFindFirstOrThrowArgs>(
      args?: SelectSubset<T, examFindFirstOrThrowArgs>
    ): CheckSelect<T, Prisma__examClient<exam>, Prisma__examClient<examGetPayload<T>>>

    /**
     * Count the number of Exams.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {examCountArgs} args - Arguments to filter Exams to count.
     * @example
     * // Count the number of Exams
     * const count = await prisma.exam.count({
     *   where: {
     *     // ... the filter for the Exams we want to count
     *   }
     * })
    **/
    count<T extends examCountArgs>(
      args?: Subset<T, examCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ExamCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Exam.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExamAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ExamAggregateArgs>(args: Subset<T, ExamAggregateArgs>): PrismaPromise<GetExamAggregateType<T>>

    /**
     * Group by Exam.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExamGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ExamGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ExamGroupByArgs['orderBy'] }
        : { orderBy?: ExamGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ExamGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetExamGroupByPayload<T> : PrismaPromise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for exam.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__examClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * exam base type for findUnique actions
   */
  export type examFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the exam
     * 
    **/
    select?: examSelect | null
    /**
     * Filter, which exam to fetch.
     * 
    **/
    where: examWhereUniqueInput
  }

  /**
   * exam: findUnique
   */
  export interface examFindUniqueArgs extends examFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * exam base type for findFirst actions
   */
  export type examFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the exam
     * 
    **/
    select?: examSelect | null
    /**
     * Filter, which exam to fetch.
     * 
    **/
    where?: examWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of exams to fetch.
     * 
    **/
    orderBy?: Enumerable<examOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for exams.
     * 
    **/
    cursor?: examWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` exams from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` exams.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of exams.
     * 
    **/
    distinct?: Enumerable<ExamScalarFieldEnum>
  }

  /**
   * exam: findFirst
   */
  export interface examFindFirstArgs extends examFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * exam findMany
   */
  export type examFindManyArgs = {
    /**
     * Select specific fields to fetch from the exam
     * 
    **/
    select?: examSelect | null
    /**
     * Filter, which exams to fetch.
     * 
    **/
    where?: examWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of exams to fetch.
     * 
    **/
    orderBy?: Enumerable<examOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing exams.
     * 
    **/
    cursor?: examWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` exams from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` exams.
     * 
    **/
    skip?: number
    distinct?: Enumerable<ExamScalarFieldEnum>
  }


  /**
   * exam create
   */
  export type examCreateArgs = {
    /**
     * Select specific fields to fetch from the exam
     * 
    **/
    select?: examSelect | null
    /**
     * The data needed to create a exam.
     * 
    **/
    data: XOR<examCreateInput, examUncheckedCreateInput>
  }


  /**
   * exam createMany
   */
  export type examCreateManyArgs = {
    /**
     * The data used to create many exams.
     * 
    **/
    data: Enumerable<examCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * exam update
   */
  export type examUpdateArgs = {
    /**
     * Select specific fields to fetch from the exam
     * 
    **/
    select?: examSelect | null
    /**
     * The data needed to update a exam.
     * 
    **/
    data: XOR<examUpdateInput, examUncheckedUpdateInput>
    /**
     * Choose, which exam to update.
     * 
    **/
    where: examWhereUniqueInput
  }


  /**
   * exam updateMany
   */
  export type examUpdateManyArgs = {
    /**
     * The data used to update exams.
     * 
    **/
    data: XOR<examUpdateManyMutationInput, examUncheckedUpdateManyInput>
    /**
     * Filter which exams to update
     * 
    **/
    where?: examWhereInput
  }


  /**
   * exam upsert
   */
  export type examUpsertArgs = {
    /**
     * Select specific fields to fetch from the exam
     * 
    **/
    select?: examSelect | null
    /**
     * The filter to search for the exam to update in case it exists.
     * 
    **/
    where: examWhereUniqueInput
    /**
     * In case the exam found by the `where` argument doesn't exist, create a new exam with this data.
     * 
    **/
    create: XOR<examCreateInput, examUncheckedCreateInput>
    /**
     * In case the exam was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<examUpdateInput, examUncheckedUpdateInput>
  }


  /**
   * exam delete
   */
  export type examDeleteArgs = {
    /**
     * Select specific fields to fetch from the exam
     * 
    **/
    select?: examSelect | null
    /**
     * Filter which exam to delete.
     * 
    **/
    where: examWhereUniqueInput
  }


  /**
   * exam deleteMany
   */
  export type examDeleteManyArgs = {
    /**
     * Filter which exams to delete
     * 
    **/
    where?: examWhereInput
  }


  /**
   * exam: findUniqueOrThrow
   */
  export type examFindUniqueOrThrowArgs = examFindUniqueArgsBase
      

  /**
   * exam: findFirstOrThrow
   */
  export type examFindFirstOrThrowArgs = examFindFirstArgsBase
      

  /**
   * exam without action
   */
  export type examArgs = {
    /**
     * Select specific fields to fetch from the exam
     * 
    **/
    select?: examSelect | null
  }



  /**
   * Model exam_mark
   */


  export type AggregateExam_mark = {
    _count: Exam_markCountAggregateOutputType | null
    _avg: Exam_markAvgAggregateOutputType | null
    _sum: Exam_markSumAggregateOutputType | null
    _min: Exam_markMinAggregateOutputType | null
    _max: Exam_markMaxAggregateOutputType | null
  }

  export type Exam_markAvgAggregateOutputType = {
    mark_id: number | null
    total_mark: number | null
    exam_sem_id: number | null
    director_id: number | null
    head_of_exam_id: number | null
    index_no: number | null
  }

  export type Exam_markSumAggregateOutputType = {
    mark_id: number | null
    total_mark: number | null
    exam_sem_id: number | null
    director_id: number | null
    head_of_exam_id: number | null
    index_no: number | null
  }

  export type Exam_markMinAggregateOutputType = {
    mark_id: number | null
    course_code: string | null
    course_name: string | null
    grade: string | null
    total_mark: number | null
    director_status: string | null
    head_of_exam_status: string | null
    exam_sem_id: number | null
    director_id: number | null
    head_of_exam_id: number | null
    index_no: number | null
  }

  export type Exam_markMaxAggregateOutputType = {
    mark_id: number | null
    course_code: string | null
    course_name: string | null
    grade: string | null
    total_mark: number | null
    director_status: string | null
    head_of_exam_status: string | null
    exam_sem_id: number | null
    director_id: number | null
    head_of_exam_id: number | null
    index_no: number | null
  }

  export type Exam_markCountAggregateOutputType = {
    mark_id: number
    course_code: number
    course_name: number
    grade: number
    total_mark: number
    director_status: number
    head_of_exam_status: number
    exam_sem_id: number
    director_id: number
    head_of_exam_id: number
    index_no: number
    _all: number
  }


  export type Exam_markAvgAggregateInputType = {
    mark_id?: true
    total_mark?: true
    exam_sem_id?: true
    director_id?: true
    head_of_exam_id?: true
    index_no?: true
  }

  export type Exam_markSumAggregateInputType = {
    mark_id?: true
    total_mark?: true
    exam_sem_id?: true
    director_id?: true
    head_of_exam_id?: true
    index_no?: true
  }

  export type Exam_markMinAggregateInputType = {
    mark_id?: true
    course_code?: true
    course_name?: true
    grade?: true
    total_mark?: true
    director_status?: true
    head_of_exam_status?: true
    exam_sem_id?: true
    director_id?: true
    head_of_exam_id?: true
    index_no?: true
  }

  export type Exam_markMaxAggregateInputType = {
    mark_id?: true
    course_code?: true
    course_name?: true
    grade?: true
    total_mark?: true
    director_status?: true
    head_of_exam_status?: true
    exam_sem_id?: true
    director_id?: true
    head_of_exam_id?: true
    index_no?: true
  }

  export type Exam_markCountAggregateInputType = {
    mark_id?: true
    course_code?: true
    course_name?: true
    grade?: true
    total_mark?: true
    director_status?: true
    head_of_exam_status?: true
    exam_sem_id?: true
    director_id?: true
    head_of_exam_id?: true
    index_no?: true
    _all?: true
  }

  export type Exam_markAggregateArgs = {
    /**
     * Filter which exam_mark to aggregate.
     * 
    **/
    where?: exam_markWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of exam_marks to fetch.
     * 
    **/
    orderBy?: Enumerable<exam_markOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: exam_markWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` exam_marks from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` exam_marks.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned exam_marks
    **/
    _count?: true | Exam_markCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Exam_markAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Exam_markSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Exam_markMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Exam_markMaxAggregateInputType
  }

  export type GetExam_markAggregateType<T extends Exam_markAggregateArgs> = {
        [P in keyof T & keyof AggregateExam_mark]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateExam_mark[P]>
      : GetScalarType<T[P], AggregateExam_mark[P]>
  }




  export type Exam_markGroupByArgs = {
    where?: exam_markWhereInput
    orderBy?: Enumerable<exam_markOrderByWithAggregationInput>
    by: Array<Exam_markScalarFieldEnum>
    having?: exam_markScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Exam_markCountAggregateInputType | true
    _avg?: Exam_markAvgAggregateInputType
    _sum?: Exam_markSumAggregateInputType
    _min?: Exam_markMinAggregateInputType
    _max?: Exam_markMaxAggregateInputType
  }


  export type Exam_markGroupByOutputType = {
    mark_id: number
    course_code: string
    course_name: string
    grade: string
    total_mark: number
    director_status: string
    head_of_exam_status: string
    exam_sem_id: number
    director_id: number
    head_of_exam_id: number
    index_no: number
    _count: Exam_markCountAggregateOutputType | null
    _avg: Exam_markAvgAggregateOutputType | null
    _sum: Exam_markSumAggregateOutputType | null
    _min: Exam_markMinAggregateOutputType | null
    _max: Exam_markMaxAggregateOutputType | null
  }

  type GetExam_markGroupByPayload<T extends Exam_markGroupByArgs> = PrismaPromise<
    Array<
      PickArray<Exam_markGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Exam_markGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Exam_markGroupByOutputType[P]>
            : GetScalarType<T[P], Exam_markGroupByOutputType[P]>
        }
      >
    >


  export type exam_markSelect = {
    mark_id?: boolean
    course_code?: boolean
    course_name?: boolean
    grade?: boolean
    total_mark?: boolean
    director_status?: boolean
    head_of_exam_status?: boolean
    exam_sem_id?: boolean
    director_id?: boolean
    head_of_exam_id?: boolean
    index_no?: boolean
  }

  export type exam_markGetPayload<
    S extends boolean | null | undefined | exam_markArgs,
    U = keyof S
      > = S extends true
        ? exam_mark
    : S extends undefined
    ? never
    : S extends exam_markArgs | exam_markFindManyArgs
    ?'include' extends U
    ? exam_mark 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
    P extends keyof exam_mark ? exam_mark[P] : never
  } 
    : exam_mark
  : exam_mark


  type exam_markCountArgs = Merge<
    Omit<exam_markFindManyArgs, 'select' | 'include'> & {
      select?: Exam_markCountAggregateInputType | true
    }
  >

  export interface exam_markDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one Exam_mark that matches the filter.
     * @param {exam_markFindUniqueArgs} args - Arguments to find a Exam_mark
     * @example
     * // Get one Exam_mark
     * const exam_mark = await prisma.exam_mark.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends exam_markFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, exam_markFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'exam_mark'> extends True ? CheckSelect<T, Prisma__exam_markClient<exam_mark>, Prisma__exam_markClient<exam_markGetPayload<T>>> : CheckSelect<T, Prisma__exam_markClient<exam_mark | null >, Prisma__exam_markClient<exam_markGetPayload<T> | null >>

    /**
     * Find the first Exam_mark that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {exam_markFindFirstArgs} args - Arguments to find a Exam_mark
     * @example
     * // Get one Exam_mark
     * const exam_mark = await prisma.exam_mark.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends exam_markFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, exam_markFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'exam_mark'> extends True ? CheckSelect<T, Prisma__exam_markClient<exam_mark>, Prisma__exam_markClient<exam_markGetPayload<T>>> : CheckSelect<T, Prisma__exam_markClient<exam_mark | null >, Prisma__exam_markClient<exam_markGetPayload<T> | null >>

    /**
     * Find zero or more Exam_marks that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {exam_markFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Exam_marks
     * const exam_marks = await prisma.exam_mark.findMany()
     * 
     * // Get first 10 Exam_marks
     * const exam_marks = await prisma.exam_mark.findMany({ take: 10 })
     * 
     * // Only select the `mark_id`
     * const exam_markWithMark_idOnly = await prisma.exam_mark.findMany({ select: { mark_id: true } })
     * 
    **/
    findMany<T extends exam_markFindManyArgs>(
      args?: SelectSubset<T, exam_markFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<exam_mark>>, PrismaPromise<Array<exam_markGetPayload<T>>>>

    /**
     * Create a Exam_mark.
     * @param {exam_markCreateArgs} args - Arguments to create a Exam_mark.
     * @example
     * // Create one Exam_mark
     * const Exam_mark = await prisma.exam_mark.create({
     *   data: {
     *     // ... data to create a Exam_mark
     *   }
     * })
     * 
    **/
    create<T extends exam_markCreateArgs>(
      args: SelectSubset<T, exam_markCreateArgs>
    ): CheckSelect<T, Prisma__exam_markClient<exam_mark>, Prisma__exam_markClient<exam_markGetPayload<T>>>

    /**
     * Create many Exam_marks.
     *     @param {exam_markCreateManyArgs} args - Arguments to create many Exam_marks.
     *     @example
     *     // Create many Exam_marks
     *     const exam_mark = await prisma.exam_mark.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends exam_markCreateManyArgs>(
      args?: SelectSubset<T, exam_markCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Exam_mark.
     * @param {exam_markDeleteArgs} args - Arguments to delete one Exam_mark.
     * @example
     * // Delete one Exam_mark
     * const Exam_mark = await prisma.exam_mark.delete({
     *   where: {
     *     // ... filter to delete one Exam_mark
     *   }
     * })
     * 
    **/
    delete<T extends exam_markDeleteArgs>(
      args: SelectSubset<T, exam_markDeleteArgs>
    ): CheckSelect<T, Prisma__exam_markClient<exam_mark>, Prisma__exam_markClient<exam_markGetPayload<T>>>

    /**
     * Update one Exam_mark.
     * @param {exam_markUpdateArgs} args - Arguments to update one Exam_mark.
     * @example
     * // Update one Exam_mark
     * const exam_mark = await prisma.exam_mark.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends exam_markUpdateArgs>(
      args: SelectSubset<T, exam_markUpdateArgs>
    ): CheckSelect<T, Prisma__exam_markClient<exam_mark>, Prisma__exam_markClient<exam_markGetPayload<T>>>

    /**
     * Delete zero or more Exam_marks.
     * @param {exam_markDeleteManyArgs} args - Arguments to filter Exam_marks to delete.
     * @example
     * // Delete a few Exam_marks
     * const { count } = await prisma.exam_mark.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends exam_markDeleteManyArgs>(
      args?: SelectSubset<T, exam_markDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Exam_marks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {exam_markUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Exam_marks
     * const exam_mark = await prisma.exam_mark.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends exam_markUpdateManyArgs>(
      args: SelectSubset<T, exam_markUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Exam_mark.
     * @param {exam_markUpsertArgs} args - Arguments to update or create a Exam_mark.
     * @example
     * // Update or create a Exam_mark
     * const exam_mark = await prisma.exam_mark.upsert({
     *   create: {
     *     // ... data to create a Exam_mark
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Exam_mark we want to update
     *   }
     * })
    **/
    upsert<T extends exam_markUpsertArgs>(
      args: SelectSubset<T, exam_markUpsertArgs>
    ): CheckSelect<T, Prisma__exam_markClient<exam_mark>, Prisma__exam_markClient<exam_markGetPayload<T>>>

    /**
     * Find one Exam_mark that matches the filter or throw
     * `NotFoundError` if no matches were found.
     * @param {exam_markFindUniqueOrThrowArgs} args - Arguments to find a Exam_mark
     * @example
     * // Get one Exam_mark
     * const exam_mark = await prisma.exam_mark.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends exam_markFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, exam_markFindUniqueOrThrowArgs>
    ): CheckSelect<T, Prisma__exam_markClient<exam_mark>, Prisma__exam_markClient<exam_markGetPayload<T>>>

    /**
     * Find the first Exam_mark that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {exam_markFindFirstOrThrowArgs} args - Arguments to find a Exam_mark
     * @example
     * // Get one Exam_mark
     * const exam_mark = await prisma.exam_mark.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends exam_markFindFirstOrThrowArgs>(
      args?: SelectSubset<T, exam_markFindFirstOrThrowArgs>
    ): CheckSelect<T, Prisma__exam_markClient<exam_mark>, Prisma__exam_markClient<exam_markGetPayload<T>>>

    /**
     * Count the number of Exam_marks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {exam_markCountArgs} args - Arguments to filter Exam_marks to count.
     * @example
     * // Count the number of Exam_marks
     * const count = await prisma.exam_mark.count({
     *   where: {
     *     // ... the filter for the Exam_marks we want to count
     *   }
     * })
    **/
    count<T extends exam_markCountArgs>(
      args?: Subset<T, exam_markCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Exam_markCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Exam_mark.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Exam_markAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Exam_markAggregateArgs>(args: Subset<T, Exam_markAggregateArgs>): PrismaPromise<GetExam_markAggregateType<T>>

    /**
     * Group by Exam_mark.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Exam_markGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends Exam_markGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: Exam_markGroupByArgs['orderBy'] }
        : { orderBy?: Exam_markGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, Exam_markGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetExam_markGroupByPayload<T> : PrismaPromise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for exam_mark.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__exam_markClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * exam_mark base type for findUnique actions
   */
  export type exam_markFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the exam_mark
     * 
    **/
    select?: exam_markSelect | null
    /**
     * Filter, which exam_mark to fetch.
     * 
    **/
    where: exam_markWhereUniqueInput
  }

  /**
   * exam_mark: findUnique
   */
  export interface exam_markFindUniqueArgs extends exam_markFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * exam_mark base type for findFirst actions
   */
  export type exam_markFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the exam_mark
     * 
    **/
    select?: exam_markSelect | null
    /**
     * Filter, which exam_mark to fetch.
     * 
    **/
    where?: exam_markWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of exam_marks to fetch.
     * 
    **/
    orderBy?: Enumerable<exam_markOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for exam_marks.
     * 
    **/
    cursor?: exam_markWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` exam_marks from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` exam_marks.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of exam_marks.
     * 
    **/
    distinct?: Enumerable<Exam_markScalarFieldEnum>
  }

  /**
   * exam_mark: findFirst
   */
  export interface exam_markFindFirstArgs extends exam_markFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * exam_mark findMany
   */
  export type exam_markFindManyArgs = {
    /**
     * Select specific fields to fetch from the exam_mark
     * 
    **/
    select?: exam_markSelect | null
    /**
     * Filter, which exam_marks to fetch.
     * 
    **/
    where?: exam_markWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of exam_marks to fetch.
     * 
    **/
    orderBy?: Enumerable<exam_markOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing exam_marks.
     * 
    **/
    cursor?: exam_markWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` exam_marks from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` exam_marks.
     * 
    **/
    skip?: number
    distinct?: Enumerable<Exam_markScalarFieldEnum>
  }


  /**
   * exam_mark create
   */
  export type exam_markCreateArgs = {
    /**
     * Select specific fields to fetch from the exam_mark
     * 
    **/
    select?: exam_markSelect | null
    /**
     * The data needed to create a exam_mark.
     * 
    **/
    data: XOR<exam_markCreateInput, exam_markUncheckedCreateInput>
  }


  /**
   * exam_mark createMany
   */
  export type exam_markCreateManyArgs = {
    /**
     * The data used to create many exam_marks.
     * 
    **/
    data: Enumerable<exam_markCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * exam_mark update
   */
  export type exam_markUpdateArgs = {
    /**
     * Select specific fields to fetch from the exam_mark
     * 
    **/
    select?: exam_markSelect | null
    /**
     * The data needed to update a exam_mark.
     * 
    **/
    data: XOR<exam_markUpdateInput, exam_markUncheckedUpdateInput>
    /**
     * Choose, which exam_mark to update.
     * 
    **/
    where: exam_markWhereUniqueInput
  }


  /**
   * exam_mark updateMany
   */
  export type exam_markUpdateManyArgs = {
    /**
     * The data used to update exam_marks.
     * 
    **/
    data: XOR<exam_markUpdateManyMutationInput, exam_markUncheckedUpdateManyInput>
    /**
     * Filter which exam_marks to update
     * 
    **/
    where?: exam_markWhereInput
  }


  /**
   * exam_mark upsert
   */
  export type exam_markUpsertArgs = {
    /**
     * Select specific fields to fetch from the exam_mark
     * 
    **/
    select?: exam_markSelect | null
    /**
     * The filter to search for the exam_mark to update in case it exists.
     * 
    **/
    where: exam_markWhereUniqueInput
    /**
     * In case the exam_mark found by the `where` argument doesn't exist, create a new exam_mark with this data.
     * 
    **/
    create: XOR<exam_markCreateInput, exam_markUncheckedCreateInput>
    /**
     * In case the exam_mark was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<exam_markUpdateInput, exam_markUncheckedUpdateInput>
  }


  /**
   * exam_mark delete
   */
  export type exam_markDeleteArgs = {
    /**
     * Select specific fields to fetch from the exam_mark
     * 
    **/
    select?: exam_markSelect | null
    /**
     * Filter which exam_mark to delete.
     * 
    **/
    where: exam_markWhereUniqueInput
  }


  /**
   * exam_mark deleteMany
   */
  export type exam_markDeleteManyArgs = {
    /**
     * Filter which exam_marks to delete
     * 
    **/
    where?: exam_markWhereInput
  }


  /**
   * exam_mark: findUniqueOrThrow
   */
  export type exam_markFindUniqueOrThrowArgs = exam_markFindUniqueArgsBase
      

  /**
   * exam_mark: findFirstOrThrow
   */
  export type exam_markFindFirstOrThrowArgs = exam_markFindFirstArgsBase
      

  /**
   * exam_mark without action
   */
  export type exam_markArgs = {
    /**
     * Select specific fields to fetch from the exam_mark
     * 
    **/
    select?: exam_markSelect | null
  }



  /**
   * Model exam_timetable
   */


  export type AggregateExam_timetable = {
    _count: Exam_timetableCountAggregateOutputType | null
    _avg: Exam_timetableAvgAggregateOutputType | null
    _sum: Exam_timetableSumAggregateOutputType | null
    _min: Exam_timetableMinAggregateOutputType | null
    _max: Exam_timetableMaxAggregateOutputType | null
  }

  export type Exam_timetableAvgAggregateOutputType = {
    timetable_id: number | null
    exam_sem_id: number | null
  }

  export type Exam_timetableSumAggregateOutputType = {
    timetable_id: number | null
    exam_sem_id: number | null
  }

  export type Exam_timetableMinAggregateOutputType = {
    timetable_id: number | null
    exam_date: Date | null
    exam_time: Date | null
    course_code: string | null
    course_name: string | null
    exam_sem_id: number | null
  }

  export type Exam_timetableMaxAggregateOutputType = {
    timetable_id: number | null
    exam_date: Date | null
    exam_time: Date | null
    course_code: string | null
    course_name: string | null
    exam_sem_id: number | null
  }

  export type Exam_timetableCountAggregateOutputType = {
    timetable_id: number
    exam_date: number
    exam_time: number
    course_code: number
    course_name: number
    exam_sem_id: number
    _all: number
  }


  export type Exam_timetableAvgAggregateInputType = {
    timetable_id?: true
    exam_sem_id?: true
  }

  export type Exam_timetableSumAggregateInputType = {
    timetable_id?: true
    exam_sem_id?: true
  }

  export type Exam_timetableMinAggregateInputType = {
    timetable_id?: true
    exam_date?: true
    exam_time?: true
    course_code?: true
    course_name?: true
    exam_sem_id?: true
  }

  export type Exam_timetableMaxAggregateInputType = {
    timetable_id?: true
    exam_date?: true
    exam_time?: true
    course_code?: true
    course_name?: true
    exam_sem_id?: true
  }

  export type Exam_timetableCountAggregateInputType = {
    timetable_id?: true
    exam_date?: true
    exam_time?: true
    course_code?: true
    course_name?: true
    exam_sem_id?: true
    _all?: true
  }

  export type Exam_timetableAggregateArgs = {
    /**
     * Filter which exam_timetable to aggregate.
     * 
    **/
    where?: exam_timetableWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of exam_timetables to fetch.
     * 
    **/
    orderBy?: Enumerable<exam_timetableOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: exam_timetableWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` exam_timetables from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` exam_timetables.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned exam_timetables
    **/
    _count?: true | Exam_timetableCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Exam_timetableAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Exam_timetableSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Exam_timetableMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Exam_timetableMaxAggregateInputType
  }

  export type GetExam_timetableAggregateType<T extends Exam_timetableAggregateArgs> = {
        [P in keyof T & keyof AggregateExam_timetable]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateExam_timetable[P]>
      : GetScalarType<T[P], AggregateExam_timetable[P]>
  }




  export type Exam_timetableGroupByArgs = {
    where?: exam_timetableWhereInput
    orderBy?: Enumerable<exam_timetableOrderByWithAggregationInput>
    by: Array<Exam_timetableScalarFieldEnum>
    having?: exam_timetableScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Exam_timetableCountAggregateInputType | true
    _avg?: Exam_timetableAvgAggregateInputType
    _sum?: Exam_timetableSumAggregateInputType
    _min?: Exam_timetableMinAggregateInputType
    _max?: Exam_timetableMaxAggregateInputType
  }


  export type Exam_timetableGroupByOutputType = {
    timetable_id: number
    exam_date: Date
    exam_time: Date
    course_code: string
    course_name: string
    exam_sem_id: number
    _count: Exam_timetableCountAggregateOutputType | null
    _avg: Exam_timetableAvgAggregateOutputType | null
    _sum: Exam_timetableSumAggregateOutputType | null
    _min: Exam_timetableMinAggregateOutputType | null
    _max: Exam_timetableMaxAggregateOutputType | null
  }

  type GetExam_timetableGroupByPayload<T extends Exam_timetableGroupByArgs> = PrismaPromise<
    Array<
      PickArray<Exam_timetableGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Exam_timetableGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Exam_timetableGroupByOutputType[P]>
            : GetScalarType<T[P], Exam_timetableGroupByOutputType[P]>
        }
      >
    >


  export type exam_timetableSelect = {
    timetable_id?: boolean
    exam_date?: boolean
    exam_time?: boolean
    course_code?: boolean
    course_name?: boolean
    exam_sem_id?: boolean
  }

  export type exam_timetableGetPayload<
    S extends boolean | null | undefined | exam_timetableArgs,
    U = keyof S
      > = S extends true
        ? exam_timetable
    : S extends undefined
    ? never
    : S extends exam_timetableArgs | exam_timetableFindManyArgs
    ?'include' extends U
    ? exam_timetable 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
    P extends keyof exam_timetable ? exam_timetable[P] : never
  } 
    : exam_timetable
  : exam_timetable


  type exam_timetableCountArgs = Merge<
    Omit<exam_timetableFindManyArgs, 'select' | 'include'> & {
      select?: Exam_timetableCountAggregateInputType | true
    }
  >

  export interface exam_timetableDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one Exam_timetable that matches the filter.
     * @param {exam_timetableFindUniqueArgs} args - Arguments to find a Exam_timetable
     * @example
     * // Get one Exam_timetable
     * const exam_timetable = await prisma.exam_timetable.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends exam_timetableFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, exam_timetableFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'exam_timetable'> extends True ? CheckSelect<T, Prisma__exam_timetableClient<exam_timetable>, Prisma__exam_timetableClient<exam_timetableGetPayload<T>>> : CheckSelect<T, Prisma__exam_timetableClient<exam_timetable | null >, Prisma__exam_timetableClient<exam_timetableGetPayload<T> | null >>

    /**
     * Find the first Exam_timetable that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {exam_timetableFindFirstArgs} args - Arguments to find a Exam_timetable
     * @example
     * // Get one Exam_timetable
     * const exam_timetable = await prisma.exam_timetable.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends exam_timetableFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, exam_timetableFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'exam_timetable'> extends True ? CheckSelect<T, Prisma__exam_timetableClient<exam_timetable>, Prisma__exam_timetableClient<exam_timetableGetPayload<T>>> : CheckSelect<T, Prisma__exam_timetableClient<exam_timetable | null >, Prisma__exam_timetableClient<exam_timetableGetPayload<T> | null >>

    /**
     * Find zero or more Exam_timetables that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {exam_timetableFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Exam_timetables
     * const exam_timetables = await prisma.exam_timetable.findMany()
     * 
     * // Get first 10 Exam_timetables
     * const exam_timetables = await prisma.exam_timetable.findMany({ take: 10 })
     * 
     * // Only select the `timetable_id`
     * const exam_timetableWithTimetable_idOnly = await prisma.exam_timetable.findMany({ select: { timetable_id: true } })
     * 
    **/
    findMany<T extends exam_timetableFindManyArgs>(
      args?: SelectSubset<T, exam_timetableFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<exam_timetable>>, PrismaPromise<Array<exam_timetableGetPayload<T>>>>

    /**
     * Create a Exam_timetable.
     * @param {exam_timetableCreateArgs} args - Arguments to create a Exam_timetable.
     * @example
     * // Create one Exam_timetable
     * const Exam_timetable = await prisma.exam_timetable.create({
     *   data: {
     *     // ... data to create a Exam_timetable
     *   }
     * })
     * 
    **/
    create<T extends exam_timetableCreateArgs>(
      args: SelectSubset<T, exam_timetableCreateArgs>
    ): CheckSelect<T, Prisma__exam_timetableClient<exam_timetable>, Prisma__exam_timetableClient<exam_timetableGetPayload<T>>>

    /**
     * Create many Exam_timetables.
     *     @param {exam_timetableCreateManyArgs} args - Arguments to create many Exam_timetables.
     *     @example
     *     // Create many Exam_timetables
     *     const exam_timetable = await prisma.exam_timetable.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends exam_timetableCreateManyArgs>(
      args?: SelectSubset<T, exam_timetableCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Exam_timetable.
     * @param {exam_timetableDeleteArgs} args - Arguments to delete one Exam_timetable.
     * @example
     * // Delete one Exam_timetable
     * const Exam_timetable = await prisma.exam_timetable.delete({
     *   where: {
     *     // ... filter to delete one Exam_timetable
     *   }
     * })
     * 
    **/
    delete<T extends exam_timetableDeleteArgs>(
      args: SelectSubset<T, exam_timetableDeleteArgs>
    ): CheckSelect<T, Prisma__exam_timetableClient<exam_timetable>, Prisma__exam_timetableClient<exam_timetableGetPayload<T>>>

    /**
     * Update one Exam_timetable.
     * @param {exam_timetableUpdateArgs} args - Arguments to update one Exam_timetable.
     * @example
     * // Update one Exam_timetable
     * const exam_timetable = await prisma.exam_timetable.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends exam_timetableUpdateArgs>(
      args: SelectSubset<T, exam_timetableUpdateArgs>
    ): CheckSelect<T, Prisma__exam_timetableClient<exam_timetable>, Prisma__exam_timetableClient<exam_timetableGetPayload<T>>>

    /**
     * Delete zero or more Exam_timetables.
     * @param {exam_timetableDeleteManyArgs} args - Arguments to filter Exam_timetables to delete.
     * @example
     * // Delete a few Exam_timetables
     * const { count } = await prisma.exam_timetable.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends exam_timetableDeleteManyArgs>(
      args?: SelectSubset<T, exam_timetableDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Exam_timetables.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {exam_timetableUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Exam_timetables
     * const exam_timetable = await prisma.exam_timetable.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends exam_timetableUpdateManyArgs>(
      args: SelectSubset<T, exam_timetableUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Exam_timetable.
     * @param {exam_timetableUpsertArgs} args - Arguments to update or create a Exam_timetable.
     * @example
     * // Update or create a Exam_timetable
     * const exam_timetable = await prisma.exam_timetable.upsert({
     *   create: {
     *     // ... data to create a Exam_timetable
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Exam_timetable we want to update
     *   }
     * })
    **/
    upsert<T extends exam_timetableUpsertArgs>(
      args: SelectSubset<T, exam_timetableUpsertArgs>
    ): CheckSelect<T, Prisma__exam_timetableClient<exam_timetable>, Prisma__exam_timetableClient<exam_timetableGetPayload<T>>>

    /**
     * Find one Exam_timetable that matches the filter or throw
     * `NotFoundError` if no matches were found.
     * @param {exam_timetableFindUniqueOrThrowArgs} args - Arguments to find a Exam_timetable
     * @example
     * // Get one Exam_timetable
     * const exam_timetable = await prisma.exam_timetable.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends exam_timetableFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, exam_timetableFindUniqueOrThrowArgs>
    ): CheckSelect<T, Prisma__exam_timetableClient<exam_timetable>, Prisma__exam_timetableClient<exam_timetableGetPayload<T>>>

    /**
     * Find the first Exam_timetable that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {exam_timetableFindFirstOrThrowArgs} args - Arguments to find a Exam_timetable
     * @example
     * // Get one Exam_timetable
     * const exam_timetable = await prisma.exam_timetable.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends exam_timetableFindFirstOrThrowArgs>(
      args?: SelectSubset<T, exam_timetableFindFirstOrThrowArgs>
    ): CheckSelect<T, Prisma__exam_timetableClient<exam_timetable>, Prisma__exam_timetableClient<exam_timetableGetPayload<T>>>

    /**
     * Count the number of Exam_timetables.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {exam_timetableCountArgs} args - Arguments to filter Exam_timetables to count.
     * @example
     * // Count the number of Exam_timetables
     * const count = await prisma.exam_timetable.count({
     *   where: {
     *     // ... the filter for the Exam_timetables we want to count
     *   }
     * })
    **/
    count<T extends exam_timetableCountArgs>(
      args?: Subset<T, exam_timetableCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Exam_timetableCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Exam_timetable.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Exam_timetableAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Exam_timetableAggregateArgs>(args: Subset<T, Exam_timetableAggregateArgs>): PrismaPromise<GetExam_timetableAggregateType<T>>

    /**
     * Group by Exam_timetable.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Exam_timetableGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends Exam_timetableGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: Exam_timetableGroupByArgs['orderBy'] }
        : { orderBy?: Exam_timetableGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, Exam_timetableGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetExam_timetableGroupByPayload<T> : PrismaPromise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for exam_timetable.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__exam_timetableClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * exam_timetable base type for findUnique actions
   */
  export type exam_timetableFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the exam_timetable
     * 
    **/
    select?: exam_timetableSelect | null
    /**
     * Filter, which exam_timetable to fetch.
     * 
    **/
    where: exam_timetableWhereUniqueInput
  }

  /**
   * exam_timetable: findUnique
   */
  export interface exam_timetableFindUniqueArgs extends exam_timetableFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * exam_timetable base type for findFirst actions
   */
  export type exam_timetableFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the exam_timetable
     * 
    **/
    select?: exam_timetableSelect | null
    /**
     * Filter, which exam_timetable to fetch.
     * 
    **/
    where?: exam_timetableWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of exam_timetables to fetch.
     * 
    **/
    orderBy?: Enumerable<exam_timetableOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for exam_timetables.
     * 
    **/
    cursor?: exam_timetableWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` exam_timetables from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` exam_timetables.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of exam_timetables.
     * 
    **/
    distinct?: Enumerable<Exam_timetableScalarFieldEnum>
  }

  /**
   * exam_timetable: findFirst
   */
  export interface exam_timetableFindFirstArgs extends exam_timetableFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * exam_timetable findMany
   */
  export type exam_timetableFindManyArgs = {
    /**
     * Select specific fields to fetch from the exam_timetable
     * 
    **/
    select?: exam_timetableSelect | null
    /**
     * Filter, which exam_timetables to fetch.
     * 
    **/
    where?: exam_timetableWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of exam_timetables to fetch.
     * 
    **/
    orderBy?: Enumerable<exam_timetableOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing exam_timetables.
     * 
    **/
    cursor?: exam_timetableWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` exam_timetables from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` exam_timetables.
     * 
    **/
    skip?: number
    distinct?: Enumerable<Exam_timetableScalarFieldEnum>
  }


  /**
   * exam_timetable create
   */
  export type exam_timetableCreateArgs = {
    /**
     * Select specific fields to fetch from the exam_timetable
     * 
    **/
    select?: exam_timetableSelect | null
    /**
     * The data needed to create a exam_timetable.
     * 
    **/
    data: XOR<exam_timetableCreateInput, exam_timetableUncheckedCreateInput>
  }


  /**
   * exam_timetable createMany
   */
  export type exam_timetableCreateManyArgs = {
    /**
     * The data used to create many exam_timetables.
     * 
    **/
    data: Enumerable<exam_timetableCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * exam_timetable update
   */
  export type exam_timetableUpdateArgs = {
    /**
     * Select specific fields to fetch from the exam_timetable
     * 
    **/
    select?: exam_timetableSelect | null
    /**
     * The data needed to update a exam_timetable.
     * 
    **/
    data: XOR<exam_timetableUpdateInput, exam_timetableUncheckedUpdateInput>
    /**
     * Choose, which exam_timetable to update.
     * 
    **/
    where: exam_timetableWhereUniqueInput
  }


  /**
   * exam_timetable updateMany
   */
  export type exam_timetableUpdateManyArgs = {
    /**
     * The data used to update exam_timetables.
     * 
    **/
    data: XOR<exam_timetableUpdateManyMutationInput, exam_timetableUncheckedUpdateManyInput>
    /**
     * Filter which exam_timetables to update
     * 
    **/
    where?: exam_timetableWhereInput
  }


  /**
   * exam_timetable upsert
   */
  export type exam_timetableUpsertArgs = {
    /**
     * Select specific fields to fetch from the exam_timetable
     * 
    **/
    select?: exam_timetableSelect | null
    /**
     * The filter to search for the exam_timetable to update in case it exists.
     * 
    **/
    where: exam_timetableWhereUniqueInput
    /**
     * In case the exam_timetable found by the `where` argument doesn't exist, create a new exam_timetable with this data.
     * 
    **/
    create: XOR<exam_timetableCreateInput, exam_timetableUncheckedCreateInput>
    /**
     * In case the exam_timetable was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<exam_timetableUpdateInput, exam_timetableUncheckedUpdateInput>
  }


  /**
   * exam_timetable delete
   */
  export type exam_timetableDeleteArgs = {
    /**
     * Select specific fields to fetch from the exam_timetable
     * 
    **/
    select?: exam_timetableSelect | null
    /**
     * Filter which exam_timetable to delete.
     * 
    **/
    where: exam_timetableWhereUniqueInput
  }


  /**
   * exam_timetable deleteMany
   */
  export type exam_timetableDeleteManyArgs = {
    /**
     * Filter which exam_timetables to delete
     * 
    **/
    where?: exam_timetableWhereInput
  }


  /**
   * exam_timetable: findUniqueOrThrow
   */
  export type exam_timetableFindUniqueOrThrowArgs = exam_timetableFindUniqueArgsBase
      

  /**
   * exam_timetable: findFirstOrThrow
   */
  export type exam_timetableFindFirstOrThrowArgs = exam_timetableFindFirstArgsBase
      

  /**
   * exam_timetable without action
   */
  export type exam_timetableArgs = {
    /**
     * Select specific fields to fetch from the exam_timetable
     * 
    **/
    select?: exam_timetableSelect | null
  }



  /**
   * Model head_of_exam_board
   */


  export type AggregateHead_of_exam_board = {
    _count: Head_of_exam_boardCountAggregateOutputType | null
    _avg: Head_of_exam_boardAvgAggregateOutputType | null
    _sum: Head_of_exam_boardSumAggregateOutputType | null
    _min: Head_of_exam_boardMinAggregateOutputType | null
    _max: Head_of_exam_boardMaxAggregateOutputType | null
  }

  export type Head_of_exam_boardAvgAggregateOutputType = {
    head_of_exam_ID: number | null
    user_id: number | null
    staff_id: number | null
  }

  export type Head_of_exam_boardSumAggregateOutputType = {
    head_of_exam_ID: number | null
    user_id: number | null
    staff_id: number | null
  }

  export type Head_of_exam_boardMinAggregateOutputType = {
    head_of_exam_ID: number | null
    user_id: number | null
    staff_id: number | null
  }

  export type Head_of_exam_boardMaxAggregateOutputType = {
    head_of_exam_ID: number | null
    user_id: number | null
    staff_id: number | null
  }

  export type Head_of_exam_boardCountAggregateOutputType = {
    head_of_exam_ID: number
    user_id: number
    staff_id: number
    _all: number
  }


  export type Head_of_exam_boardAvgAggregateInputType = {
    head_of_exam_ID?: true
    user_id?: true
    staff_id?: true
  }

  export type Head_of_exam_boardSumAggregateInputType = {
    head_of_exam_ID?: true
    user_id?: true
    staff_id?: true
  }

  export type Head_of_exam_boardMinAggregateInputType = {
    head_of_exam_ID?: true
    user_id?: true
    staff_id?: true
  }

  export type Head_of_exam_boardMaxAggregateInputType = {
    head_of_exam_ID?: true
    user_id?: true
    staff_id?: true
  }

  export type Head_of_exam_boardCountAggregateInputType = {
    head_of_exam_ID?: true
    user_id?: true
    staff_id?: true
    _all?: true
  }

  export type Head_of_exam_boardAggregateArgs = {
    /**
     * Filter which head_of_exam_board to aggregate.
     * 
    **/
    where?: head_of_exam_boardWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of head_of_exam_boards to fetch.
     * 
    **/
    orderBy?: Enumerable<head_of_exam_boardOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: head_of_exam_boardWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` head_of_exam_boards from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` head_of_exam_boards.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned head_of_exam_boards
    **/
    _count?: true | Head_of_exam_boardCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Head_of_exam_boardAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Head_of_exam_boardSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Head_of_exam_boardMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Head_of_exam_boardMaxAggregateInputType
  }

  export type GetHead_of_exam_boardAggregateType<T extends Head_of_exam_boardAggregateArgs> = {
        [P in keyof T & keyof AggregateHead_of_exam_board]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateHead_of_exam_board[P]>
      : GetScalarType<T[P], AggregateHead_of_exam_board[P]>
  }




  export type Head_of_exam_boardGroupByArgs = {
    where?: head_of_exam_boardWhereInput
    orderBy?: Enumerable<head_of_exam_boardOrderByWithAggregationInput>
    by: Array<Head_of_exam_boardScalarFieldEnum>
    having?: head_of_exam_boardScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Head_of_exam_boardCountAggregateInputType | true
    _avg?: Head_of_exam_boardAvgAggregateInputType
    _sum?: Head_of_exam_boardSumAggregateInputType
    _min?: Head_of_exam_boardMinAggregateInputType
    _max?: Head_of_exam_boardMaxAggregateInputType
  }


  export type Head_of_exam_boardGroupByOutputType = {
    head_of_exam_ID: number
    user_id: number
    staff_id: number
    _count: Head_of_exam_boardCountAggregateOutputType | null
    _avg: Head_of_exam_boardAvgAggregateOutputType | null
    _sum: Head_of_exam_boardSumAggregateOutputType | null
    _min: Head_of_exam_boardMinAggregateOutputType | null
    _max: Head_of_exam_boardMaxAggregateOutputType | null
  }

  type GetHead_of_exam_boardGroupByPayload<T extends Head_of_exam_boardGroupByArgs> = PrismaPromise<
    Array<
      PickArray<Head_of_exam_boardGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Head_of_exam_boardGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Head_of_exam_boardGroupByOutputType[P]>
            : GetScalarType<T[P], Head_of_exam_boardGroupByOutputType[P]>
        }
      >
    >


  export type head_of_exam_boardSelect = {
    head_of_exam_ID?: boolean
    user_id?: boolean
    staff_id?: boolean
  }

  export type head_of_exam_boardGetPayload<
    S extends boolean | null | undefined | head_of_exam_boardArgs,
    U = keyof S
      > = S extends true
        ? head_of_exam_board
    : S extends undefined
    ? never
    : S extends head_of_exam_boardArgs | head_of_exam_boardFindManyArgs
    ?'include' extends U
    ? head_of_exam_board 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
    P extends keyof head_of_exam_board ? head_of_exam_board[P] : never
  } 
    : head_of_exam_board
  : head_of_exam_board


  type head_of_exam_boardCountArgs = Merge<
    Omit<head_of_exam_boardFindManyArgs, 'select' | 'include'> & {
      select?: Head_of_exam_boardCountAggregateInputType | true
    }
  >

  export interface head_of_exam_boardDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one Head_of_exam_board that matches the filter.
     * @param {head_of_exam_boardFindUniqueArgs} args - Arguments to find a Head_of_exam_board
     * @example
     * // Get one Head_of_exam_board
     * const head_of_exam_board = await prisma.head_of_exam_board.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends head_of_exam_boardFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, head_of_exam_boardFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'head_of_exam_board'> extends True ? CheckSelect<T, Prisma__head_of_exam_boardClient<head_of_exam_board>, Prisma__head_of_exam_boardClient<head_of_exam_boardGetPayload<T>>> : CheckSelect<T, Prisma__head_of_exam_boardClient<head_of_exam_board | null >, Prisma__head_of_exam_boardClient<head_of_exam_boardGetPayload<T> | null >>

    /**
     * Find the first Head_of_exam_board that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {head_of_exam_boardFindFirstArgs} args - Arguments to find a Head_of_exam_board
     * @example
     * // Get one Head_of_exam_board
     * const head_of_exam_board = await prisma.head_of_exam_board.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends head_of_exam_boardFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, head_of_exam_boardFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'head_of_exam_board'> extends True ? CheckSelect<T, Prisma__head_of_exam_boardClient<head_of_exam_board>, Prisma__head_of_exam_boardClient<head_of_exam_boardGetPayload<T>>> : CheckSelect<T, Prisma__head_of_exam_boardClient<head_of_exam_board | null >, Prisma__head_of_exam_boardClient<head_of_exam_boardGetPayload<T> | null >>

    /**
     * Find zero or more Head_of_exam_boards that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {head_of_exam_boardFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Head_of_exam_boards
     * const head_of_exam_boards = await prisma.head_of_exam_board.findMany()
     * 
     * // Get first 10 Head_of_exam_boards
     * const head_of_exam_boards = await prisma.head_of_exam_board.findMany({ take: 10 })
     * 
     * // Only select the `head_of_exam_ID`
     * const head_of_exam_boardWithHead_of_exam_IDOnly = await prisma.head_of_exam_board.findMany({ select: { head_of_exam_ID: true } })
     * 
    **/
    findMany<T extends head_of_exam_boardFindManyArgs>(
      args?: SelectSubset<T, head_of_exam_boardFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<head_of_exam_board>>, PrismaPromise<Array<head_of_exam_boardGetPayload<T>>>>

    /**
     * Create a Head_of_exam_board.
     * @param {head_of_exam_boardCreateArgs} args - Arguments to create a Head_of_exam_board.
     * @example
     * // Create one Head_of_exam_board
     * const Head_of_exam_board = await prisma.head_of_exam_board.create({
     *   data: {
     *     // ... data to create a Head_of_exam_board
     *   }
     * })
     * 
    **/
    create<T extends head_of_exam_boardCreateArgs>(
      args: SelectSubset<T, head_of_exam_boardCreateArgs>
    ): CheckSelect<T, Prisma__head_of_exam_boardClient<head_of_exam_board>, Prisma__head_of_exam_boardClient<head_of_exam_boardGetPayload<T>>>

    /**
     * Create many Head_of_exam_boards.
     *     @param {head_of_exam_boardCreateManyArgs} args - Arguments to create many Head_of_exam_boards.
     *     @example
     *     // Create many Head_of_exam_boards
     *     const head_of_exam_board = await prisma.head_of_exam_board.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends head_of_exam_boardCreateManyArgs>(
      args?: SelectSubset<T, head_of_exam_boardCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Head_of_exam_board.
     * @param {head_of_exam_boardDeleteArgs} args - Arguments to delete one Head_of_exam_board.
     * @example
     * // Delete one Head_of_exam_board
     * const Head_of_exam_board = await prisma.head_of_exam_board.delete({
     *   where: {
     *     // ... filter to delete one Head_of_exam_board
     *   }
     * })
     * 
    **/
    delete<T extends head_of_exam_boardDeleteArgs>(
      args: SelectSubset<T, head_of_exam_boardDeleteArgs>
    ): CheckSelect<T, Prisma__head_of_exam_boardClient<head_of_exam_board>, Prisma__head_of_exam_boardClient<head_of_exam_boardGetPayload<T>>>

    /**
     * Update one Head_of_exam_board.
     * @param {head_of_exam_boardUpdateArgs} args - Arguments to update one Head_of_exam_board.
     * @example
     * // Update one Head_of_exam_board
     * const head_of_exam_board = await prisma.head_of_exam_board.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends head_of_exam_boardUpdateArgs>(
      args: SelectSubset<T, head_of_exam_boardUpdateArgs>
    ): CheckSelect<T, Prisma__head_of_exam_boardClient<head_of_exam_board>, Prisma__head_of_exam_boardClient<head_of_exam_boardGetPayload<T>>>

    /**
     * Delete zero or more Head_of_exam_boards.
     * @param {head_of_exam_boardDeleteManyArgs} args - Arguments to filter Head_of_exam_boards to delete.
     * @example
     * // Delete a few Head_of_exam_boards
     * const { count } = await prisma.head_of_exam_board.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends head_of_exam_boardDeleteManyArgs>(
      args?: SelectSubset<T, head_of_exam_boardDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Head_of_exam_boards.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {head_of_exam_boardUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Head_of_exam_boards
     * const head_of_exam_board = await prisma.head_of_exam_board.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends head_of_exam_boardUpdateManyArgs>(
      args: SelectSubset<T, head_of_exam_boardUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Head_of_exam_board.
     * @param {head_of_exam_boardUpsertArgs} args - Arguments to update or create a Head_of_exam_board.
     * @example
     * // Update or create a Head_of_exam_board
     * const head_of_exam_board = await prisma.head_of_exam_board.upsert({
     *   create: {
     *     // ... data to create a Head_of_exam_board
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Head_of_exam_board we want to update
     *   }
     * })
    **/
    upsert<T extends head_of_exam_boardUpsertArgs>(
      args: SelectSubset<T, head_of_exam_boardUpsertArgs>
    ): CheckSelect<T, Prisma__head_of_exam_boardClient<head_of_exam_board>, Prisma__head_of_exam_boardClient<head_of_exam_boardGetPayload<T>>>

    /**
     * Find one Head_of_exam_board that matches the filter or throw
     * `NotFoundError` if no matches were found.
     * @param {head_of_exam_boardFindUniqueOrThrowArgs} args - Arguments to find a Head_of_exam_board
     * @example
     * // Get one Head_of_exam_board
     * const head_of_exam_board = await prisma.head_of_exam_board.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends head_of_exam_boardFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, head_of_exam_boardFindUniqueOrThrowArgs>
    ): CheckSelect<T, Prisma__head_of_exam_boardClient<head_of_exam_board>, Prisma__head_of_exam_boardClient<head_of_exam_boardGetPayload<T>>>

    /**
     * Find the first Head_of_exam_board that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {head_of_exam_boardFindFirstOrThrowArgs} args - Arguments to find a Head_of_exam_board
     * @example
     * // Get one Head_of_exam_board
     * const head_of_exam_board = await prisma.head_of_exam_board.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends head_of_exam_boardFindFirstOrThrowArgs>(
      args?: SelectSubset<T, head_of_exam_boardFindFirstOrThrowArgs>
    ): CheckSelect<T, Prisma__head_of_exam_boardClient<head_of_exam_board>, Prisma__head_of_exam_boardClient<head_of_exam_boardGetPayload<T>>>

    /**
     * Count the number of Head_of_exam_boards.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {head_of_exam_boardCountArgs} args - Arguments to filter Head_of_exam_boards to count.
     * @example
     * // Count the number of Head_of_exam_boards
     * const count = await prisma.head_of_exam_board.count({
     *   where: {
     *     // ... the filter for the Head_of_exam_boards we want to count
     *   }
     * })
    **/
    count<T extends head_of_exam_boardCountArgs>(
      args?: Subset<T, head_of_exam_boardCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Head_of_exam_boardCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Head_of_exam_board.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Head_of_exam_boardAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Head_of_exam_boardAggregateArgs>(args: Subset<T, Head_of_exam_boardAggregateArgs>): PrismaPromise<GetHead_of_exam_boardAggregateType<T>>

    /**
     * Group by Head_of_exam_board.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Head_of_exam_boardGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends Head_of_exam_boardGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: Head_of_exam_boardGroupByArgs['orderBy'] }
        : { orderBy?: Head_of_exam_boardGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, Head_of_exam_boardGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetHead_of_exam_boardGroupByPayload<T> : PrismaPromise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for head_of_exam_board.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__head_of_exam_boardClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * head_of_exam_board base type for findUnique actions
   */
  export type head_of_exam_boardFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the head_of_exam_board
     * 
    **/
    select?: head_of_exam_boardSelect | null
    /**
     * Filter, which head_of_exam_board to fetch.
     * 
    **/
    where: head_of_exam_boardWhereUniqueInput
  }

  /**
   * head_of_exam_board: findUnique
   */
  export interface head_of_exam_boardFindUniqueArgs extends head_of_exam_boardFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * head_of_exam_board base type for findFirst actions
   */
  export type head_of_exam_boardFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the head_of_exam_board
     * 
    **/
    select?: head_of_exam_boardSelect | null
    /**
     * Filter, which head_of_exam_board to fetch.
     * 
    **/
    where?: head_of_exam_boardWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of head_of_exam_boards to fetch.
     * 
    **/
    orderBy?: Enumerable<head_of_exam_boardOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for head_of_exam_boards.
     * 
    **/
    cursor?: head_of_exam_boardWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` head_of_exam_boards from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` head_of_exam_boards.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of head_of_exam_boards.
     * 
    **/
    distinct?: Enumerable<Head_of_exam_boardScalarFieldEnum>
  }

  /**
   * head_of_exam_board: findFirst
   */
  export interface head_of_exam_boardFindFirstArgs extends head_of_exam_boardFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * head_of_exam_board findMany
   */
  export type head_of_exam_boardFindManyArgs = {
    /**
     * Select specific fields to fetch from the head_of_exam_board
     * 
    **/
    select?: head_of_exam_boardSelect | null
    /**
     * Filter, which head_of_exam_boards to fetch.
     * 
    **/
    where?: head_of_exam_boardWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of head_of_exam_boards to fetch.
     * 
    **/
    orderBy?: Enumerable<head_of_exam_boardOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing head_of_exam_boards.
     * 
    **/
    cursor?: head_of_exam_boardWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` head_of_exam_boards from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` head_of_exam_boards.
     * 
    **/
    skip?: number
    distinct?: Enumerable<Head_of_exam_boardScalarFieldEnum>
  }


  /**
   * head_of_exam_board create
   */
  export type head_of_exam_boardCreateArgs = {
    /**
     * Select specific fields to fetch from the head_of_exam_board
     * 
    **/
    select?: head_of_exam_boardSelect | null
    /**
     * The data needed to create a head_of_exam_board.
     * 
    **/
    data: XOR<head_of_exam_boardCreateInput, head_of_exam_boardUncheckedCreateInput>
  }


  /**
   * head_of_exam_board createMany
   */
  export type head_of_exam_boardCreateManyArgs = {
    /**
     * The data used to create many head_of_exam_boards.
     * 
    **/
    data: Enumerable<head_of_exam_boardCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * head_of_exam_board update
   */
  export type head_of_exam_boardUpdateArgs = {
    /**
     * Select specific fields to fetch from the head_of_exam_board
     * 
    **/
    select?: head_of_exam_boardSelect | null
    /**
     * The data needed to update a head_of_exam_board.
     * 
    **/
    data: XOR<head_of_exam_boardUpdateInput, head_of_exam_boardUncheckedUpdateInput>
    /**
     * Choose, which head_of_exam_board to update.
     * 
    **/
    where: head_of_exam_boardWhereUniqueInput
  }


  /**
   * head_of_exam_board updateMany
   */
  export type head_of_exam_boardUpdateManyArgs = {
    /**
     * The data used to update head_of_exam_boards.
     * 
    **/
    data: XOR<head_of_exam_boardUpdateManyMutationInput, head_of_exam_boardUncheckedUpdateManyInput>
    /**
     * Filter which head_of_exam_boards to update
     * 
    **/
    where?: head_of_exam_boardWhereInput
  }


  /**
   * head_of_exam_board upsert
   */
  export type head_of_exam_boardUpsertArgs = {
    /**
     * Select specific fields to fetch from the head_of_exam_board
     * 
    **/
    select?: head_of_exam_boardSelect | null
    /**
     * The filter to search for the head_of_exam_board to update in case it exists.
     * 
    **/
    where: head_of_exam_boardWhereUniqueInput
    /**
     * In case the head_of_exam_board found by the `where` argument doesn't exist, create a new head_of_exam_board with this data.
     * 
    **/
    create: XOR<head_of_exam_boardCreateInput, head_of_exam_boardUncheckedCreateInput>
    /**
     * In case the head_of_exam_board was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<head_of_exam_boardUpdateInput, head_of_exam_boardUncheckedUpdateInput>
  }


  /**
   * head_of_exam_board delete
   */
  export type head_of_exam_boardDeleteArgs = {
    /**
     * Select specific fields to fetch from the head_of_exam_board
     * 
    **/
    select?: head_of_exam_boardSelect | null
    /**
     * Filter which head_of_exam_board to delete.
     * 
    **/
    where: head_of_exam_boardWhereUniqueInput
  }


  /**
   * head_of_exam_board deleteMany
   */
  export type head_of_exam_boardDeleteManyArgs = {
    /**
     * Filter which head_of_exam_boards to delete
     * 
    **/
    where?: head_of_exam_boardWhereInput
  }


  /**
   * head_of_exam_board: findUniqueOrThrow
   */
  export type head_of_exam_boardFindUniqueOrThrowArgs = head_of_exam_boardFindUniqueArgsBase
      

  /**
   * head_of_exam_board: findFirstOrThrow
   */
  export type head_of_exam_boardFindFirstOrThrowArgs = head_of_exam_boardFindFirstArgsBase
      

  /**
   * head_of_exam_board without action
   */
  export type head_of_exam_boardArgs = {
    /**
     * Select specific fields to fetch from the head_of_exam_board
     * 
    **/
    select?: head_of_exam_boardSelect | null
  }



  /**
   * Model lecture_question
   */


  export type AggregateLecture_question = {
    _count: Lecture_questionCountAggregateOutputType | null
    _avg: Lecture_questionAvgAggregateOutputType | null
    _sum: Lecture_questionSumAggregateOutputType | null
    _min: Lecture_questionMinAggregateOutputType | null
    _max: Lecture_questionMaxAggregateOutputType | null
  }

  export type Lecture_questionAvgAggregateOutputType = {
    exam_paper_id: number | null
    lecture_id: number | null
  }

  export type Lecture_questionSumAggregateOutputType = {
    exam_paper_id: number | null
    lecture_id: number | null
  }

  export type Lecture_questionMinAggregateOutputType = {
    exam_paper_id: number | null
    lecture_id: number | null
  }

  export type Lecture_questionMaxAggregateOutputType = {
    exam_paper_id: number | null
    lecture_id: number | null
  }

  export type Lecture_questionCountAggregateOutputType = {
    exam_paper_id: number
    lecture_id: number
    _all: number
  }


  export type Lecture_questionAvgAggregateInputType = {
    exam_paper_id?: true
    lecture_id?: true
  }

  export type Lecture_questionSumAggregateInputType = {
    exam_paper_id?: true
    lecture_id?: true
  }

  export type Lecture_questionMinAggregateInputType = {
    exam_paper_id?: true
    lecture_id?: true
  }

  export type Lecture_questionMaxAggregateInputType = {
    exam_paper_id?: true
    lecture_id?: true
  }

  export type Lecture_questionCountAggregateInputType = {
    exam_paper_id?: true
    lecture_id?: true
    _all?: true
  }

  export type Lecture_questionAggregateArgs = {
    /**
     * Filter which lecture_question to aggregate.
     * 
    **/
    where?: lecture_questionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of lecture_questions to fetch.
     * 
    **/
    orderBy?: Enumerable<lecture_questionOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: lecture_questionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` lecture_questions from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` lecture_questions.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned lecture_questions
    **/
    _count?: true | Lecture_questionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Lecture_questionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Lecture_questionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Lecture_questionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Lecture_questionMaxAggregateInputType
  }

  export type GetLecture_questionAggregateType<T extends Lecture_questionAggregateArgs> = {
        [P in keyof T & keyof AggregateLecture_question]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLecture_question[P]>
      : GetScalarType<T[P], AggregateLecture_question[P]>
  }




  export type Lecture_questionGroupByArgs = {
    where?: lecture_questionWhereInput
    orderBy?: Enumerable<lecture_questionOrderByWithAggregationInput>
    by: Array<Lecture_questionScalarFieldEnum>
    having?: lecture_questionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Lecture_questionCountAggregateInputType | true
    _avg?: Lecture_questionAvgAggregateInputType
    _sum?: Lecture_questionSumAggregateInputType
    _min?: Lecture_questionMinAggregateInputType
    _max?: Lecture_questionMaxAggregateInputType
  }


  export type Lecture_questionGroupByOutputType = {
    exam_paper_id: number
    lecture_id: number
    _count: Lecture_questionCountAggregateOutputType | null
    _avg: Lecture_questionAvgAggregateOutputType | null
    _sum: Lecture_questionSumAggregateOutputType | null
    _min: Lecture_questionMinAggregateOutputType | null
    _max: Lecture_questionMaxAggregateOutputType | null
  }

  type GetLecture_questionGroupByPayload<T extends Lecture_questionGroupByArgs> = PrismaPromise<
    Array<
      PickArray<Lecture_questionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Lecture_questionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Lecture_questionGroupByOutputType[P]>
            : GetScalarType<T[P], Lecture_questionGroupByOutputType[P]>
        }
      >
    >


  export type lecture_questionSelect = {
    exam_paper_id?: boolean
    lecture_id?: boolean
  }

  export type lecture_questionGetPayload<
    S extends boolean | null | undefined | lecture_questionArgs,
    U = keyof S
      > = S extends true
        ? lecture_question
    : S extends undefined
    ? never
    : S extends lecture_questionArgs | lecture_questionFindManyArgs
    ?'include' extends U
    ? lecture_question 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
    P extends keyof lecture_question ? lecture_question[P] : never
  } 
    : lecture_question
  : lecture_question


  type lecture_questionCountArgs = Merge<
    Omit<lecture_questionFindManyArgs, 'select' | 'include'> & {
      select?: Lecture_questionCountAggregateInputType | true
    }
  >

  export interface lecture_questionDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one Lecture_question that matches the filter.
     * @param {lecture_questionFindUniqueArgs} args - Arguments to find a Lecture_question
     * @example
     * // Get one Lecture_question
     * const lecture_question = await prisma.lecture_question.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends lecture_questionFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, lecture_questionFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'lecture_question'> extends True ? CheckSelect<T, Prisma__lecture_questionClient<lecture_question>, Prisma__lecture_questionClient<lecture_questionGetPayload<T>>> : CheckSelect<T, Prisma__lecture_questionClient<lecture_question | null >, Prisma__lecture_questionClient<lecture_questionGetPayload<T> | null >>

    /**
     * Find the first Lecture_question that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {lecture_questionFindFirstArgs} args - Arguments to find a Lecture_question
     * @example
     * // Get one Lecture_question
     * const lecture_question = await prisma.lecture_question.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends lecture_questionFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, lecture_questionFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'lecture_question'> extends True ? CheckSelect<T, Prisma__lecture_questionClient<lecture_question>, Prisma__lecture_questionClient<lecture_questionGetPayload<T>>> : CheckSelect<T, Prisma__lecture_questionClient<lecture_question | null >, Prisma__lecture_questionClient<lecture_questionGetPayload<T> | null >>

    /**
     * Find zero or more Lecture_questions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {lecture_questionFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Lecture_questions
     * const lecture_questions = await prisma.lecture_question.findMany()
     * 
     * // Get first 10 Lecture_questions
     * const lecture_questions = await prisma.lecture_question.findMany({ take: 10 })
     * 
     * // Only select the `exam_paper_id`
     * const lecture_questionWithExam_paper_idOnly = await prisma.lecture_question.findMany({ select: { exam_paper_id: true } })
     * 
    **/
    findMany<T extends lecture_questionFindManyArgs>(
      args?: SelectSubset<T, lecture_questionFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<lecture_question>>, PrismaPromise<Array<lecture_questionGetPayload<T>>>>

    /**
     * Create a Lecture_question.
     * @param {lecture_questionCreateArgs} args - Arguments to create a Lecture_question.
     * @example
     * // Create one Lecture_question
     * const Lecture_question = await prisma.lecture_question.create({
     *   data: {
     *     // ... data to create a Lecture_question
     *   }
     * })
     * 
    **/
    create<T extends lecture_questionCreateArgs>(
      args: SelectSubset<T, lecture_questionCreateArgs>
    ): CheckSelect<T, Prisma__lecture_questionClient<lecture_question>, Prisma__lecture_questionClient<lecture_questionGetPayload<T>>>

    /**
     * Create many Lecture_questions.
     *     @param {lecture_questionCreateManyArgs} args - Arguments to create many Lecture_questions.
     *     @example
     *     // Create many Lecture_questions
     *     const lecture_question = await prisma.lecture_question.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends lecture_questionCreateManyArgs>(
      args?: SelectSubset<T, lecture_questionCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Lecture_question.
     * @param {lecture_questionDeleteArgs} args - Arguments to delete one Lecture_question.
     * @example
     * // Delete one Lecture_question
     * const Lecture_question = await prisma.lecture_question.delete({
     *   where: {
     *     // ... filter to delete one Lecture_question
     *   }
     * })
     * 
    **/
    delete<T extends lecture_questionDeleteArgs>(
      args: SelectSubset<T, lecture_questionDeleteArgs>
    ): CheckSelect<T, Prisma__lecture_questionClient<lecture_question>, Prisma__lecture_questionClient<lecture_questionGetPayload<T>>>

    /**
     * Update one Lecture_question.
     * @param {lecture_questionUpdateArgs} args - Arguments to update one Lecture_question.
     * @example
     * // Update one Lecture_question
     * const lecture_question = await prisma.lecture_question.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends lecture_questionUpdateArgs>(
      args: SelectSubset<T, lecture_questionUpdateArgs>
    ): CheckSelect<T, Prisma__lecture_questionClient<lecture_question>, Prisma__lecture_questionClient<lecture_questionGetPayload<T>>>

    /**
     * Delete zero or more Lecture_questions.
     * @param {lecture_questionDeleteManyArgs} args - Arguments to filter Lecture_questions to delete.
     * @example
     * // Delete a few Lecture_questions
     * const { count } = await prisma.lecture_question.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends lecture_questionDeleteManyArgs>(
      args?: SelectSubset<T, lecture_questionDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Lecture_questions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {lecture_questionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Lecture_questions
     * const lecture_question = await prisma.lecture_question.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends lecture_questionUpdateManyArgs>(
      args: SelectSubset<T, lecture_questionUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Lecture_question.
     * @param {lecture_questionUpsertArgs} args - Arguments to update or create a Lecture_question.
     * @example
     * // Update or create a Lecture_question
     * const lecture_question = await prisma.lecture_question.upsert({
     *   create: {
     *     // ... data to create a Lecture_question
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Lecture_question we want to update
     *   }
     * })
    **/
    upsert<T extends lecture_questionUpsertArgs>(
      args: SelectSubset<T, lecture_questionUpsertArgs>
    ): CheckSelect<T, Prisma__lecture_questionClient<lecture_question>, Prisma__lecture_questionClient<lecture_questionGetPayload<T>>>

    /**
     * Find one Lecture_question that matches the filter or throw
     * `NotFoundError` if no matches were found.
     * @param {lecture_questionFindUniqueOrThrowArgs} args - Arguments to find a Lecture_question
     * @example
     * // Get one Lecture_question
     * const lecture_question = await prisma.lecture_question.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends lecture_questionFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, lecture_questionFindUniqueOrThrowArgs>
    ): CheckSelect<T, Prisma__lecture_questionClient<lecture_question>, Prisma__lecture_questionClient<lecture_questionGetPayload<T>>>

    /**
     * Find the first Lecture_question that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {lecture_questionFindFirstOrThrowArgs} args - Arguments to find a Lecture_question
     * @example
     * // Get one Lecture_question
     * const lecture_question = await prisma.lecture_question.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends lecture_questionFindFirstOrThrowArgs>(
      args?: SelectSubset<T, lecture_questionFindFirstOrThrowArgs>
    ): CheckSelect<T, Prisma__lecture_questionClient<lecture_question>, Prisma__lecture_questionClient<lecture_questionGetPayload<T>>>

    /**
     * Count the number of Lecture_questions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {lecture_questionCountArgs} args - Arguments to filter Lecture_questions to count.
     * @example
     * // Count the number of Lecture_questions
     * const count = await prisma.lecture_question.count({
     *   where: {
     *     // ... the filter for the Lecture_questions we want to count
     *   }
     * })
    **/
    count<T extends lecture_questionCountArgs>(
      args?: Subset<T, lecture_questionCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Lecture_questionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Lecture_question.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Lecture_questionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Lecture_questionAggregateArgs>(args: Subset<T, Lecture_questionAggregateArgs>): PrismaPromise<GetLecture_questionAggregateType<T>>

    /**
     * Group by Lecture_question.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Lecture_questionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends Lecture_questionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: Lecture_questionGroupByArgs['orderBy'] }
        : { orderBy?: Lecture_questionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, Lecture_questionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetLecture_questionGroupByPayload<T> : PrismaPromise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for lecture_question.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__lecture_questionClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * lecture_question base type for findUnique actions
   */
  export type lecture_questionFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the lecture_question
     * 
    **/
    select?: lecture_questionSelect | null
    /**
     * Filter, which lecture_question to fetch.
     * 
    **/
    where: lecture_questionWhereUniqueInput
  }

  /**
   * lecture_question: findUnique
   */
  export interface lecture_questionFindUniqueArgs extends lecture_questionFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * lecture_question base type for findFirst actions
   */
  export type lecture_questionFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the lecture_question
     * 
    **/
    select?: lecture_questionSelect | null
    /**
     * Filter, which lecture_question to fetch.
     * 
    **/
    where?: lecture_questionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of lecture_questions to fetch.
     * 
    **/
    orderBy?: Enumerable<lecture_questionOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for lecture_questions.
     * 
    **/
    cursor?: lecture_questionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` lecture_questions from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` lecture_questions.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of lecture_questions.
     * 
    **/
    distinct?: Enumerable<Lecture_questionScalarFieldEnum>
  }

  /**
   * lecture_question: findFirst
   */
  export interface lecture_questionFindFirstArgs extends lecture_questionFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * lecture_question findMany
   */
  export type lecture_questionFindManyArgs = {
    /**
     * Select specific fields to fetch from the lecture_question
     * 
    **/
    select?: lecture_questionSelect | null
    /**
     * Filter, which lecture_questions to fetch.
     * 
    **/
    where?: lecture_questionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of lecture_questions to fetch.
     * 
    **/
    orderBy?: Enumerable<lecture_questionOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing lecture_questions.
     * 
    **/
    cursor?: lecture_questionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` lecture_questions from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` lecture_questions.
     * 
    **/
    skip?: number
    distinct?: Enumerable<Lecture_questionScalarFieldEnum>
  }


  /**
   * lecture_question create
   */
  export type lecture_questionCreateArgs = {
    /**
     * Select specific fields to fetch from the lecture_question
     * 
    **/
    select?: lecture_questionSelect | null
    /**
     * The data needed to create a lecture_question.
     * 
    **/
    data: XOR<lecture_questionCreateInput, lecture_questionUncheckedCreateInput>
  }


  /**
   * lecture_question createMany
   */
  export type lecture_questionCreateManyArgs = {
    /**
     * The data used to create many lecture_questions.
     * 
    **/
    data: Enumerable<lecture_questionCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * lecture_question update
   */
  export type lecture_questionUpdateArgs = {
    /**
     * Select specific fields to fetch from the lecture_question
     * 
    **/
    select?: lecture_questionSelect | null
    /**
     * The data needed to update a lecture_question.
     * 
    **/
    data: XOR<lecture_questionUpdateInput, lecture_questionUncheckedUpdateInput>
    /**
     * Choose, which lecture_question to update.
     * 
    **/
    where: lecture_questionWhereUniqueInput
  }


  /**
   * lecture_question updateMany
   */
  export type lecture_questionUpdateManyArgs = {
    /**
     * The data used to update lecture_questions.
     * 
    **/
    data: XOR<lecture_questionUpdateManyMutationInput, lecture_questionUncheckedUpdateManyInput>
    /**
     * Filter which lecture_questions to update
     * 
    **/
    where?: lecture_questionWhereInput
  }


  /**
   * lecture_question upsert
   */
  export type lecture_questionUpsertArgs = {
    /**
     * Select specific fields to fetch from the lecture_question
     * 
    **/
    select?: lecture_questionSelect | null
    /**
     * The filter to search for the lecture_question to update in case it exists.
     * 
    **/
    where: lecture_questionWhereUniqueInput
    /**
     * In case the lecture_question found by the `where` argument doesn't exist, create a new lecture_question with this data.
     * 
    **/
    create: XOR<lecture_questionCreateInput, lecture_questionUncheckedCreateInput>
    /**
     * In case the lecture_question was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<lecture_questionUpdateInput, lecture_questionUncheckedUpdateInput>
  }


  /**
   * lecture_question delete
   */
  export type lecture_questionDeleteArgs = {
    /**
     * Select specific fields to fetch from the lecture_question
     * 
    **/
    select?: lecture_questionSelect | null
    /**
     * Filter which lecture_question to delete.
     * 
    **/
    where: lecture_questionWhereUniqueInput
  }


  /**
   * lecture_question deleteMany
   */
  export type lecture_questionDeleteManyArgs = {
    /**
     * Filter which lecture_questions to delete
     * 
    **/
    where?: lecture_questionWhereInput
  }


  /**
   * lecture_question: findUniqueOrThrow
   */
  export type lecture_questionFindUniqueOrThrowArgs = lecture_questionFindUniqueArgsBase
      

  /**
   * lecture_question: findFirstOrThrow
   */
  export type lecture_questionFindFirstOrThrowArgs = lecture_questionFindFirstArgsBase
      

  /**
   * lecture_question without action
   */
  export type lecture_questionArgs = {
    /**
     * Select specific fields to fetch from the lecture_question
     * 
    **/
    select?: lecture_questionSelect | null
  }



  /**
   * Model lecturer
   */


  export type AggregateLecturer = {
    _count: LecturerCountAggregateOutputType | null
    _avg: LecturerAvgAggregateOutputType | null
    _sum: LecturerSumAggregateOutputType | null
    _min: LecturerMinAggregateOutputType | null
    _max: LecturerMaxAggregateOutputType | null
  }

  export type LecturerAvgAggregateOutputType = {
    lecturer_id: number | null
    user_id: number | null
  }

  export type LecturerSumAggregateOutputType = {
    lecturer_id: number | null
    user_id: number | null
  }

  export type LecturerMinAggregateOutputType = {
    lecturer_id: number | null
    degree: string | null
    user_id: number | null
  }

  export type LecturerMaxAggregateOutputType = {
    lecturer_id: number | null
    degree: string | null
    user_id: number | null
  }

  export type LecturerCountAggregateOutputType = {
    lecturer_id: number
    degree: number
    user_id: number
    _all: number
  }


  export type LecturerAvgAggregateInputType = {
    lecturer_id?: true
    user_id?: true
  }

  export type LecturerSumAggregateInputType = {
    lecturer_id?: true
    user_id?: true
  }

  export type LecturerMinAggregateInputType = {
    lecturer_id?: true
    degree?: true
    user_id?: true
  }

  export type LecturerMaxAggregateInputType = {
    lecturer_id?: true
    degree?: true
    user_id?: true
  }

  export type LecturerCountAggregateInputType = {
    lecturer_id?: true
    degree?: true
    user_id?: true
    _all?: true
  }

  export type LecturerAggregateArgs = {
    /**
     * Filter which lecturer to aggregate.
     * 
    **/
    where?: lecturerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of lecturers to fetch.
     * 
    **/
    orderBy?: Enumerable<lecturerOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: lecturerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` lecturers from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` lecturers.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned lecturers
    **/
    _count?: true | LecturerCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: LecturerAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: LecturerSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: LecturerMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: LecturerMaxAggregateInputType
  }

  export type GetLecturerAggregateType<T extends LecturerAggregateArgs> = {
        [P in keyof T & keyof AggregateLecturer]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLecturer[P]>
      : GetScalarType<T[P], AggregateLecturer[P]>
  }




  export type LecturerGroupByArgs = {
    where?: lecturerWhereInput
    orderBy?: Enumerable<lecturerOrderByWithAggregationInput>
    by: Array<LecturerScalarFieldEnum>
    having?: lecturerScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: LecturerCountAggregateInputType | true
    _avg?: LecturerAvgAggregateInputType
    _sum?: LecturerSumAggregateInputType
    _min?: LecturerMinAggregateInputType
    _max?: LecturerMaxAggregateInputType
  }


  export type LecturerGroupByOutputType = {
    lecturer_id: number
    degree: string
    user_id: number
    _count: LecturerCountAggregateOutputType | null
    _avg: LecturerAvgAggregateOutputType | null
    _sum: LecturerSumAggregateOutputType | null
    _min: LecturerMinAggregateOutputType | null
    _max: LecturerMaxAggregateOutputType | null
  }

  type GetLecturerGroupByPayload<T extends LecturerGroupByArgs> = PrismaPromise<
    Array<
      PickArray<LecturerGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof LecturerGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], LecturerGroupByOutputType[P]>
            : GetScalarType<T[P], LecturerGroupByOutputType[P]>
        }
      >
    >


  export type lecturerSelect = {
    lecturer_id?: boolean
    degree?: boolean
    user_id?: boolean
  }

  export type lecturerGetPayload<
    S extends boolean | null | undefined | lecturerArgs,
    U = keyof S
      > = S extends true
        ? lecturer
    : S extends undefined
    ? never
    : S extends lecturerArgs | lecturerFindManyArgs
    ?'include' extends U
    ? lecturer 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
    P extends keyof lecturer ? lecturer[P] : never
  } 
    : lecturer
  : lecturer


  type lecturerCountArgs = Merge<
    Omit<lecturerFindManyArgs, 'select' | 'include'> & {
      select?: LecturerCountAggregateInputType | true
    }
  >

  export interface lecturerDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one Lecturer that matches the filter.
     * @param {lecturerFindUniqueArgs} args - Arguments to find a Lecturer
     * @example
     * // Get one Lecturer
     * const lecturer = await prisma.lecturer.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends lecturerFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, lecturerFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'lecturer'> extends True ? CheckSelect<T, Prisma__lecturerClient<lecturer>, Prisma__lecturerClient<lecturerGetPayload<T>>> : CheckSelect<T, Prisma__lecturerClient<lecturer | null >, Prisma__lecturerClient<lecturerGetPayload<T> | null >>

    /**
     * Find the first Lecturer that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {lecturerFindFirstArgs} args - Arguments to find a Lecturer
     * @example
     * // Get one Lecturer
     * const lecturer = await prisma.lecturer.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends lecturerFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, lecturerFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'lecturer'> extends True ? CheckSelect<T, Prisma__lecturerClient<lecturer>, Prisma__lecturerClient<lecturerGetPayload<T>>> : CheckSelect<T, Prisma__lecturerClient<lecturer | null >, Prisma__lecturerClient<lecturerGetPayload<T> | null >>

    /**
     * Find zero or more Lecturers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {lecturerFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Lecturers
     * const lecturers = await prisma.lecturer.findMany()
     * 
     * // Get first 10 Lecturers
     * const lecturers = await prisma.lecturer.findMany({ take: 10 })
     * 
     * // Only select the `lecturer_id`
     * const lecturerWithLecturer_idOnly = await prisma.lecturer.findMany({ select: { lecturer_id: true } })
     * 
    **/
    findMany<T extends lecturerFindManyArgs>(
      args?: SelectSubset<T, lecturerFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<lecturer>>, PrismaPromise<Array<lecturerGetPayload<T>>>>

    /**
     * Create a Lecturer.
     * @param {lecturerCreateArgs} args - Arguments to create a Lecturer.
     * @example
     * // Create one Lecturer
     * const Lecturer = await prisma.lecturer.create({
     *   data: {
     *     // ... data to create a Lecturer
     *   }
     * })
     * 
    **/
    create<T extends lecturerCreateArgs>(
      args: SelectSubset<T, lecturerCreateArgs>
    ): CheckSelect<T, Prisma__lecturerClient<lecturer>, Prisma__lecturerClient<lecturerGetPayload<T>>>

    /**
     * Create many Lecturers.
     *     @param {lecturerCreateManyArgs} args - Arguments to create many Lecturers.
     *     @example
     *     // Create many Lecturers
     *     const lecturer = await prisma.lecturer.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends lecturerCreateManyArgs>(
      args?: SelectSubset<T, lecturerCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Lecturer.
     * @param {lecturerDeleteArgs} args - Arguments to delete one Lecturer.
     * @example
     * // Delete one Lecturer
     * const Lecturer = await prisma.lecturer.delete({
     *   where: {
     *     // ... filter to delete one Lecturer
     *   }
     * })
     * 
    **/
    delete<T extends lecturerDeleteArgs>(
      args: SelectSubset<T, lecturerDeleteArgs>
    ): CheckSelect<T, Prisma__lecturerClient<lecturer>, Prisma__lecturerClient<lecturerGetPayload<T>>>

    /**
     * Update one Lecturer.
     * @param {lecturerUpdateArgs} args - Arguments to update one Lecturer.
     * @example
     * // Update one Lecturer
     * const lecturer = await prisma.lecturer.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends lecturerUpdateArgs>(
      args: SelectSubset<T, lecturerUpdateArgs>
    ): CheckSelect<T, Prisma__lecturerClient<lecturer>, Prisma__lecturerClient<lecturerGetPayload<T>>>

    /**
     * Delete zero or more Lecturers.
     * @param {lecturerDeleteManyArgs} args - Arguments to filter Lecturers to delete.
     * @example
     * // Delete a few Lecturers
     * const { count } = await prisma.lecturer.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends lecturerDeleteManyArgs>(
      args?: SelectSubset<T, lecturerDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Lecturers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {lecturerUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Lecturers
     * const lecturer = await prisma.lecturer.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends lecturerUpdateManyArgs>(
      args: SelectSubset<T, lecturerUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Lecturer.
     * @param {lecturerUpsertArgs} args - Arguments to update or create a Lecturer.
     * @example
     * // Update or create a Lecturer
     * const lecturer = await prisma.lecturer.upsert({
     *   create: {
     *     // ... data to create a Lecturer
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Lecturer we want to update
     *   }
     * })
    **/
    upsert<T extends lecturerUpsertArgs>(
      args: SelectSubset<T, lecturerUpsertArgs>
    ): CheckSelect<T, Prisma__lecturerClient<lecturer>, Prisma__lecturerClient<lecturerGetPayload<T>>>

    /**
     * Find one Lecturer that matches the filter or throw
     * `NotFoundError` if no matches were found.
     * @param {lecturerFindUniqueOrThrowArgs} args - Arguments to find a Lecturer
     * @example
     * // Get one Lecturer
     * const lecturer = await prisma.lecturer.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends lecturerFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, lecturerFindUniqueOrThrowArgs>
    ): CheckSelect<T, Prisma__lecturerClient<lecturer>, Prisma__lecturerClient<lecturerGetPayload<T>>>

    /**
     * Find the first Lecturer that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {lecturerFindFirstOrThrowArgs} args - Arguments to find a Lecturer
     * @example
     * // Get one Lecturer
     * const lecturer = await prisma.lecturer.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends lecturerFindFirstOrThrowArgs>(
      args?: SelectSubset<T, lecturerFindFirstOrThrowArgs>
    ): CheckSelect<T, Prisma__lecturerClient<lecturer>, Prisma__lecturerClient<lecturerGetPayload<T>>>

    /**
     * Count the number of Lecturers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {lecturerCountArgs} args - Arguments to filter Lecturers to count.
     * @example
     * // Count the number of Lecturers
     * const count = await prisma.lecturer.count({
     *   where: {
     *     // ... the filter for the Lecturers we want to count
     *   }
     * })
    **/
    count<T extends lecturerCountArgs>(
      args?: Subset<T, lecturerCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], LecturerCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Lecturer.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LecturerAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends LecturerAggregateArgs>(args: Subset<T, LecturerAggregateArgs>): PrismaPromise<GetLecturerAggregateType<T>>

    /**
     * Group by Lecturer.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LecturerGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends LecturerGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: LecturerGroupByArgs['orderBy'] }
        : { orderBy?: LecturerGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, LecturerGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetLecturerGroupByPayload<T> : PrismaPromise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for lecturer.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__lecturerClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * lecturer base type for findUnique actions
   */
  export type lecturerFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the lecturer
     * 
    **/
    select?: lecturerSelect | null
    /**
     * Filter, which lecturer to fetch.
     * 
    **/
    where: lecturerWhereUniqueInput
  }

  /**
   * lecturer: findUnique
   */
  export interface lecturerFindUniqueArgs extends lecturerFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * lecturer base type for findFirst actions
   */
  export type lecturerFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the lecturer
     * 
    **/
    select?: lecturerSelect | null
    /**
     * Filter, which lecturer to fetch.
     * 
    **/
    where?: lecturerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of lecturers to fetch.
     * 
    **/
    orderBy?: Enumerable<lecturerOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for lecturers.
     * 
    **/
    cursor?: lecturerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` lecturers from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` lecturers.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of lecturers.
     * 
    **/
    distinct?: Enumerable<LecturerScalarFieldEnum>
  }

  /**
   * lecturer: findFirst
   */
  export interface lecturerFindFirstArgs extends lecturerFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * lecturer findMany
   */
  export type lecturerFindManyArgs = {
    /**
     * Select specific fields to fetch from the lecturer
     * 
    **/
    select?: lecturerSelect | null
    /**
     * Filter, which lecturers to fetch.
     * 
    **/
    where?: lecturerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of lecturers to fetch.
     * 
    **/
    orderBy?: Enumerable<lecturerOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing lecturers.
     * 
    **/
    cursor?: lecturerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` lecturers from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` lecturers.
     * 
    **/
    skip?: number
    distinct?: Enumerable<LecturerScalarFieldEnum>
  }


  /**
   * lecturer create
   */
  export type lecturerCreateArgs = {
    /**
     * Select specific fields to fetch from the lecturer
     * 
    **/
    select?: lecturerSelect | null
    /**
     * The data needed to create a lecturer.
     * 
    **/
    data: XOR<lecturerCreateInput, lecturerUncheckedCreateInput>
  }


  /**
   * lecturer createMany
   */
  export type lecturerCreateManyArgs = {
    /**
     * The data used to create many lecturers.
     * 
    **/
    data: Enumerable<lecturerCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * lecturer update
   */
  export type lecturerUpdateArgs = {
    /**
     * Select specific fields to fetch from the lecturer
     * 
    **/
    select?: lecturerSelect | null
    /**
     * The data needed to update a lecturer.
     * 
    **/
    data: XOR<lecturerUpdateInput, lecturerUncheckedUpdateInput>
    /**
     * Choose, which lecturer to update.
     * 
    **/
    where: lecturerWhereUniqueInput
  }


  /**
   * lecturer updateMany
   */
  export type lecturerUpdateManyArgs = {
    /**
     * The data used to update lecturers.
     * 
    **/
    data: XOR<lecturerUpdateManyMutationInput, lecturerUncheckedUpdateManyInput>
    /**
     * Filter which lecturers to update
     * 
    **/
    where?: lecturerWhereInput
  }


  /**
   * lecturer upsert
   */
  export type lecturerUpsertArgs = {
    /**
     * Select specific fields to fetch from the lecturer
     * 
    **/
    select?: lecturerSelect | null
    /**
     * The filter to search for the lecturer to update in case it exists.
     * 
    **/
    where: lecturerWhereUniqueInput
    /**
     * In case the lecturer found by the `where` argument doesn't exist, create a new lecturer with this data.
     * 
    **/
    create: XOR<lecturerCreateInput, lecturerUncheckedCreateInput>
    /**
     * In case the lecturer was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<lecturerUpdateInput, lecturerUncheckedUpdateInput>
  }


  /**
   * lecturer delete
   */
  export type lecturerDeleteArgs = {
    /**
     * Select specific fields to fetch from the lecturer
     * 
    **/
    select?: lecturerSelect | null
    /**
     * Filter which lecturer to delete.
     * 
    **/
    where: lecturerWhereUniqueInput
  }


  /**
   * lecturer deleteMany
   */
  export type lecturerDeleteManyArgs = {
    /**
     * Filter which lecturers to delete
     * 
    **/
    where?: lecturerWhereInput
  }


  /**
   * lecturer: findUniqueOrThrow
   */
  export type lecturerFindUniqueOrThrowArgs = lecturerFindUniqueArgsBase
      

  /**
   * lecturer: findFirstOrThrow
   */
  export type lecturerFindFirstOrThrowArgs = lecturerFindFirstArgsBase
      

  /**
   * lecturer without action
   */
  export type lecturerArgs = {
    /**
     * Select specific fields to fetch from the lecturer
     * 
    **/
    select?: lecturerSelect | null
  }



  /**
   * Model lecturer_courses
   */


  export type AggregateLecturer_courses = {
    _count: Lecturer_coursesCountAggregateOutputType | null
    _avg: Lecturer_coursesAvgAggregateOutputType | null
    _sum: Lecturer_coursesSumAggregateOutputType | null
    _min: Lecturer_coursesMinAggregateOutputType | null
    _max: Lecturer_coursesMaxAggregateOutputType | null
  }

  export type Lecturer_coursesAvgAggregateOutputType = {
    user_id: number | null
    course_id: number | null
  }

  export type Lecturer_coursesSumAggregateOutputType = {
    user_id: number | null
    course_id: number | null
  }

  export type Lecturer_coursesMinAggregateOutputType = {
    user_id: number | null
    course_id: number | null
  }

  export type Lecturer_coursesMaxAggregateOutputType = {
    user_id: number | null
    course_id: number | null
  }

  export type Lecturer_coursesCountAggregateOutputType = {
    user_id: number
    course_id: number
    _all: number
  }


  export type Lecturer_coursesAvgAggregateInputType = {
    user_id?: true
    course_id?: true
  }

  export type Lecturer_coursesSumAggregateInputType = {
    user_id?: true
    course_id?: true
  }

  export type Lecturer_coursesMinAggregateInputType = {
    user_id?: true
    course_id?: true
  }

  export type Lecturer_coursesMaxAggregateInputType = {
    user_id?: true
    course_id?: true
  }

  export type Lecturer_coursesCountAggregateInputType = {
    user_id?: true
    course_id?: true
    _all?: true
  }

  export type Lecturer_coursesAggregateArgs = {
    /**
     * Filter which lecturer_courses to aggregate.
     * 
    **/
    where?: lecturer_coursesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of lecturer_courses to fetch.
     * 
    **/
    orderBy?: Enumerable<lecturer_coursesOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: lecturer_coursesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` lecturer_courses from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` lecturer_courses.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned lecturer_courses
    **/
    _count?: true | Lecturer_coursesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Lecturer_coursesAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Lecturer_coursesSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Lecturer_coursesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Lecturer_coursesMaxAggregateInputType
  }

  export type GetLecturer_coursesAggregateType<T extends Lecturer_coursesAggregateArgs> = {
        [P in keyof T & keyof AggregateLecturer_courses]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLecturer_courses[P]>
      : GetScalarType<T[P], AggregateLecturer_courses[P]>
  }




  export type Lecturer_coursesGroupByArgs = {
    where?: lecturer_coursesWhereInput
    orderBy?: Enumerable<lecturer_coursesOrderByWithAggregationInput>
    by: Array<Lecturer_coursesScalarFieldEnum>
    having?: lecturer_coursesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Lecturer_coursesCountAggregateInputType | true
    _avg?: Lecturer_coursesAvgAggregateInputType
    _sum?: Lecturer_coursesSumAggregateInputType
    _min?: Lecturer_coursesMinAggregateInputType
    _max?: Lecturer_coursesMaxAggregateInputType
  }


  export type Lecturer_coursesGroupByOutputType = {
    user_id: number
    course_id: number
    _count: Lecturer_coursesCountAggregateOutputType | null
    _avg: Lecturer_coursesAvgAggregateOutputType | null
    _sum: Lecturer_coursesSumAggregateOutputType | null
    _min: Lecturer_coursesMinAggregateOutputType | null
    _max: Lecturer_coursesMaxAggregateOutputType | null
  }

  type GetLecturer_coursesGroupByPayload<T extends Lecturer_coursesGroupByArgs> = PrismaPromise<
    Array<
      PickArray<Lecturer_coursesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Lecturer_coursesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Lecturer_coursesGroupByOutputType[P]>
            : GetScalarType<T[P], Lecturer_coursesGroupByOutputType[P]>
        }
      >
    >


  export type lecturer_coursesSelect = {
    user_id?: boolean
    course_id?: boolean
  }

  export type lecturer_coursesGetPayload<
    S extends boolean | null | undefined | lecturer_coursesArgs,
    U = keyof S
      > = S extends true
        ? lecturer_courses
    : S extends undefined
    ? never
    : S extends lecturer_coursesArgs | lecturer_coursesFindManyArgs
    ?'include' extends U
    ? lecturer_courses 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
    P extends keyof lecturer_courses ? lecturer_courses[P] : never
  } 
    : lecturer_courses
  : lecturer_courses


  type lecturer_coursesCountArgs = Merge<
    Omit<lecturer_coursesFindManyArgs, 'select' | 'include'> & {
      select?: Lecturer_coursesCountAggregateInputType | true
    }
  >

  export interface lecturer_coursesDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one Lecturer_courses that matches the filter.
     * @param {lecturer_coursesFindUniqueArgs} args - Arguments to find a Lecturer_courses
     * @example
     * // Get one Lecturer_courses
     * const lecturer_courses = await prisma.lecturer_courses.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends lecturer_coursesFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, lecturer_coursesFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'lecturer_courses'> extends True ? CheckSelect<T, Prisma__lecturer_coursesClient<lecturer_courses>, Prisma__lecturer_coursesClient<lecturer_coursesGetPayload<T>>> : CheckSelect<T, Prisma__lecturer_coursesClient<lecturer_courses | null >, Prisma__lecturer_coursesClient<lecturer_coursesGetPayload<T> | null >>

    /**
     * Find the first Lecturer_courses that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {lecturer_coursesFindFirstArgs} args - Arguments to find a Lecturer_courses
     * @example
     * // Get one Lecturer_courses
     * const lecturer_courses = await prisma.lecturer_courses.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends lecturer_coursesFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, lecturer_coursesFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'lecturer_courses'> extends True ? CheckSelect<T, Prisma__lecturer_coursesClient<lecturer_courses>, Prisma__lecturer_coursesClient<lecturer_coursesGetPayload<T>>> : CheckSelect<T, Prisma__lecturer_coursesClient<lecturer_courses | null >, Prisma__lecturer_coursesClient<lecturer_coursesGetPayload<T> | null >>

    /**
     * Find zero or more Lecturer_courses that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {lecturer_coursesFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Lecturer_courses
     * const lecturer_courses = await prisma.lecturer_courses.findMany()
     * 
     * // Get first 10 Lecturer_courses
     * const lecturer_courses = await prisma.lecturer_courses.findMany({ take: 10 })
     * 
     * // Only select the `user_id`
     * const lecturer_coursesWithUser_idOnly = await prisma.lecturer_courses.findMany({ select: { user_id: true } })
     * 
    **/
    findMany<T extends lecturer_coursesFindManyArgs>(
      args?: SelectSubset<T, lecturer_coursesFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<lecturer_courses>>, PrismaPromise<Array<lecturer_coursesGetPayload<T>>>>

    /**
     * Create a Lecturer_courses.
     * @param {lecturer_coursesCreateArgs} args - Arguments to create a Lecturer_courses.
     * @example
     * // Create one Lecturer_courses
     * const Lecturer_courses = await prisma.lecturer_courses.create({
     *   data: {
     *     // ... data to create a Lecturer_courses
     *   }
     * })
     * 
    **/
    create<T extends lecturer_coursesCreateArgs>(
      args: SelectSubset<T, lecturer_coursesCreateArgs>
    ): CheckSelect<T, Prisma__lecturer_coursesClient<lecturer_courses>, Prisma__lecturer_coursesClient<lecturer_coursesGetPayload<T>>>

    /**
     * Create many Lecturer_courses.
     *     @param {lecturer_coursesCreateManyArgs} args - Arguments to create many Lecturer_courses.
     *     @example
     *     // Create many Lecturer_courses
     *     const lecturer_courses = await prisma.lecturer_courses.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends lecturer_coursesCreateManyArgs>(
      args?: SelectSubset<T, lecturer_coursesCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Lecturer_courses.
     * @param {lecturer_coursesDeleteArgs} args - Arguments to delete one Lecturer_courses.
     * @example
     * // Delete one Lecturer_courses
     * const Lecturer_courses = await prisma.lecturer_courses.delete({
     *   where: {
     *     // ... filter to delete one Lecturer_courses
     *   }
     * })
     * 
    **/
    delete<T extends lecturer_coursesDeleteArgs>(
      args: SelectSubset<T, lecturer_coursesDeleteArgs>
    ): CheckSelect<T, Prisma__lecturer_coursesClient<lecturer_courses>, Prisma__lecturer_coursesClient<lecturer_coursesGetPayload<T>>>

    /**
     * Update one Lecturer_courses.
     * @param {lecturer_coursesUpdateArgs} args - Arguments to update one Lecturer_courses.
     * @example
     * // Update one Lecturer_courses
     * const lecturer_courses = await prisma.lecturer_courses.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends lecturer_coursesUpdateArgs>(
      args: SelectSubset<T, lecturer_coursesUpdateArgs>
    ): CheckSelect<T, Prisma__lecturer_coursesClient<lecturer_courses>, Prisma__lecturer_coursesClient<lecturer_coursesGetPayload<T>>>

    /**
     * Delete zero or more Lecturer_courses.
     * @param {lecturer_coursesDeleteManyArgs} args - Arguments to filter Lecturer_courses to delete.
     * @example
     * // Delete a few Lecturer_courses
     * const { count } = await prisma.lecturer_courses.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends lecturer_coursesDeleteManyArgs>(
      args?: SelectSubset<T, lecturer_coursesDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Lecturer_courses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {lecturer_coursesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Lecturer_courses
     * const lecturer_courses = await prisma.lecturer_courses.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends lecturer_coursesUpdateManyArgs>(
      args: SelectSubset<T, lecturer_coursesUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Lecturer_courses.
     * @param {lecturer_coursesUpsertArgs} args - Arguments to update or create a Lecturer_courses.
     * @example
     * // Update or create a Lecturer_courses
     * const lecturer_courses = await prisma.lecturer_courses.upsert({
     *   create: {
     *     // ... data to create a Lecturer_courses
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Lecturer_courses we want to update
     *   }
     * })
    **/
    upsert<T extends lecturer_coursesUpsertArgs>(
      args: SelectSubset<T, lecturer_coursesUpsertArgs>
    ): CheckSelect<T, Prisma__lecturer_coursesClient<lecturer_courses>, Prisma__lecturer_coursesClient<lecturer_coursesGetPayload<T>>>

    /**
     * Find one Lecturer_courses that matches the filter or throw
     * `NotFoundError` if no matches were found.
     * @param {lecturer_coursesFindUniqueOrThrowArgs} args - Arguments to find a Lecturer_courses
     * @example
     * // Get one Lecturer_courses
     * const lecturer_courses = await prisma.lecturer_courses.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends lecturer_coursesFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, lecturer_coursesFindUniqueOrThrowArgs>
    ): CheckSelect<T, Prisma__lecturer_coursesClient<lecturer_courses>, Prisma__lecturer_coursesClient<lecturer_coursesGetPayload<T>>>

    /**
     * Find the first Lecturer_courses that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {lecturer_coursesFindFirstOrThrowArgs} args - Arguments to find a Lecturer_courses
     * @example
     * // Get one Lecturer_courses
     * const lecturer_courses = await prisma.lecturer_courses.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends lecturer_coursesFindFirstOrThrowArgs>(
      args?: SelectSubset<T, lecturer_coursesFindFirstOrThrowArgs>
    ): CheckSelect<T, Prisma__lecturer_coursesClient<lecturer_courses>, Prisma__lecturer_coursesClient<lecturer_coursesGetPayload<T>>>

    /**
     * Count the number of Lecturer_courses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {lecturer_coursesCountArgs} args - Arguments to filter Lecturer_courses to count.
     * @example
     * // Count the number of Lecturer_courses
     * const count = await prisma.lecturer_courses.count({
     *   where: {
     *     // ... the filter for the Lecturer_courses we want to count
     *   }
     * })
    **/
    count<T extends lecturer_coursesCountArgs>(
      args?: Subset<T, lecturer_coursesCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Lecturer_coursesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Lecturer_courses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Lecturer_coursesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Lecturer_coursesAggregateArgs>(args: Subset<T, Lecturer_coursesAggregateArgs>): PrismaPromise<GetLecturer_coursesAggregateType<T>>

    /**
     * Group by Lecturer_courses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Lecturer_coursesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends Lecturer_coursesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: Lecturer_coursesGroupByArgs['orderBy'] }
        : { orderBy?: Lecturer_coursesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, Lecturer_coursesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetLecturer_coursesGroupByPayload<T> : PrismaPromise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for lecturer_courses.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__lecturer_coursesClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * lecturer_courses base type for findUnique actions
   */
  export type lecturer_coursesFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the lecturer_courses
     * 
    **/
    select?: lecturer_coursesSelect | null
    /**
     * Filter, which lecturer_courses to fetch.
     * 
    **/
    where: lecturer_coursesWhereUniqueInput
  }

  /**
   * lecturer_courses: findUnique
   */
  export interface lecturer_coursesFindUniqueArgs extends lecturer_coursesFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * lecturer_courses base type for findFirst actions
   */
  export type lecturer_coursesFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the lecturer_courses
     * 
    **/
    select?: lecturer_coursesSelect | null
    /**
     * Filter, which lecturer_courses to fetch.
     * 
    **/
    where?: lecturer_coursesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of lecturer_courses to fetch.
     * 
    **/
    orderBy?: Enumerable<lecturer_coursesOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for lecturer_courses.
     * 
    **/
    cursor?: lecturer_coursesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` lecturer_courses from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` lecturer_courses.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of lecturer_courses.
     * 
    **/
    distinct?: Enumerable<Lecturer_coursesScalarFieldEnum>
  }

  /**
   * lecturer_courses: findFirst
   */
  export interface lecturer_coursesFindFirstArgs extends lecturer_coursesFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * lecturer_courses findMany
   */
  export type lecturer_coursesFindManyArgs = {
    /**
     * Select specific fields to fetch from the lecturer_courses
     * 
    **/
    select?: lecturer_coursesSelect | null
    /**
     * Filter, which lecturer_courses to fetch.
     * 
    **/
    where?: lecturer_coursesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of lecturer_courses to fetch.
     * 
    **/
    orderBy?: Enumerable<lecturer_coursesOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing lecturer_courses.
     * 
    **/
    cursor?: lecturer_coursesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` lecturer_courses from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` lecturer_courses.
     * 
    **/
    skip?: number
    distinct?: Enumerable<Lecturer_coursesScalarFieldEnum>
  }


  /**
   * lecturer_courses create
   */
  export type lecturer_coursesCreateArgs = {
    /**
     * Select specific fields to fetch from the lecturer_courses
     * 
    **/
    select?: lecturer_coursesSelect | null
    /**
     * The data needed to create a lecturer_courses.
     * 
    **/
    data: XOR<lecturer_coursesCreateInput, lecturer_coursesUncheckedCreateInput>
  }


  /**
   * lecturer_courses createMany
   */
  export type lecturer_coursesCreateManyArgs = {
    /**
     * The data used to create many lecturer_courses.
     * 
    **/
    data: Enumerable<lecturer_coursesCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * lecturer_courses update
   */
  export type lecturer_coursesUpdateArgs = {
    /**
     * Select specific fields to fetch from the lecturer_courses
     * 
    **/
    select?: lecturer_coursesSelect | null
    /**
     * The data needed to update a lecturer_courses.
     * 
    **/
    data: XOR<lecturer_coursesUpdateInput, lecturer_coursesUncheckedUpdateInput>
    /**
     * Choose, which lecturer_courses to update.
     * 
    **/
    where: lecturer_coursesWhereUniqueInput
  }


  /**
   * lecturer_courses updateMany
   */
  export type lecturer_coursesUpdateManyArgs = {
    /**
     * The data used to update lecturer_courses.
     * 
    **/
    data: XOR<lecturer_coursesUpdateManyMutationInput, lecturer_coursesUncheckedUpdateManyInput>
    /**
     * Filter which lecturer_courses to update
     * 
    **/
    where?: lecturer_coursesWhereInput
  }


  /**
   * lecturer_courses upsert
   */
  export type lecturer_coursesUpsertArgs = {
    /**
     * Select specific fields to fetch from the lecturer_courses
     * 
    **/
    select?: lecturer_coursesSelect | null
    /**
     * The filter to search for the lecturer_courses to update in case it exists.
     * 
    **/
    where: lecturer_coursesWhereUniqueInput
    /**
     * In case the lecturer_courses found by the `where` argument doesn't exist, create a new lecturer_courses with this data.
     * 
    **/
    create: XOR<lecturer_coursesCreateInput, lecturer_coursesUncheckedCreateInput>
    /**
     * In case the lecturer_courses was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<lecturer_coursesUpdateInput, lecturer_coursesUncheckedUpdateInput>
  }


  /**
   * lecturer_courses delete
   */
  export type lecturer_coursesDeleteArgs = {
    /**
     * Select specific fields to fetch from the lecturer_courses
     * 
    **/
    select?: lecturer_coursesSelect | null
    /**
     * Filter which lecturer_courses to delete.
     * 
    **/
    where: lecturer_coursesWhereUniqueInput
  }


  /**
   * lecturer_courses deleteMany
   */
  export type lecturer_coursesDeleteManyArgs = {
    /**
     * Filter which lecturer_courses to delete
     * 
    **/
    where?: lecturer_coursesWhereInput
  }


  /**
   * lecturer_courses: findUniqueOrThrow
   */
  export type lecturer_coursesFindUniqueOrThrowArgs = lecturer_coursesFindUniqueArgsBase
      

  /**
   * lecturer_courses: findFirstOrThrow
   */
  export type lecturer_coursesFindFirstOrThrowArgs = lecturer_coursesFindFirstArgsBase
      

  /**
   * lecturer_courses without action
   */
  export type lecturer_coursesArgs = {
    /**
     * Select specific fields to fetch from the lecturer_courses
     * 
    **/
    select?: lecturer_coursesSelect | null
  }



  /**
   * Model letter
   */


  export type AggregateLetter = {
    _count: LetterCountAggregateOutputType | null
    _avg: LetterAvgAggregateOutputType | null
    _sum: LetterSumAggregateOutputType | null
    _min: LetterMinAggregateOutputType | null
    _max: LetterMaxAggregateOutputType | null
  }

  export type LetterAvgAggregateOutputType = {
    letter_id: number | null
    duration: number | null
    study_year: number | null
    index_no: number | null
  }

  export type LetterSumAggregateOutputType = {
    letter_id: number | null
    duration: number | null
    study_year: number | null
    index_no: number | null
  }

  export type LetterMinAggregateOutputType = {
    letter_id: number | null
    email: string | null
    another_email: string | null
    final_quali: string | null
    id_no: string | null
    duration: number | null
    degree_status: string | null
    study_year: number | null
    index_no: number | null
    reg_no: string | null
    degree_prog: string | null
    address: string | null
    contact_no: string | null
    another_cont_no: string | null
    payment_voucher: string | null
  }

  export type LetterMaxAggregateOutputType = {
    letter_id: number | null
    email: string | null
    another_email: string | null
    final_quali: string | null
    id_no: string | null
    duration: number | null
    degree_status: string | null
    study_year: number | null
    index_no: number | null
    reg_no: string | null
    degree_prog: string | null
    address: string | null
    contact_no: string | null
    another_cont_no: string | null
    payment_voucher: string | null
  }

  export type LetterCountAggregateOutputType = {
    letter_id: number
    email: number
    another_email: number
    final_quali: number
    id_no: number
    duration: number
    degree_status: number
    study_year: number
    index_no: number
    reg_no: number
    degree_prog: number
    address: number
    contact_no: number
    another_cont_no: number
    payment_voucher: number
    _all: number
  }


  export type LetterAvgAggregateInputType = {
    letter_id?: true
    duration?: true
    study_year?: true
    index_no?: true
  }

  export type LetterSumAggregateInputType = {
    letter_id?: true
    duration?: true
    study_year?: true
    index_no?: true
  }

  export type LetterMinAggregateInputType = {
    letter_id?: true
    email?: true
    another_email?: true
    final_quali?: true
    id_no?: true
    duration?: true
    degree_status?: true
    study_year?: true
    index_no?: true
    reg_no?: true
    degree_prog?: true
    address?: true
    contact_no?: true
    another_cont_no?: true
    payment_voucher?: true
  }

  export type LetterMaxAggregateInputType = {
    letter_id?: true
    email?: true
    another_email?: true
    final_quali?: true
    id_no?: true
    duration?: true
    degree_status?: true
    study_year?: true
    index_no?: true
    reg_no?: true
    degree_prog?: true
    address?: true
    contact_no?: true
    another_cont_no?: true
    payment_voucher?: true
  }

  export type LetterCountAggregateInputType = {
    letter_id?: true
    email?: true
    another_email?: true
    final_quali?: true
    id_no?: true
    duration?: true
    degree_status?: true
    study_year?: true
    index_no?: true
    reg_no?: true
    degree_prog?: true
    address?: true
    contact_no?: true
    another_cont_no?: true
    payment_voucher?: true
    _all?: true
  }

  export type LetterAggregateArgs = {
    /**
     * Filter which letter to aggregate.
     * 
    **/
    where?: letterWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of letters to fetch.
     * 
    **/
    orderBy?: Enumerable<letterOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: letterWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` letters from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` letters.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned letters
    **/
    _count?: true | LetterCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: LetterAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: LetterSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: LetterMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: LetterMaxAggregateInputType
  }

  export type GetLetterAggregateType<T extends LetterAggregateArgs> = {
        [P in keyof T & keyof AggregateLetter]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLetter[P]>
      : GetScalarType<T[P], AggregateLetter[P]>
  }




  export type LetterGroupByArgs = {
    where?: letterWhereInput
    orderBy?: Enumerable<letterOrderByWithAggregationInput>
    by: Array<LetterScalarFieldEnum>
    having?: letterScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: LetterCountAggregateInputType | true
    _avg?: LetterAvgAggregateInputType
    _sum?: LetterSumAggregateInputType
    _min?: LetterMinAggregateInputType
    _max?: LetterMaxAggregateInputType
  }


  export type LetterGroupByOutputType = {
    letter_id: number
    email: string
    another_email: string
    final_quali: string
    id_no: string
    duration: number
    degree_status: string
    study_year: number
    index_no: number
    reg_no: string
    degree_prog: string
    address: string
    contact_no: string
    another_cont_no: string
    payment_voucher: string
    _count: LetterCountAggregateOutputType | null
    _avg: LetterAvgAggregateOutputType | null
    _sum: LetterSumAggregateOutputType | null
    _min: LetterMinAggregateOutputType | null
    _max: LetterMaxAggregateOutputType | null
  }

  type GetLetterGroupByPayload<T extends LetterGroupByArgs> = PrismaPromise<
    Array<
      PickArray<LetterGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof LetterGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], LetterGroupByOutputType[P]>
            : GetScalarType<T[P], LetterGroupByOutputType[P]>
        }
      >
    >


  export type letterSelect = {
    letter_id?: boolean
    email?: boolean
    another_email?: boolean
    final_quali?: boolean
    id_no?: boolean
    duration?: boolean
    degree_status?: boolean
    study_year?: boolean
    index_no?: boolean
    reg_no?: boolean
    degree_prog?: boolean
    address?: boolean
    contact_no?: boolean
    another_cont_no?: boolean
    payment_voucher?: boolean
  }

  export type letterGetPayload<
    S extends boolean | null | undefined | letterArgs,
    U = keyof S
      > = S extends true
        ? letter
    : S extends undefined
    ? never
    : S extends letterArgs | letterFindManyArgs
    ?'include' extends U
    ? letter 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
    P extends keyof letter ? letter[P] : never
  } 
    : letter
  : letter


  type letterCountArgs = Merge<
    Omit<letterFindManyArgs, 'select' | 'include'> & {
      select?: LetterCountAggregateInputType | true
    }
  >

  export interface letterDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one Letter that matches the filter.
     * @param {letterFindUniqueArgs} args - Arguments to find a Letter
     * @example
     * // Get one Letter
     * const letter = await prisma.letter.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends letterFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, letterFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'letter'> extends True ? CheckSelect<T, Prisma__letterClient<letter>, Prisma__letterClient<letterGetPayload<T>>> : CheckSelect<T, Prisma__letterClient<letter | null >, Prisma__letterClient<letterGetPayload<T> | null >>

    /**
     * Find the first Letter that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {letterFindFirstArgs} args - Arguments to find a Letter
     * @example
     * // Get one Letter
     * const letter = await prisma.letter.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends letterFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, letterFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'letter'> extends True ? CheckSelect<T, Prisma__letterClient<letter>, Prisma__letterClient<letterGetPayload<T>>> : CheckSelect<T, Prisma__letterClient<letter | null >, Prisma__letterClient<letterGetPayload<T> | null >>

    /**
     * Find zero or more Letters that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {letterFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Letters
     * const letters = await prisma.letter.findMany()
     * 
     * // Get first 10 Letters
     * const letters = await prisma.letter.findMany({ take: 10 })
     * 
     * // Only select the `letter_id`
     * const letterWithLetter_idOnly = await prisma.letter.findMany({ select: { letter_id: true } })
     * 
    **/
    findMany<T extends letterFindManyArgs>(
      args?: SelectSubset<T, letterFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<letter>>, PrismaPromise<Array<letterGetPayload<T>>>>

    /**
     * Create a Letter.
     * @param {letterCreateArgs} args - Arguments to create a Letter.
     * @example
     * // Create one Letter
     * const Letter = await prisma.letter.create({
     *   data: {
     *     // ... data to create a Letter
     *   }
     * })
     * 
    **/
    create<T extends letterCreateArgs>(
      args: SelectSubset<T, letterCreateArgs>
    ): CheckSelect<T, Prisma__letterClient<letter>, Prisma__letterClient<letterGetPayload<T>>>

    /**
     * Create many Letters.
     *     @param {letterCreateManyArgs} args - Arguments to create many Letters.
     *     @example
     *     // Create many Letters
     *     const letter = await prisma.letter.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends letterCreateManyArgs>(
      args?: SelectSubset<T, letterCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Letter.
     * @param {letterDeleteArgs} args - Arguments to delete one Letter.
     * @example
     * // Delete one Letter
     * const Letter = await prisma.letter.delete({
     *   where: {
     *     // ... filter to delete one Letter
     *   }
     * })
     * 
    **/
    delete<T extends letterDeleteArgs>(
      args: SelectSubset<T, letterDeleteArgs>
    ): CheckSelect<T, Prisma__letterClient<letter>, Prisma__letterClient<letterGetPayload<T>>>

    /**
     * Update one Letter.
     * @param {letterUpdateArgs} args - Arguments to update one Letter.
     * @example
     * // Update one Letter
     * const letter = await prisma.letter.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends letterUpdateArgs>(
      args: SelectSubset<T, letterUpdateArgs>
    ): CheckSelect<T, Prisma__letterClient<letter>, Prisma__letterClient<letterGetPayload<T>>>

    /**
     * Delete zero or more Letters.
     * @param {letterDeleteManyArgs} args - Arguments to filter Letters to delete.
     * @example
     * // Delete a few Letters
     * const { count } = await prisma.letter.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends letterDeleteManyArgs>(
      args?: SelectSubset<T, letterDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Letters.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {letterUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Letters
     * const letter = await prisma.letter.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends letterUpdateManyArgs>(
      args: SelectSubset<T, letterUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Letter.
     * @param {letterUpsertArgs} args - Arguments to update or create a Letter.
     * @example
     * // Update or create a Letter
     * const letter = await prisma.letter.upsert({
     *   create: {
     *     // ... data to create a Letter
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Letter we want to update
     *   }
     * })
    **/
    upsert<T extends letterUpsertArgs>(
      args: SelectSubset<T, letterUpsertArgs>
    ): CheckSelect<T, Prisma__letterClient<letter>, Prisma__letterClient<letterGetPayload<T>>>

    /**
     * Find one Letter that matches the filter or throw
     * `NotFoundError` if no matches were found.
     * @param {letterFindUniqueOrThrowArgs} args - Arguments to find a Letter
     * @example
     * // Get one Letter
     * const letter = await prisma.letter.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends letterFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, letterFindUniqueOrThrowArgs>
    ): CheckSelect<T, Prisma__letterClient<letter>, Prisma__letterClient<letterGetPayload<T>>>

    /**
     * Find the first Letter that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {letterFindFirstOrThrowArgs} args - Arguments to find a Letter
     * @example
     * // Get one Letter
     * const letter = await prisma.letter.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends letterFindFirstOrThrowArgs>(
      args?: SelectSubset<T, letterFindFirstOrThrowArgs>
    ): CheckSelect<T, Prisma__letterClient<letter>, Prisma__letterClient<letterGetPayload<T>>>

    /**
     * Count the number of Letters.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {letterCountArgs} args - Arguments to filter Letters to count.
     * @example
     * // Count the number of Letters
     * const count = await prisma.letter.count({
     *   where: {
     *     // ... the filter for the Letters we want to count
     *   }
     * })
    **/
    count<T extends letterCountArgs>(
      args?: Subset<T, letterCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], LetterCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Letter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LetterAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends LetterAggregateArgs>(args: Subset<T, LetterAggregateArgs>): PrismaPromise<GetLetterAggregateType<T>>

    /**
     * Group by Letter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LetterGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends LetterGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: LetterGroupByArgs['orderBy'] }
        : { orderBy?: LetterGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, LetterGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetLetterGroupByPayload<T> : PrismaPromise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for letter.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__letterClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * letter base type for findUnique actions
   */
  export type letterFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the letter
     * 
    **/
    select?: letterSelect | null
    /**
     * Filter, which letter to fetch.
     * 
    **/
    where: letterWhereUniqueInput
  }

  /**
   * letter: findUnique
   */
  export interface letterFindUniqueArgs extends letterFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * letter base type for findFirst actions
   */
  export type letterFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the letter
     * 
    **/
    select?: letterSelect | null
    /**
     * Filter, which letter to fetch.
     * 
    **/
    where?: letterWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of letters to fetch.
     * 
    **/
    orderBy?: Enumerable<letterOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for letters.
     * 
    **/
    cursor?: letterWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` letters from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` letters.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of letters.
     * 
    **/
    distinct?: Enumerable<LetterScalarFieldEnum>
  }

  /**
   * letter: findFirst
   */
  export interface letterFindFirstArgs extends letterFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * letter findMany
   */
  export type letterFindManyArgs = {
    /**
     * Select specific fields to fetch from the letter
     * 
    **/
    select?: letterSelect | null
    /**
     * Filter, which letters to fetch.
     * 
    **/
    where?: letterWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of letters to fetch.
     * 
    **/
    orderBy?: Enumerable<letterOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing letters.
     * 
    **/
    cursor?: letterWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` letters from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` letters.
     * 
    **/
    skip?: number
    distinct?: Enumerable<LetterScalarFieldEnum>
  }


  /**
   * letter create
   */
  export type letterCreateArgs = {
    /**
     * Select specific fields to fetch from the letter
     * 
    **/
    select?: letterSelect | null
    /**
     * The data needed to create a letter.
     * 
    **/
    data: XOR<letterCreateInput, letterUncheckedCreateInput>
  }


  /**
   * letter createMany
   */
  export type letterCreateManyArgs = {
    /**
     * The data used to create many letters.
     * 
    **/
    data: Enumerable<letterCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * letter update
   */
  export type letterUpdateArgs = {
    /**
     * Select specific fields to fetch from the letter
     * 
    **/
    select?: letterSelect | null
    /**
     * The data needed to update a letter.
     * 
    **/
    data: XOR<letterUpdateInput, letterUncheckedUpdateInput>
    /**
     * Choose, which letter to update.
     * 
    **/
    where: letterWhereUniqueInput
  }


  /**
   * letter updateMany
   */
  export type letterUpdateManyArgs = {
    /**
     * The data used to update letters.
     * 
    **/
    data: XOR<letterUpdateManyMutationInput, letterUncheckedUpdateManyInput>
    /**
     * Filter which letters to update
     * 
    **/
    where?: letterWhereInput
  }


  /**
   * letter upsert
   */
  export type letterUpsertArgs = {
    /**
     * Select specific fields to fetch from the letter
     * 
    **/
    select?: letterSelect | null
    /**
     * The filter to search for the letter to update in case it exists.
     * 
    **/
    where: letterWhereUniqueInput
    /**
     * In case the letter found by the `where` argument doesn't exist, create a new letter with this data.
     * 
    **/
    create: XOR<letterCreateInput, letterUncheckedCreateInput>
    /**
     * In case the letter was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<letterUpdateInput, letterUncheckedUpdateInput>
  }


  /**
   * letter delete
   */
  export type letterDeleteArgs = {
    /**
     * Select specific fields to fetch from the letter
     * 
    **/
    select?: letterSelect | null
    /**
     * Filter which letter to delete.
     * 
    **/
    where: letterWhereUniqueInput
  }


  /**
   * letter deleteMany
   */
  export type letterDeleteManyArgs = {
    /**
     * Filter which letters to delete
     * 
    **/
    where?: letterWhereInput
  }


  /**
   * letter: findUniqueOrThrow
   */
  export type letterFindUniqueOrThrowArgs = letterFindUniqueArgsBase
      

  /**
   * letter: findFirstOrThrow
   */
  export type letterFindFirstOrThrowArgs = letterFindFirstArgsBase
      

  /**
   * letter without action
   */
  export type letterArgs = {
    /**
     * Select specific fields to fetch from the letter
     * 
    **/
    select?: letterSelect | null
  }



  /**
   * Model ma
   */


  export type AggregateMa = {
    _count: MaCountAggregateOutputType | null
    _avg: MaAvgAggregateOutputType | null
    _sum: MaSumAggregateOutputType | null
    _min: MaMinAggregateOutputType | null
    _max: MaMaxAggregateOutputType | null
  }

  export type MaAvgAggregateOutputType = {
    MA_id: number | null
    user_id: number | null
    staff_id: number | null
    letter_id: number | null
  }

  export type MaSumAggregateOutputType = {
    MA_id: number | null
    user_id: number | null
    staff_id: number | null
    letter_id: number | null
  }

  export type MaMinAggregateOutputType = {
    MA_id: number | null
    user_id: number | null
    staff_id: number | null
    office_id: string | null
    letter_id: number | null
  }

  export type MaMaxAggregateOutputType = {
    MA_id: number | null
    user_id: number | null
    staff_id: number | null
    office_id: string | null
    letter_id: number | null
  }

  export type MaCountAggregateOutputType = {
    MA_id: number
    user_id: number
    staff_id: number
    office_id: number
    letter_id: number
    _all: number
  }


  export type MaAvgAggregateInputType = {
    MA_id?: true
    user_id?: true
    staff_id?: true
    letter_id?: true
  }

  export type MaSumAggregateInputType = {
    MA_id?: true
    user_id?: true
    staff_id?: true
    letter_id?: true
  }

  export type MaMinAggregateInputType = {
    MA_id?: true
    user_id?: true
    staff_id?: true
    office_id?: true
    letter_id?: true
  }

  export type MaMaxAggregateInputType = {
    MA_id?: true
    user_id?: true
    staff_id?: true
    office_id?: true
    letter_id?: true
  }

  export type MaCountAggregateInputType = {
    MA_id?: true
    user_id?: true
    staff_id?: true
    office_id?: true
    letter_id?: true
    _all?: true
  }

  export type MaAggregateArgs = {
    /**
     * Filter which ma to aggregate.
     * 
    **/
    where?: maWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of mas to fetch.
     * 
    **/
    orderBy?: Enumerable<maOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: maWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` mas from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` mas.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned mas
    **/
    _count?: true | MaCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: MaAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: MaSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MaMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MaMaxAggregateInputType
  }

  export type GetMaAggregateType<T extends MaAggregateArgs> = {
        [P in keyof T & keyof AggregateMa]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMa[P]>
      : GetScalarType<T[P], AggregateMa[P]>
  }




  export type MaGroupByArgs = {
    where?: maWhereInput
    orderBy?: Enumerable<maOrderByWithAggregationInput>
    by: Array<MaScalarFieldEnum>
    having?: maScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MaCountAggregateInputType | true
    _avg?: MaAvgAggregateInputType
    _sum?: MaSumAggregateInputType
    _min?: MaMinAggregateInputType
    _max?: MaMaxAggregateInputType
  }


  export type MaGroupByOutputType = {
    MA_id: number
    user_id: number
    staff_id: number
    office_id: string
    letter_id: number
    _count: MaCountAggregateOutputType | null
    _avg: MaAvgAggregateOutputType | null
    _sum: MaSumAggregateOutputType | null
    _min: MaMinAggregateOutputType | null
    _max: MaMaxAggregateOutputType | null
  }

  type GetMaGroupByPayload<T extends MaGroupByArgs> = PrismaPromise<
    Array<
      PickArray<MaGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MaGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MaGroupByOutputType[P]>
            : GetScalarType<T[P], MaGroupByOutputType[P]>
        }
      >
    >


  export type maSelect = {
    MA_id?: boolean
    user_id?: boolean
    staff_id?: boolean
    office_id?: boolean
    letter_id?: boolean
  }

  export type maGetPayload<
    S extends boolean | null | undefined | maArgs,
    U = keyof S
      > = S extends true
        ? ma
    : S extends undefined
    ? never
    : S extends maArgs | maFindManyArgs
    ?'include' extends U
    ? ma 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
    P extends keyof ma ? ma[P] : never
  } 
    : ma
  : ma


  type maCountArgs = Merge<
    Omit<maFindManyArgs, 'select' | 'include'> & {
      select?: MaCountAggregateInputType | true
    }
  >

  export interface maDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one Ma that matches the filter.
     * @param {maFindUniqueArgs} args - Arguments to find a Ma
     * @example
     * // Get one Ma
     * const ma = await prisma.ma.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends maFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, maFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'ma'> extends True ? CheckSelect<T, Prisma__maClient<ma>, Prisma__maClient<maGetPayload<T>>> : CheckSelect<T, Prisma__maClient<ma | null >, Prisma__maClient<maGetPayload<T> | null >>

    /**
     * Find the first Ma that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {maFindFirstArgs} args - Arguments to find a Ma
     * @example
     * // Get one Ma
     * const ma = await prisma.ma.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends maFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, maFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'ma'> extends True ? CheckSelect<T, Prisma__maClient<ma>, Prisma__maClient<maGetPayload<T>>> : CheckSelect<T, Prisma__maClient<ma | null >, Prisma__maClient<maGetPayload<T> | null >>

    /**
     * Find zero or more Mas that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {maFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Mas
     * const mas = await prisma.ma.findMany()
     * 
     * // Get first 10 Mas
     * const mas = await prisma.ma.findMany({ take: 10 })
     * 
     * // Only select the `MA_id`
     * const maWithMA_idOnly = await prisma.ma.findMany({ select: { MA_id: true } })
     * 
    **/
    findMany<T extends maFindManyArgs>(
      args?: SelectSubset<T, maFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<ma>>, PrismaPromise<Array<maGetPayload<T>>>>

    /**
     * Create a Ma.
     * @param {maCreateArgs} args - Arguments to create a Ma.
     * @example
     * // Create one Ma
     * const Ma = await prisma.ma.create({
     *   data: {
     *     // ... data to create a Ma
     *   }
     * })
     * 
    **/
    create<T extends maCreateArgs>(
      args: SelectSubset<T, maCreateArgs>
    ): CheckSelect<T, Prisma__maClient<ma>, Prisma__maClient<maGetPayload<T>>>

    /**
     * Create many Mas.
     *     @param {maCreateManyArgs} args - Arguments to create many Mas.
     *     @example
     *     // Create many Mas
     *     const ma = await prisma.ma.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends maCreateManyArgs>(
      args?: SelectSubset<T, maCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Ma.
     * @param {maDeleteArgs} args - Arguments to delete one Ma.
     * @example
     * // Delete one Ma
     * const Ma = await prisma.ma.delete({
     *   where: {
     *     // ... filter to delete one Ma
     *   }
     * })
     * 
    **/
    delete<T extends maDeleteArgs>(
      args: SelectSubset<T, maDeleteArgs>
    ): CheckSelect<T, Prisma__maClient<ma>, Prisma__maClient<maGetPayload<T>>>

    /**
     * Update one Ma.
     * @param {maUpdateArgs} args - Arguments to update one Ma.
     * @example
     * // Update one Ma
     * const ma = await prisma.ma.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends maUpdateArgs>(
      args: SelectSubset<T, maUpdateArgs>
    ): CheckSelect<T, Prisma__maClient<ma>, Prisma__maClient<maGetPayload<T>>>

    /**
     * Delete zero or more Mas.
     * @param {maDeleteManyArgs} args - Arguments to filter Mas to delete.
     * @example
     * // Delete a few Mas
     * const { count } = await prisma.ma.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends maDeleteManyArgs>(
      args?: SelectSubset<T, maDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Mas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {maUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Mas
     * const ma = await prisma.ma.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends maUpdateManyArgs>(
      args: SelectSubset<T, maUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Ma.
     * @param {maUpsertArgs} args - Arguments to update or create a Ma.
     * @example
     * // Update or create a Ma
     * const ma = await prisma.ma.upsert({
     *   create: {
     *     // ... data to create a Ma
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Ma we want to update
     *   }
     * })
    **/
    upsert<T extends maUpsertArgs>(
      args: SelectSubset<T, maUpsertArgs>
    ): CheckSelect<T, Prisma__maClient<ma>, Prisma__maClient<maGetPayload<T>>>

    /**
     * Find one Ma that matches the filter or throw
     * `NotFoundError` if no matches were found.
     * @param {maFindUniqueOrThrowArgs} args - Arguments to find a Ma
     * @example
     * // Get one Ma
     * const ma = await prisma.ma.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends maFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, maFindUniqueOrThrowArgs>
    ): CheckSelect<T, Prisma__maClient<ma>, Prisma__maClient<maGetPayload<T>>>

    /**
     * Find the first Ma that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {maFindFirstOrThrowArgs} args - Arguments to find a Ma
     * @example
     * // Get one Ma
     * const ma = await prisma.ma.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends maFindFirstOrThrowArgs>(
      args?: SelectSubset<T, maFindFirstOrThrowArgs>
    ): CheckSelect<T, Prisma__maClient<ma>, Prisma__maClient<maGetPayload<T>>>

    /**
     * Count the number of Mas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {maCountArgs} args - Arguments to filter Mas to count.
     * @example
     * // Count the number of Mas
     * const count = await prisma.ma.count({
     *   where: {
     *     // ... the filter for the Mas we want to count
     *   }
     * })
    **/
    count<T extends maCountArgs>(
      args?: Subset<T, maCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MaCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Ma.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MaAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MaAggregateArgs>(args: Subset<T, MaAggregateArgs>): PrismaPromise<GetMaAggregateType<T>>

    /**
     * Group by Ma.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MaGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MaGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MaGroupByArgs['orderBy'] }
        : { orderBy?: MaGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MaGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMaGroupByPayload<T> : PrismaPromise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for ma.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__maClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * ma base type for findUnique actions
   */
  export type maFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the ma
     * 
    **/
    select?: maSelect | null
    /**
     * Filter, which ma to fetch.
     * 
    **/
    where: maWhereUniqueInput
  }

  /**
   * ma: findUnique
   */
  export interface maFindUniqueArgs extends maFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * ma base type for findFirst actions
   */
  export type maFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the ma
     * 
    **/
    select?: maSelect | null
    /**
     * Filter, which ma to fetch.
     * 
    **/
    where?: maWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of mas to fetch.
     * 
    **/
    orderBy?: Enumerable<maOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for mas.
     * 
    **/
    cursor?: maWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` mas from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` mas.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of mas.
     * 
    **/
    distinct?: Enumerable<MaScalarFieldEnum>
  }

  /**
   * ma: findFirst
   */
  export interface maFindFirstArgs extends maFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * ma findMany
   */
  export type maFindManyArgs = {
    /**
     * Select specific fields to fetch from the ma
     * 
    **/
    select?: maSelect | null
    /**
     * Filter, which mas to fetch.
     * 
    **/
    where?: maWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of mas to fetch.
     * 
    **/
    orderBy?: Enumerable<maOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing mas.
     * 
    **/
    cursor?: maWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` mas from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` mas.
     * 
    **/
    skip?: number
    distinct?: Enumerable<MaScalarFieldEnum>
  }


  /**
   * ma create
   */
  export type maCreateArgs = {
    /**
     * Select specific fields to fetch from the ma
     * 
    **/
    select?: maSelect | null
    /**
     * The data needed to create a ma.
     * 
    **/
    data: XOR<maCreateInput, maUncheckedCreateInput>
  }


  /**
   * ma createMany
   */
  export type maCreateManyArgs = {
    /**
     * The data used to create many mas.
     * 
    **/
    data: Enumerable<maCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * ma update
   */
  export type maUpdateArgs = {
    /**
     * Select specific fields to fetch from the ma
     * 
    **/
    select?: maSelect | null
    /**
     * The data needed to update a ma.
     * 
    **/
    data: XOR<maUpdateInput, maUncheckedUpdateInput>
    /**
     * Choose, which ma to update.
     * 
    **/
    where: maWhereUniqueInput
  }


  /**
   * ma updateMany
   */
  export type maUpdateManyArgs = {
    /**
     * The data used to update mas.
     * 
    **/
    data: XOR<maUpdateManyMutationInput, maUncheckedUpdateManyInput>
    /**
     * Filter which mas to update
     * 
    **/
    where?: maWhereInput
  }


  /**
   * ma upsert
   */
  export type maUpsertArgs = {
    /**
     * Select specific fields to fetch from the ma
     * 
    **/
    select?: maSelect | null
    /**
     * The filter to search for the ma to update in case it exists.
     * 
    **/
    where: maWhereUniqueInput
    /**
     * In case the ma found by the `where` argument doesn't exist, create a new ma with this data.
     * 
    **/
    create: XOR<maCreateInput, maUncheckedCreateInput>
    /**
     * In case the ma was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<maUpdateInput, maUncheckedUpdateInput>
  }


  /**
   * ma delete
   */
  export type maDeleteArgs = {
    /**
     * Select specific fields to fetch from the ma
     * 
    **/
    select?: maSelect | null
    /**
     * Filter which ma to delete.
     * 
    **/
    where: maWhereUniqueInput
  }


  /**
   * ma deleteMany
   */
  export type maDeleteManyArgs = {
    /**
     * Filter which mas to delete
     * 
    **/
    where?: maWhereInput
  }


  /**
   * ma: findUniqueOrThrow
   */
  export type maFindUniqueOrThrowArgs = maFindUniqueArgsBase
      

  /**
   * ma: findFirstOrThrow
   */
  export type maFindFirstOrThrowArgs = maFindFirstArgsBase
      

  /**
   * ma without action
   */
  export type maArgs = {
    /**
     * Select specific fields to fetch from the ma
     * 
    **/
    select?: maSelect | null
  }



  /**
   * Model mis_report
   */


  export type AggregateMis_report = {
    _count: Mis_reportCountAggregateOutputType | null
    _avg: Mis_reportAvgAggregateOutputType | null
    _sum: Mis_reportSumAggregateOutputType | null
    _min: Mis_reportMinAggregateOutputType | null
    _max: Mis_reportMaxAggregateOutputType | null
  }

  export type Mis_reportAvgAggregateOutputType = {
    mis_id: number | null
    report_id: number | null
  }

  export type Mis_reportSumAggregateOutputType = {
    mis_id: number | null
    report_id: number | null
  }

  export type Mis_reportMinAggregateOutputType = {
    mis_id: number | null
    report_id: number | null
  }

  export type Mis_reportMaxAggregateOutputType = {
    mis_id: number | null
    report_id: number | null
  }

  export type Mis_reportCountAggregateOutputType = {
    mis_id: number
    report_id: number
    _all: number
  }


  export type Mis_reportAvgAggregateInputType = {
    mis_id?: true
    report_id?: true
  }

  export type Mis_reportSumAggregateInputType = {
    mis_id?: true
    report_id?: true
  }

  export type Mis_reportMinAggregateInputType = {
    mis_id?: true
    report_id?: true
  }

  export type Mis_reportMaxAggregateInputType = {
    mis_id?: true
    report_id?: true
  }

  export type Mis_reportCountAggregateInputType = {
    mis_id?: true
    report_id?: true
    _all?: true
  }

  export type Mis_reportAggregateArgs = {
    /**
     * Filter which mis_report to aggregate.
     * 
    **/
    where?: mis_reportWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of mis_reports to fetch.
     * 
    **/
    orderBy?: Enumerable<mis_reportOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: mis_reportWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` mis_reports from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` mis_reports.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned mis_reports
    **/
    _count?: true | Mis_reportCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Mis_reportAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Mis_reportSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Mis_reportMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Mis_reportMaxAggregateInputType
  }

  export type GetMis_reportAggregateType<T extends Mis_reportAggregateArgs> = {
        [P in keyof T & keyof AggregateMis_report]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMis_report[P]>
      : GetScalarType<T[P], AggregateMis_report[P]>
  }




  export type Mis_reportGroupByArgs = {
    where?: mis_reportWhereInput
    orderBy?: Enumerable<mis_reportOrderByWithAggregationInput>
    by: Array<Mis_reportScalarFieldEnum>
    having?: mis_reportScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Mis_reportCountAggregateInputType | true
    _avg?: Mis_reportAvgAggregateInputType
    _sum?: Mis_reportSumAggregateInputType
    _min?: Mis_reportMinAggregateInputType
    _max?: Mis_reportMaxAggregateInputType
  }


  export type Mis_reportGroupByOutputType = {
    mis_id: number
    report_id: number
    _count: Mis_reportCountAggregateOutputType | null
    _avg: Mis_reportAvgAggregateOutputType | null
    _sum: Mis_reportSumAggregateOutputType | null
    _min: Mis_reportMinAggregateOutputType | null
    _max: Mis_reportMaxAggregateOutputType | null
  }

  type GetMis_reportGroupByPayload<T extends Mis_reportGroupByArgs> = PrismaPromise<
    Array<
      PickArray<Mis_reportGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Mis_reportGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Mis_reportGroupByOutputType[P]>
            : GetScalarType<T[P], Mis_reportGroupByOutputType[P]>
        }
      >
    >


  export type mis_reportSelect = {
    mis_id?: boolean
    report_id?: boolean
  }

  export type mis_reportGetPayload<
    S extends boolean | null | undefined | mis_reportArgs,
    U = keyof S
      > = S extends true
        ? mis_report
    : S extends undefined
    ? never
    : S extends mis_reportArgs | mis_reportFindManyArgs
    ?'include' extends U
    ? mis_report 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
    P extends keyof mis_report ? mis_report[P] : never
  } 
    : mis_report
  : mis_report


  type mis_reportCountArgs = Merge<
    Omit<mis_reportFindManyArgs, 'select' | 'include'> & {
      select?: Mis_reportCountAggregateInputType | true
    }
  >

  export interface mis_reportDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one Mis_report that matches the filter.
     * @param {mis_reportFindUniqueArgs} args - Arguments to find a Mis_report
     * @example
     * // Get one Mis_report
     * const mis_report = await prisma.mis_report.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends mis_reportFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, mis_reportFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'mis_report'> extends True ? CheckSelect<T, Prisma__mis_reportClient<mis_report>, Prisma__mis_reportClient<mis_reportGetPayload<T>>> : CheckSelect<T, Prisma__mis_reportClient<mis_report | null >, Prisma__mis_reportClient<mis_reportGetPayload<T> | null >>

    /**
     * Find the first Mis_report that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {mis_reportFindFirstArgs} args - Arguments to find a Mis_report
     * @example
     * // Get one Mis_report
     * const mis_report = await prisma.mis_report.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends mis_reportFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, mis_reportFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'mis_report'> extends True ? CheckSelect<T, Prisma__mis_reportClient<mis_report>, Prisma__mis_reportClient<mis_reportGetPayload<T>>> : CheckSelect<T, Prisma__mis_reportClient<mis_report | null >, Prisma__mis_reportClient<mis_reportGetPayload<T> | null >>

    /**
     * Find zero or more Mis_reports that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {mis_reportFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Mis_reports
     * const mis_reports = await prisma.mis_report.findMany()
     * 
     * // Get first 10 Mis_reports
     * const mis_reports = await prisma.mis_report.findMany({ take: 10 })
     * 
     * // Only select the `mis_id`
     * const mis_reportWithMis_idOnly = await prisma.mis_report.findMany({ select: { mis_id: true } })
     * 
    **/
    findMany<T extends mis_reportFindManyArgs>(
      args?: SelectSubset<T, mis_reportFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<mis_report>>, PrismaPromise<Array<mis_reportGetPayload<T>>>>

    /**
     * Create a Mis_report.
     * @param {mis_reportCreateArgs} args - Arguments to create a Mis_report.
     * @example
     * // Create one Mis_report
     * const Mis_report = await prisma.mis_report.create({
     *   data: {
     *     // ... data to create a Mis_report
     *   }
     * })
     * 
    **/
    create<T extends mis_reportCreateArgs>(
      args: SelectSubset<T, mis_reportCreateArgs>
    ): CheckSelect<T, Prisma__mis_reportClient<mis_report>, Prisma__mis_reportClient<mis_reportGetPayload<T>>>

    /**
     * Create many Mis_reports.
     *     @param {mis_reportCreateManyArgs} args - Arguments to create many Mis_reports.
     *     @example
     *     // Create many Mis_reports
     *     const mis_report = await prisma.mis_report.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends mis_reportCreateManyArgs>(
      args?: SelectSubset<T, mis_reportCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Mis_report.
     * @param {mis_reportDeleteArgs} args - Arguments to delete one Mis_report.
     * @example
     * // Delete one Mis_report
     * const Mis_report = await prisma.mis_report.delete({
     *   where: {
     *     // ... filter to delete one Mis_report
     *   }
     * })
     * 
    **/
    delete<T extends mis_reportDeleteArgs>(
      args: SelectSubset<T, mis_reportDeleteArgs>
    ): CheckSelect<T, Prisma__mis_reportClient<mis_report>, Prisma__mis_reportClient<mis_reportGetPayload<T>>>

    /**
     * Update one Mis_report.
     * @param {mis_reportUpdateArgs} args - Arguments to update one Mis_report.
     * @example
     * // Update one Mis_report
     * const mis_report = await prisma.mis_report.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends mis_reportUpdateArgs>(
      args: SelectSubset<T, mis_reportUpdateArgs>
    ): CheckSelect<T, Prisma__mis_reportClient<mis_report>, Prisma__mis_reportClient<mis_reportGetPayload<T>>>

    /**
     * Delete zero or more Mis_reports.
     * @param {mis_reportDeleteManyArgs} args - Arguments to filter Mis_reports to delete.
     * @example
     * // Delete a few Mis_reports
     * const { count } = await prisma.mis_report.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends mis_reportDeleteManyArgs>(
      args?: SelectSubset<T, mis_reportDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Mis_reports.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {mis_reportUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Mis_reports
     * const mis_report = await prisma.mis_report.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends mis_reportUpdateManyArgs>(
      args: SelectSubset<T, mis_reportUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Mis_report.
     * @param {mis_reportUpsertArgs} args - Arguments to update or create a Mis_report.
     * @example
     * // Update or create a Mis_report
     * const mis_report = await prisma.mis_report.upsert({
     *   create: {
     *     // ... data to create a Mis_report
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Mis_report we want to update
     *   }
     * })
    **/
    upsert<T extends mis_reportUpsertArgs>(
      args: SelectSubset<T, mis_reportUpsertArgs>
    ): CheckSelect<T, Prisma__mis_reportClient<mis_report>, Prisma__mis_reportClient<mis_reportGetPayload<T>>>

    /**
     * Find one Mis_report that matches the filter or throw
     * `NotFoundError` if no matches were found.
     * @param {mis_reportFindUniqueOrThrowArgs} args - Arguments to find a Mis_report
     * @example
     * // Get one Mis_report
     * const mis_report = await prisma.mis_report.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends mis_reportFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, mis_reportFindUniqueOrThrowArgs>
    ): CheckSelect<T, Prisma__mis_reportClient<mis_report>, Prisma__mis_reportClient<mis_reportGetPayload<T>>>

    /**
     * Find the first Mis_report that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {mis_reportFindFirstOrThrowArgs} args - Arguments to find a Mis_report
     * @example
     * // Get one Mis_report
     * const mis_report = await prisma.mis_report.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends mis_reportFindFirstOrThrowArgs>(
      args?: SelectSubset<T, mis_reportFindFirstOrThrowArgs>
    ): CheckSelect<T, Prisma__mis_reportClient<mis_report>, Prisma__mis_reportClient<mis_reportGetPayload<T>>>

    /**
     * Count the number of Mis_reports.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {mis_reportCountArgs} args - Arguments to filter Mis_reports to count.
     * @example
     * // Count the number of Mis_reports
     * const count = await prisma.mis_report.count({
     *   where: {
     *     // ... the filter for the Mis_reports we want to count
     *   }
     * })
    **/
    count<T extends mis_reportCountArgs>(
      args?: Subset<T, mis_reportCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Mis_reportCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Mis_report.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Mis_reportAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Mis_reportAggregateArgs>(args: Subset<T, Mis_reportAggregateArgs>): PrismaPromise<GetMis_reportAggregateType<T>>

    /**
     * Group by Mis_report.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Mis_reportGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends Mis_reportGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: Mis_reportGroupByArgs['orderBy'] }
        : { orderBy?: Mis_reportGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, Mis_reportGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMis_reportGroupByPayload<T> : PrismaPromise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for mis_report.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__mis_reportClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * mis_report base type for findUnique actions
   */
  export type mis_reportFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the mis_report
     * 
    **/
    select?: mis_reportSelect | null
    /**
     * Filter, which mis_report to fetch.
     * 
    **/
    where: mis_reportWhereUniqueInput
  }

  /**
   * mis_report: findUnique
   */
  export interface mis_reportFindUniqueArgs extends mis_reportFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * mis_report base type for findFirst actions
   */
  export type mis_reportFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the mis_report
     * 
    **/
    select?: mis_reportSelect | null
    /**
     * Filter, which mis_report to fetch.
     * 
    **/
    where?: mis_reportWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of mis_reports to fetch.
     * 
    **/
    orderBy?: Enumerable<mis_reportOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for mis_reports.
     * 
    **/
    cursor?: mis_reportWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` mis_reports from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` mis_reports.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of mis_reports.
     * 
    **/
    distinct?: Enumerable<Mis_reportScalarFieldEnum>
  }

  /**
   * mis_report: findFirst
   */
  export interface mis_reportFindFirstArgs extends mis_reportFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * mis_report findMany
   */
  export type mis_reportFindManyArgs = {
    /**
     * Select specific fields to fetch from the mis_report
     * 
    **/
    select?: mis_reportSelect | null
    /**
     * Filter, which mis_reports to fetch.
     * 
    **/
    where?: mis_reportWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of mis_reports to fetch.
     * 
    **/
    orderBy?: Enumerable<mis_reportOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing mis_reports.
     * 
    **/
    cursor?: mis_reportWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` mis_reports from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` mis_reports.
     * 
    **/
    skip?: number
    distinct?: Enumerable<Mis_reportScalarFieldEnum>
  }


  /**
   * mis_report create
   */
  export type mis_reportCreateArgs = {
    /**
     * Select specific fields to fetch from the mis_report
     * 
    **/
    select?: mis_reportSelect | null
    /**
     * The data needed to create a mis_report.
     * 
    **/
    data: XOR<mis_reportCreateInput, mis_reportUncheckedCreateInput>
  }


  /**
   * mis_report createMany
   */
  export type mis_reportCreateManyArgs = {
    /**
     * The data used to create many mis_reports.
     * 
    **/
    data: Enumerable<mis_reportCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * mis_report update
   */
  export type mis_reportUpdateArgs = {
    /**
     * Select specific fields to fetch from the mis_report
     * 
    **/
    select?: mis_reportSelect | null
    /**
     * The data needed to update a mis_report.
     * 
    **/
    data: XOR<mis_reportUpdateInput, mis_reportUncheckedUpdateInput>
    /**
     * Choose, which mis_report to update.
     * 
    **/
    where: mis_reportWhereUniqueInput
  }


  /**
   * mis_report updateMany
   */
  export type mis_reportUpdateManyArgs = {
    /**
     * The data used to update mis_reports.
     * 
    **/
    data: XOR<mis_reportUpdateManyMutationInput, mis_reportUncheckedUpdateManyInput>
    /**
     * Filter which mis_reports to update
     * 
    **/
    where?: mis_reportWhereInput
  }


  /**
   * mis_report upsert
   */
  export type mis_reportUpsertArgs = {
    /**
     * Select specific fields to fetch from the mis_report
     * 
    **/
    select?: mis_reportSelect | null
    /**
     * The filter to search for the mis_report to update in case it exists.
     * 
    **/
    where: mis_reportWhereUniqueInput
    /**
     * In case the mis_report found by the `where` argument doesn't exist, create a new mis_report with this data.
     * 
    **/
    create: XOR<mis_reportCreateInput, mis_reportUncheckedCreateInput>
    /**
     * In case the mis_report was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<mis_reportUpdateInput, mis_reportUncheckedUpdateInput>
  }


  /**
   * mis_report delete
   */
  export type mis_reportDeleteArgs = {
    /**
     * Select specific fields to fetch from the mis_report
     * 
    **/
    select?: mis_reportSelect | null
    /**
     * Filter which mis_report to delete.
     * 
    **/
    where: mis_reportWhereUniqueInput
  }


  /**
   * mis_report deleteMany
   */
  export type mis_reportDeleteManyArgs = {
    /**
     * Filter which mis_reports to delete
     * 
    **/
    where?: mis_reportWhereInput
  }


  /**
   * mis_report: findUniqueOrThrow
   */
  export type mis_reportFindUniqueOrThrowArgs = mis_reportFindUniqueArgsBase
      

  /**
   * mis_report: findFirstOrThrow
   */
  export type mis_reportFindFirstOrThrowArgs = mis_reportFindFirstArgsBase
      

  /**
   * mis_report without action
   */
  export type mis_reportArgs = {
    /**
     * Select specific fields to fetch from the mis_report
     * 
    **/
    select?: mis_reportSelect | null
  }



  /**
   * Model paper_marks
   */


  export type AggregatePaper_marks = {
    _count: Paper_marksCountAggregateOutputType | null
    _avg: Paper_marksAvgAggregateOutputType | null
    _sum: Paper_marksSumAggregateOutputType | null
    _min: Paper_marksMinAggregateOutputType | null
    _max: Paper_marksMaxAggregateOutputType | null
  }

  export type Paper_marksAvgAggregateOutputType = {
    paper_id: number | null
    sub_marks: number | null
    total_marks: number | null
    paper_precentage: number | null
    mark_id: number | null
  }

  export type Paper_marksSumAggregateOutputType = {
    paper_id: number | null
    sub_marks: number | null
    total_marks: number | null
    paper_precentage: number | null
    mark_id: number | null
  }

  export type Paper_marksMinAggregateOutputType = {
    paper_id: number | null
    sub_marks: number | null
    total_marks: number | null
    paper_precentage: number | null
    mark_id: number | null
  }

  export type Paper_marksMaxAggregateOutputType = {
    paper_id: number | null
    sub_marks: number | null
    total_marks: number | null
    paper_precentage: number | null
    mark_id: number | null
  }

  export type Paper_marksCountAggregateOutputType = {
    paper_id: number
    sub_marks: number
    total_marks: number
    paper_precentage: number
    mark_id: number
    _all: number
  }


  export type Paper_marksAvgAggregateInputType = {
    paper_id?: true
    sub_marks?: true
    total_marks?: true
    paper_precentage?: true
    mark_id?: true
  }

  export type Paper_marksSumAggregateInputType = {
    paper_id?: true
    sub_marks?: true
    total_marks?: true
    paper_precentage?: true
    mark_id?: true
  }

  export type Paper_marksMinAggregateInputType = {
    paper_id?: true
    sub_marks?: true
    total_marks?: true
    paper_precentage?: true
    mark_id?: true
  }

  export type Paper_marksMaxAggregateInputType = {
    paper_id?: true
    sub_marks?: true
    total_marks?: true
    paper_precentage?: true
    mark_id?: true
  }

  export type Paper_marksCountAggregateInputType = {
    paper_id?: true
    sub_marks?: true
    total_marks?: true
    paper_precentage?: true
    mark_id?: true
    _all?: true
  }

  export type Paper_marksAggregateArgs = {
    /**
     * Filter which paper_marks to aggregate.
     * 
    **/
    where?: paper_marksWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of paper_marks to fetch.
     * 
    **/
    orderBy?: Enumerable<paper_marksOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: paper_marksWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` paper_marks from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` paper_marks.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned paper_marks
    **/
    _count?: true | Paper_marksCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Paper_marksAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Paper_marksSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Paper_marksMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Paper_marksMaxAggregateInputType
  }

  export type GetPaper_marksAggregateType<T extends Paper_marksAggregateArgs> = {
        [P in keyof T & keyof AggregatePaper_marks]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePaper_marks[P]>
      : GetScalarType<T[P], AggregatePaper_marks[P]>
  }




  export type Paper_marksGroupByArgs = {
    where?: paper_marksWhereInput
    orderBy?: Enumerable<paper_marksOrderByWithAggregationInput>
    by: Array<Paper_marksScalarFieldEnum>
    having?: paper_marksScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Paper_marksCountAggregateInputType | true
    _avg?: Paper_marksAvgAggregateInputType
    _sum?: Paper_marksSumAggregateInputType
    _min?: Paper_marksMinAggregateInputType
    _max?: Paper_marksMaxAggregateInputType
  }


  export type Paper_marksGroupByOutputType = {
    paper_id: number
    sub_marks: number
    total_marks: number
    paper_precentage: number
    mark_id: number
    _count: Paper_marksCountAggregateOutputType | null
    _avg: Paper_marksAvgAggregateOutputType | null
    _sum: Paper_marksSumAggregateOutputType | null
    _min: Paper_marksMinAggregateOutputType | null
    _max: Paper_marksMaxAggregateOutputType | null
  }

  type GetPaper_marksGroupByPayload<T extends Paper_marksGroupByArgs> = PrismaPromise<
    Array<
      PickArray<Paper_marksGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Paper_marksGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Paper_marksGroupByOutputType[P]>
            : GetScalarType<T[P], Paper_marksGroupByOutputType[P]>
        }
      >
    >


  export type paper_marksSelect = {
    paper_id?: boolean
    sub_marks?: boolean
    total_marks?: boolean
    paper_precentage?: boolean
    mark_id?: boolean
  }

  export type paper_marksGetPayload<
    S extends boolean | null | undefined | paper_marksArgs,
    U = keyof S
      > = S extends true
        ? paper_marks
    : S extends undefined
    ? never
    : S extends paper_marksArgs | paper_marksFindManyArgs
    ?'include' extends U
    ? paper_marks 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
    P extends keyof paper_marks ? paper_marks[P] : never
  } 
    : paper_marks
  : paper_marks


  type paper_marksCountArgs = Merge<
    Omit<paper_marksFindManyArgs, 'select' | 'include'> & {
      select?: Paper_marksCountAggregateInputType | true
    }
  >

  export interface paper_marksDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one Paper_marks that matches the filter.
     * @param {paper_marksFindUniqueArgs} args - Arguments to find a Paper_marks
     * @example
     * // Get one Paper_marks
     * const paper_marks = await prisma.paper_marks.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends paper_marksFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, paper_marksFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'paper_marks'> extends True ? CheckSelect<T, Prisma__paper_marksClient<paper_marks>, Prisma__paper_marksClient<paper_marksGetPayload<T>>> : CheckSelect<T, Prisma__paper_marksClient<paper_marks | null >, Prisma__paper_marksClient<paper_marksGetPayload<T> | null >>

    /**
     * Find the first Paper_marks that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {paper_marksFindFirstArgs} args - Arguments to find a Paper_marks
     * @example
     * // Get one Paper_marks
     * const paper_marks = await prisma.paper_marks.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends paper_marksFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, paper_marksFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'paper_marks'> extends True ? CheckSelect<T, Prisma__paper_marksClient<paper_marks>, Prisma__paper_marksClient<paper_marksGetPayload<T>>> : CheckSelect<T, Prisma__paper_marksClient<paper_marks | null >, Prisma__paper_marksClient<paper_marksGetPayload<T> | null >>

    /**
     * Find zero or more Paper_marks that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {paper_marksFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Paper_marks
     * const paper_marks = await prisma.paper_marks.findMany()
     * 
     * // Get first 10 Paper_marks
     * const paper_marks = await prisma.paper_marks.findMany({ take: 10 })
     * 
     * // Only select the `paper_id`
     * const paper_marksWithPaper_idOnly = await prisma.paper_marks.findMany({ select: { paper_id: true } })
     * 
    **/
    findMany<T extends paper_marksFindManyArgs>(
      args?: SelectSubset<T, paper_marksFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<paper_marks>>, PrismaPromise<Array<paper_marksGetPayload<T>>>>

    /**
     * Create a Paper_marks.
     * @param {paper_marksCreateArgs} args - Arguments to create a Paper_marks.
     * @example
     * // Create one Paper_marks
     * const Paper_marks = await prisma.paper_marks.create({
     *   data: {
     *     // ... data to create a Paper_marks
     *   }
     * })
     * 
    **/
    create<T extends paper_marksCreateArgs>(
      args: SelectSubset<T, paper_marksCreateArgs>
    ): CheckSelect<T, Prisma__paper_marksClient<paper_marks>, Prisma__paper_marksClient<paper_marksGetPayload<T>>>

    /**
     * Create many Paper_marks.
     *     @param {paper_marksCreateManyArgs} args - Arguments to create many Paper_marks.
     *     @example
     *     // Create many Paper_marks
     *     const paper_marks = await prisma.paper_marks.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends paper_marksCreateManyArgs>(
      args?: SelectSubset<T, paper_marksCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Paper_marks.
     * @param {paper_marksDeleteArgs} args - Arguments to delete one Paper_marks.
     * @example
     * // Delete one Paper_marks
     * const Paper_marks = await prisma.paper_marks.delete({
     *   where: {
     *     // ... filter to delete one Paper_marks
     *   }
     * })
     * 
    **/
    delete<T extends paper_marksDeleteArgs>(
      args: SelectSubset<T, paper_marksDeleteArgs>
    ): CheckSelect<T, Prisma__paper_marksClient<paper_marks>, Prisma__paper_marksClient<paper_marksGetPayload<T>>>

    /**
     * Update one Paper_marks.
     * @param {paper_marksUpdateArgs} args - Arguments to update one Paper_marks.
     * @example
     * // Update one Paper_marks
     * const paper_marks = await prisma.paper_marks.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends paper_marksUpdateArgs>(
      args: SelectSubset<T, paper_marksUpdateArgs>
    ): CheckSelect<T, Prisma__paper_marksClient<paper_marks>, Prisma__paper_marksClient<paper_marksGetPayload<T>>>

    /**
     * Delete zero or more Paper_marks.
     * @param {paper_marksDeleteManyArgs} args - Arguments to filter Paper_marks to delete.
     * @example
     * // Delete a few Paper_marks
     * const { count } = await prisma.paper_marks.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends paper_marksDeleteManyArgs>(
      args?: SelectSubset<T, paper_marksDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Paper_marks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {paper_marksUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Paper_marks
     * const paper_marks = await prisma.paper_marks.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends paper_marksUpdateManyArgs>(
      args: SelectSubset<T, paper_marksUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Paper_marks.
     * @param {paper_marksUpsertArgs} args - Arguments to update or create a Paper_marks.
     * @example
     * // Update or create a Paper_marks
     * const paper_marks = await prisma.paper_marks.upsert({
     *   create: {
     *     // ... data to create a Paper_marks
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Paper_marks we want to update
     *   }
     * })
    **/
    upsert<T extends paper_marksUpsertArgs>(
      args: SelectSubset<T, paper_marksUpsertArgs>
    ): CheckSelect<T, Prisma__paper_marksClient<paper_marks>, Prisma__paper_marksClient<paper_marksGetPayload<T>>>

    /**
     * Find one Paper_marks that matches the filter or throw
     * `NotFoundError` if no matches were found.
     * @param {paper_marksFindUniqueOrThrowArgs} args - Arguments to find a Paper_marks
     * @example
     * // Get one Paper_marks
     * const paper_marks = await prisma.paper_marks.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends paper_marksFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, paper_marksFindUniqueOrThrowArgs>
    ): CheckSelect<T, Prisma__paper_marksClient<paper_marks>, Prisma__paper_marksClient<paper_marksGetPayload<T>>>

    /**
     * Find the first Paper_marks that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {paper_marksFindFirstOrThrowArgs} args - Arguments to find a Paper_marks
     * @example
     * // Get one Paper_marks
     * const paper_marks = await prisma.paper_marks.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends paper_marksFindFirstOrThrowArgs>(
      args?: SelectSubset<T, paper_marksFindFirstOrThrowArgs>
    ): CheckSelect<T, Prisma__paper_marksClient<paper_marks>, Prisma__paper_marksClient<paper_marksGetPayload<T>>>

    /**
     * Count the number of Paper_marks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {paper_marksCountArgs} args - Arguments to filter Paper_marks to count.
     * @example
     * // Count the number of Paper_marks
     * const count = await prisma.paper_marks.count({
     *   where: {
     *     // ... the filter for the Paper_marks we want to count
     *   }
     * })
    **/
    count<T extends paper_marksCountArgs>(
      args?: Subset<T, paper_marksCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Paper_marksCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Paper_marks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Paper_marksAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Paper_marksAggregateArgs>(args: Subset<T, Paper_marksAggregateArgs>): PrismaPromise<GetPaper_marksAggregateType<T>>

    /**
     * Group by Paper_marks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Paper_marksGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends Paper_marksGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: Paper_marksGroupByArgs['orderBy'] }
        : { orderBy?: Paper_marksGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, Paper_marksGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPaper_marksGroupByPayload<T> : PrismaPromise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for paper_marks.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__paper_marksClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * paper_marks base type for findUnique actions
   */
  export type paper_marksFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the paper_marks
     * 
    **/
    select?: paper_marksSelect | null
    /**
     * Filter, which paper_marks to fetch.
     * 
    **/
    where: paper_marksWhereUniqueInput
  }

  /**
   * paper_marks: findUnique
   */
  export interface paper_marksFindUniqueArgs extends paper_marksFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * paper_marks base type for findFirst actions
   */
  export type paper_marksFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the paper_marks
     * 
    **/
    select?: paper_marksSelect | null
    /**
     * Filter, which paper_marks to fetch.
     * 
    **/
    where?: paper_marksWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of paper_marks to fetch.
     * 
    **/
    orderBy?: Enumerable<paper_marksOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for paper_marks.
     * 
    **/
    cursor?: paper_marksWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` paper_marks from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` paper_marks.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of paper_marks.
     * 
    **/
    distinct?: Enumerable<Paper_marksScalarFieldEnum>
  }

  /**
   * paper_marks: findFirst
   */
  export interface paper_marksFindFirstArgs extends paper_marksFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * paper_marks findMany
   */
  export type paper_marksFindManyArgs = {
    /**
     * Select specific fields to fetch from the paper_marks
     * 
    **/
    select?: paper_marksSelect | null
    /**
     * Filter, which paper_marks to fetch.
     * 
    **/
    where?: paper_marksWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of paper_marks to fetch.
     * 
    **/
    orderBy?: Enumerable<paper_marksOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing paper_marks.
     * 
    **/
    cursor?: paper_marksWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` paper_marks from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` paper_marks.
     * 
    **/
    skip?: number
    distinct?: Enumerable<Paper_marksScalarFieldEnum>
  }


  /**
   * paper_marks create
   */
  export type paper_marksCreateArgs = {
    /**
     * Select specific fields to fetch from the paper_marks
     * 
    **/
    select?: paper_marksSelect | null
    /**
     * The data needed to create a paper_marks.
     * 
    **/
    data: XOR<paper_marksCreateInput, paper_marksUncheckedCreateInput>
  }


  /**
   * paper_marks createMany
   */
  export type paper_marksCreateManyArgs = {
    /**
     * The data used to create many paper_marks.
     * 
    **/
    data: Enumerable<paper_marksCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * paper_marks update
   */
  export type paper_marksUpdateArgs = {
    /**
     * Select specific fields to fetch from the paper_marks
     * 
    **/
    select?: paper_marksSelect | null
    /**
     * The data needed to update a paper_marks.
     * 
    **/
    data: XOR<paper_marksUpdateInput, paper_marksUncheckedUpdateInput>
    /**
     * Choose, which paper_marks to update.
     * 
    **/
    where: paper_marksWhereUniqueInput
  }


  /**
   * paper_marks updateMany
   */
  export type paper_marksUpdateManyArgs = {
    /**
     * The data used to update paper_marks.
     * 
    **/
    data: XOR<paper_marksUpdateManyMutationInput, paper_marksUncheckedUpdateManyInput>
    /**
     * Filter which paper_marks to update
     * 
    **/
    where?: paper_marksWhereInput
  }


  /**
   * paper_marks upsert
   */
  export type paper_marksUpsertArgs = {
    /**
     * Select specific fields to fetch from the paper_marks
     * 
    **/
    select?: paper_marksSelect | null
    /**
     * The filter to search for the paper_marks to update in case it exists.
     * 
    **/
    where: paper_marksWhereUniqueInput
    /**
     * In case the paper_marks found by the `where` argument doesn't exist, create a new paper_marks with this data.
     * 
    **/
    create: XOR<paper_marksCreateInput, paper_marksUncheckedCreateInput>
    /**
     * In case the paper_marks was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<paper_marksUpdateInput, paper_marksUncheckedUpdateInput>
  }


  /**
   * paper_marks delete
   */
  export type paper_marksDeleteArgs = {
    /**
     * Select specific fields to fetch from the paper_marks
     * 
    **/
    select?: paper_marksSelect | null
    /**
     * Filter which paper_marks to delete.
     * 
    **/
    where: paper_marksWhereUniqueInput
  }


  /**
   * paper_marks deleteMany
   */
  export type paper_marksDeleteManyArgs = {
    /**
     * Filter which paper_marks to delete
     * 
    **/
    where?: paper_marksWhereInput
  }


  /**
   * paper_marks: findUniqueOrThrow
   */
  export type paper_marksFindUniqueOrThrowArgs = paper_marksFindUniqueArgsBase
      

  /**
   * paper_marks: findFirstOrThrow
   */
  export type paper_marksFindFirstOrThrowArgs = paper_marksFindFirstArgsBase
      

  /**
   * paper_marks without action
   */
  export type paper_marksArgs = {
    /**
     * Select specific fields to fetch from the paper_marks
     * 
    **/
    select?: paper_marksSelect | null
  }



  /**
   * Model paper_question
   */


  export type AggregatePaper_question = {
    _count: Paper_questionCountAggregateOutputType | null
    _avg: Paper_questionAvgAggregateOutputType | null
    _sum: Paper_questionSumAggregateOutputType | null
    _min: Paper_questionMinAggregateOutputType | null
    _max: Paper_questionMaxAggregateOutputType | null
  }

  export type Paper_questionAvgAggregateOutputType = {
    exam_paper_id: number | null
    question_no: number | null
    exam_sem_id: number | null
  }

  export type Paper_questionSumAggregateOutputType = {
    exam_paper_id: number | null
    question_no: number | null
    exam_sem_id: number | null
  }

  export type Paper_questionMinAggregateOutputType = {
    exam_paper_id: number | null
    course_code: string | null
    course_name: string | null
    question_no: number | null
    exam_sem_id: number | null
  }

  export type Paper_questionMaxAggregateOutputType = {
    exam_paper_id: number | null
    course_code: string | null
    course_name: string | null
    question_no: number | null
    exam_sem_id: number | null
  }

  export type Paper_questionCountAggregateOutputType = {
    exam_paper_id: number
    course_code: number
    course_name: number
    question_no: number
    exam_sem_id: number
    _all: number
  }


  export type Paper_questionAvgAggregateInputType = {
    exam_paper_id?: true
    question_no?: true
    exam_sem_id?: true
  }

  export type Paper_questionSumAggregateInputType = {
    exam_paper_id?: true
    question_no?: true
    exam_sem_id?: true
  }

  export type Paper_questionMinAggregateInputType = {
    exam_paper_id?: true
    course_code?: true
    course_name?: true
    question_no?: true
    exam_sem_id?: true
  }

  export type Paper_questionMaxAggregateInputType = {
    exam_paper_id?: true
    course_code?: true
    course_name?: true
    question_no?: true
    exam_sem_id?: true
  }

  export type Paper_questionCountAggregateInputType = {
    exam_paper_id?: true
    course_code?: true
    course_name?: true
    question_no?: true
    exam_sem_id?: true
    _all?: true
  }

  export type Paper_questionAggregateArgs = {
    /**
     * Filter which paper_question to aggregate.
     * 
    **/
    where?: paper_questionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of paper_questions to fetch.
     * 
    **/
    orderBy?: Enumerable<paper_questionOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: paper_questionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` paper_questions from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` paper_questions.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned paper_questions
    **/
    _count?: true | Paper_questionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Paper_questionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Paper_questionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Paper_questionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Paper_questionMaxAggregateInputType
  }

  export type GetPaper_questionAggregateType<T extends Paper_questionAggregateArgs> = {
        [P in keyof T & keyof AggregatePaper_question]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePaper_question[P]>
      : GetScalarType<T[P], AggregatePaper_question[P]>
  }




  export type Paper_questionGroupByArgs = {
    where?: paper_questionWhereInput
    orderBy?: Enumerable<paper_questionOrderByWithAggregationInput>
    by: Array<Paper_questionScalarFieldEnum>
    having?: paper_questionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Paper_questionCountAggregateInputType | true
    _avg?: Paper_questionAvgAggregateInputType
    _sum?: Paper_questionSumAggregateInputType
    _min?: Paper_questionMinAggregateInputType
    _max?: Paper_questionMaxAggregateInputType
  }


  export type Paper_questionGroupByOutputType = {
    exam_paper_id: number
    course_code: string
    course_name: string
    question_no: number
    exam_sem_id: number
    _count: Paper_questionCountAggregateOutputType | null
    _avg: Paper_questionAvgAggregateOutputType | null
    _sum: Paper_questionSumAggregateOutputType | null
    _min: Paper_questionMinAggregateOutputType | null
    _max: Paper_questionMaxAggregateOutputType | null
  }

  type GetPaper_questionGroupByPayload<T extends Paper_questionGroupByArgs> = PrismaPromise<
    Array<
      PickArray<Paper_questionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Paper_questionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Paper_questionGroupByOutputType[P]>
            : GetScalarType<T[P], Paper_questionGroupByOutputType[P]>
        }
      >
    >


  export type paper_questionSelect = {
    exam_paper_id?: boolean
    course_code?: boolean
    course_name?: boolean
    question_no?: boolean
    exam_sem_id?: boolean
  }

  export type paper_questionGetPayload<
    S extends boolean | null | undefined | paper_questionArgs,
    U = keyof S
      > = S extends true
        ? paper_question
    : S extends undefined
    ? never
    : S extends paper_questionArgs | paper_questionFindManyArgs
    ?'include' extends U
    ? paper_question 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
    P extends keyof paper_question ? paper_question[P] : never
  } 
    : paper_question
  : paper_question


  type paper_questionCountArgs = Merge<
    Omit<paper_questionFindManyArgs, 'select' | 'include'> & {
      select?: Paper_questionCountAggregateInputType | true
    }
  >

  export interface paper_questionDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one Paper_question that matches the filter.
     * @param {paper_questionFindUniqueArgs} args - Arguments to find a Paper_question
     * @example
     * // Get one Paper_question
     * const paper_question = await prisma.paper_question.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends paper_questionFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, paper_questionFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'paper_question'> extends True ? CheckSelect<T, Prisma__paper_questionClient<paper_question>, Prisma__paper_questionClient<paper_questionGetPayload<T>>> : CheckSelect<T, Prisma__paper_questionClient<paper_question | null >, Prisma__paper_questionClient<paper_questionGetPayload<T> | null >>

    /**
     * Find the first Paper_question that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {paper_questionFindFirstArgs} args - Arguments to find a Paper_question
     * @example
     * // Get one Paper_question
     * const paper_question = await prisma.paper_question.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends paper_questionFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, paper_questionFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'paper_question'> extends True ? CheckSelect<T, Prisma__paper_questionClient<paper_question>, Prisma__paper_questionClient<paper_questionGetPayload<T>>> : CheckSelect<T, Prisma__paper_questionClient<paper_question | null >, Prisma__paper_questionClient<paper_questionGetPayload<T> | null >>

    /**
     * Find zero or more Paper_questions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {paper_questionFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Paper_questions
     * const paper_questions = await prisma.paper_question.findMany()
     * 
     * // Get first 10 Paper_questions
     * const paper_questions = await prisma.paper_question.findMany({ take: 10 })
     * 
     * // Only select the `exam_paper_id`
     * const paper_questionWithExam_paper_idOnly = await prisma.paper_question.findMany({ select: { exam_paper_id: true } })
     * 
    **/
    findMany<T extends paper_questionFindManyArgs>(
      args?: SelectSubset<T, paper_questionFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<paper_question>>, PrismaPromise<Array<paper_questionGetPayload<T>>>>

    /**
     * Create a Paper_question.
     * @param {paper_questionCreateArgs} args - Arguments to create a Paper_question.
     * @example
     * // Create one Paper_question
     * const Paper_question = await prisma.paper_question.create({
     *   data: {
     *     // ... data to create a Paper_question
     *   }
     * })
     * 
    **/
    create<T extends paper_questionCreateArgs>(
      args: SelectSubset<T, paper_questionCreateArgs>
    ): CheckSelect<T, Prisma__paper_questionClient<paper_question>, Prisma__paper_questionClient<paper_questionGetPayload<T>>>

    /**
     * Create many Paper_questions.
     *     @param {paper_questionCreateManyArgs} args - Arguments to create many Paper_questions.
     *     @example
     *     // Create many Paper_questions
     *     const paper_question = await prisma.paper_question.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends paper_questionCreateManyArgs>(
      args?: SelectSubset<T, paper_questionCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Paper_question.
     * @param {paper_questionDeleteArgs} args - Arguments to delete one Paper_question.
     * @example
     * // Delete one Paper_question
     * const Paper_question = await prisma.paper_question.delete({
     *   where: {
     *     // ... filter to delete one Paper_question
     *   }
     * })
     * 
    **/
    delete<T extends paper_questionDeleteArgs>(
      args: SelectSubset<T, paper_questionDeleteArgs>
    ): CheckSelect<T, Prisma__paper_questionClient<paper_question>, Prisma__paper_questionClient<paper_questionGetPayload<T>>>

    /**
     * Update one Paper_question.
     * @param {paper_questionUpdateArgs} args - Arguments to update one Paper_question.
     * @example
     * // Update one Paper_question
     * const paper_question = await prisma.paper_question.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends paper_questionUpdateArgs>(
      args: SelectSubset<T, paper_questionUpdateArgs>
    ): CheckSelect<T, Prisma__paper_questionClient<paper_question>, Prisma__paper_questionClient<paper_questionGetPayload<T>>>

    /**
     * Delete zero or more Paper_questions.
     * @param {paper_questionDeleteManyArgs} args - Arguments to filter Paper_questions to delete.
     * @example
     * // Delete a few Paper_questions
     * const { count } = await prisma.paper_question.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends paper_questionDeleteManyArgs>(
      args?: SelectSubset<T, paper_questionDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Paper_questions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {paper_questionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Paper_questions
     * const paper_question = await prisma.paper_question.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends paper_questionUpdateManyArgs>(
      args: SelectSubset<T, paper_questionUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Paper_question.
     * @param {paper_questionUpsertArgs} args - Arguments to update or create a Paper_question.
     * @example
     * // Update or create a Paper_question
     * const paper_question = await prisma.paper_question.upsert({
     *   create: {
     *     // ... data to create a Paper_question
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Paper_question we want to update
     *   }
     * })
    **/
    upsert<T extends paper_questionUpsertArgs>(
      args: SelectSubset<T, paper_questionUpsertArgs>
    ): CheckSelect<T, Prisma__paper_questionClient<paper_question>, Prisma__paper_questionClient<paper_questionGetPayload<T>>>

    /**
     * Find one Paper_question that matches the filter or throw
     * `NotFoundError` if no matches were found.
     * @param {paper_questionFindUniqueOrThrowArgs} args - Arguments to find a Paper_question
     * @example
     * // Get one Paper_question
     * const paper_question = await prisma.paper_question.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends paper_questionFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, paper_questionFindUniqueOrThrowArgs>
    ): CheckSelect<T, Prisma__paper_questionClient<paper_question>, Prisma__paper_questionClient<paper_questionGetPayload<T>>>

    /**
     * Find the first Paper_question that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {paper_questionFindFirstOrThrowArgs} args - Arguments to find a Paper_question
     * @example
     * // Get one Paper_question
     * const paper_question = await prisma.paper_question.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends paper_questionFindFirstOrThrowArgs>(
      args?: SelectSubset<T, paper_questionFindFirstOrThrowArgs>
    ): CheckSelect<T, Prisma__paper_questionClient<paper_question>, Prisma__paper_questionClient<paper_questionGetPayload<T>>>

    /**
     * Count the number of Paper_questions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {paper_questionCountArgs} args - Arguments to filter Paper_questions to count.
     * @example
     * // Count the number of Paper_questions
     * const count = await prisma.paper_question.count({
     *   where: {
     *     // ... the filter for the Paper_questions we want to count
     *   }
     * })
    **/
    count<T extends paper_questionCountArgs>(
      args?: Subset<T, paper_questionCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Paper_questionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Paper_question.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Paper_questionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Paper_questionAggregateArgs>(args: Subset<T, Paper_questionAggregateArgs>): PrismaPromise<GetPaper_questionAggregateType<T>>

    /**
     * Group by Paper_question.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Paper_questionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends Paper_questionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: Paper_questionGroupByArgs['orderBy'] }
        : { orderBy?: Paper_questionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, Paper_questionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPaper_questionGroupByPayload<T> : PrismaPromise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for paper_question.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__paper_questionClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * paper_question base type for findUnique actions
   */
  export type paper_questionFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the paper_question
     * 
    **/
    select?: paper_questionSelect | null
    /**
     * Filter, which paper_question to fetch.
     * 
    **/
    where: paper_questionWhereUniqueInput
  }

  /**
   * paper_question: findUnique
   */
  export interface paper_questionFindUniqueArgs extends paper_questionFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * paper_question base type for findFirst actions
   */
  export type paper_questionFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the paper_question
     * 
    **/
    select?: paper_questionSelect | null
    /**
     * Filter, which paper_question to fetch.
     * 
    **/
    where?: paper_questionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of paper_questions to fetch.
     * 
    **/
    orderBy?: Enumerable<paper_questionOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for paper_questions.
     * 
    **/
    cursor?: paper_questionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` paper_questions from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` paper_questions.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of paper_questions.
     * 
    **/
    distinct?: Enumerable<Paper_questionScalarFieldEnum>
  }

  /**
   * paper_question: findFirst
   */
  export interface paper_questionFindFirstArgs extends paper_questionFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * paper_question findMany
   */
  export type paper_questionFindManyArgs = {
    /**
     * Select specific fields to fetch from the paper_question
     * 
    **/
    select?: paper_questionSelect | null
    /**
     * Filter, which paper_questions to fetch.
     * 
    **/
    where?: paper_questionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of paper_questions to fetch.
     * 
    **/
    orderBy?: Enumerable<paper_questionOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing paper_questions.
     * 
    **/
    cursor?: paper_questionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` paper_questions from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` paper_questions.
     * 
    **/
    skip?: number
    distinct?: Enumerable<Paper_questionScalarFieldEnum>
  }


  /**
   * paper_question create
   */
  export type paper_questionCreateArgs = {
    /**
     * Select specific fields to fetch from the paper_question
     * 
    **/
    select?: paper_questionSelect | null
    /**
     * The data needed to create a paper_question.
     * 
    **/
    data: XOR<paper_questionCreateInput, paper_questionUncheckedCreateInput>
  }


  /**
   * paper_question createMany
   */
  export type paper_questionCreateManyArgs = {
    /**
     * The data used to create many paper_questions.
     * 
    **/
    data: Enumerable<paper_questionCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * paper_question update
   */
  export type paper_questionUpdateArgs = {
    /**
     * Select specific fields to fetch from the paper_question
     * 
    **/
    select?: paper_questionSelect | null
    /**
     * The data needed to update a paper_question.
     * 
    **/
    data: XOR<paper_questionUpdateInput, paper_questionUncheckedUpdateInput>
    /**
     * Choose, which paper_question to update.
     * 
    **/
    where: paper_questionWhereUniqueInput
  }


  /**
   * paper_question updateMany
   */
  export type paper_questionUpdateManyArgs = {
    /**
     * The data used to update paper_questions.
     * 
    **/
    data: XOR<paper_questionUpdateManyMutationInput, paper_questionUncheckedUpdateManyInput>
    /**
     * Filter which paper_questions to update
     * 
    **/
    where?: paper_questionWhereInput
  }


  /**
   * paper_question upsert
   */
  export type paper_questionUpsertArgs = {
    /**
     * Select specific fields to fetch from the paper_question
     * 
    **/
    select?: paper_questionSelect | null
    /**
     * The filter to search for the paper_question to update in case it exists.
     * 
    **/
    where: paper_questionWhereUniqueInput
    /**
     * In case the paper_question found by the `where` argument doesn't exist, create a new paper_question with this data.
     * 
    **/
    create: XOR<paper_questionCreateInput, paper_questionUncheckedCreateInput>
    /**
     * In case the paper_question was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<paper_questionUpdateInput, paper_questionUncheckedUpdateInput>
  }


  /**
   * paper_question delete
   */
  export type paper_questionDeleteArgs = {
    /**
     * Select specific fields to fetch from the paper_question
     * 
    **/
    select?: paper_questionSelect | null
    /**
     * Filter which paper_question to delete.
     * 
    **/
    where: paper_questionWhereUniqueInput
  }


  /**
   * paper_question deleteMany
   */
  export type paper_questionDeleteManyArgs = {
    /**
     * Filter which paper_questions to delete
     * 
    **/
    where?: paper_questionWhereInput
  }


  /**
   * paper_question: findUniqueOrThrow
   */
  export type paper_questionFindUniqueOrThrowArgs = paper_questionFindUniqueArgsBase
      

  /**
   * paper_question: findFirstOrThrow
   */
  export type paper_questionFindFirstOrThrowArgs = paper_questionFindFirstArgsBase
      

  /**
   * paper_question without action
   */
  export type paper_questionArgs = {
    /**
     * Select specific fields to fetch from the paper_question
     * 
    **/
    select?: paper_questionSelect | null
  }



  /**
   * Model payment
   */


  export type AggregatePayment = {
    _count: PaymentCountAggregateOutputType | null
    _avg: PaymentAvgAggregateOutputType | null
    _sum: PaymentSumAggregateOutputType | null
    _min: PaymentMinAggregateOutputType | null
    _max: PaymentMaxAggregateOutputType | null
  }

  export type PaymentAvgAggregateOutputType = {
    payment_id: number | null
    amount: number | null
    index_no: number | null
    ac_year_ID: number | null
  }

  export type PaymentSumAggregateOutputType = {
    payment_id: number | null
    amount: number | null
    index_no: number | null
    ac_year_ID: number | null
  }

  export type PaymentMinAggregateOutputType = {
    payment_id: number | null
    payment_date: Date | null
    amount: number | null
    status: string | null
    index_no: number | null
    ac_year_ID: number | null
  }

  export type PaymentMaxAggregateOutputType = {
    payment_id: number | null
    payment_date: Date | null
    amount: number | null
    status: string | null
    index_no: number | null
    ac_year_ID: number | null
  }

  export type PaymentCountAggregateOutputType = {
    payment_id: number
    payment_date: number
    amount: number
    status: number
    index_no: number
    ac_year_ID: number
    _all: number
  }


  export type PaymentAvgAggregateInputType = {
    payment_id?: true
    amount?: true
    index_no?: true
    ac_year_ID?: true
  }

  export type PaymentSumAggregateInputType = {
    payment_id?: true
    amount?: true
    index_no?: true
    ac_year_ID?: true
  }

  export type PaymentMinAggregateInputType = {
    payment_id?: true
    payment_date?: true
    amount?: true
    status?: true
    index_no?: true
    ac_year_ID?: true
  }

  export type PaymentMaxAggregateInputType = {
    payment_id?: true
    payment_date?: true
    amount?: true
    status?: true
    index_no?: true
    ac_year_ID?: true
  }

  export type PaymentCountAggregateInputType = {
    payment_id?: true
    payment_date?: true
    amount?: true
    status?: true
    index_no?: true
    ac_year_ID?: true
    _all?: true
  }

  export type PaymentAggregateArgs = {
    /**
     * Filter which payment to aggregate.
     * 
    **/
    where?: paymentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of payments to fetch.
     * 
    **/
    orderBy?: Enumerable<paymentOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: paymentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` payments from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` payments.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned payments
    **/
    _count?: true | PaymentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PaymentAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PaymentSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PaymentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PaymentMaxAggregateInputType
  }

  export type GetPaymentAggregateType<T extends PaymentAggregateArgs> = {
        [P in keyof T & keyof AggregatePayment]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePayment[P]>
      : GetScalarType<T[P], AggregatePayment[P]>
  }




  export type PaymentGroupByArgs = {
    where?: paymentWhereInput
    orderBy?: Enumerable<paymentOrderByWithAggregationInput>
    by: Array<PaymentScalarFieldEnum>
    having?: paymentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PaymentCountAggregateInputType | true
    _avg?: PaymentAvgAggregateInputType
    _sum?: PaymentSumAggregateInputType
    _min?: PaymentMinAggregateInputType
    _max?: PaymentMaxAggregateInputType
  }


  export type PaymentGroupByOutputType = {
    payment_id: number
    payment_date: Date
    amount: number
    status: string
    index_no: number
    ac_year_ID: number
    _count: PaymentCountAggregateOutputType | null
    _avg: PaymentAvgAggregateOutputType | null
    _sum: PaymentSumAggregateOutputType | null
    _min: PaymentMinAggregateOutputType | null
    _max: PaymentMaxAggregateOutputType | null
  }

  type GetPaymentGroupByPayload<T extends PaymentGroupByArgs> = PrismaPromise<
    Array<
      PickArray<PaymentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PaymentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PaymentGroupByOutputType[P]>
            : GetScalarType<T[P], PaymentGroupByOutputType[P]>
        }
      >
    >


  export type paymentSelect = {
    payment_id?: boolean
    payment_date?: boolean
    amount?: boolean
    status?: boolean
    index_no?: boolean
    ac_year_ID?: boolean
  }

  export type paymentGetPayload<
    S extends boolean | null | undefined | paymentArgs,
    U = keyof S
      > = S extends true
        ? payment
    : S extends undefined
    ? never
    : S extends paymentArgs | paymentFindManyArgs
    ?'include' extends U
    ? payment 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
    P extends keyof payment ? payment[P] : never
  } 
    : payment
  : payment


  type paymentCountArgs = Merge<
    Omit<paymentFindManyArgs, 'select' | 'include'> & {
      select?: PaymentCountAggregateInputType | true
    }
  >

  export interface paymentDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one Payment that matches the filter.
     * @param {paymentFindUniqueArgs} args - Arguments to find a Payment
     * @example
     * // Get one Payment
     * const payment = await prisma.payment.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends paymentFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, paymentFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'payment'> extends True ? CheckSelect<T, Prisma__paymentClient<payment>, Prisma__paymentClient<paymentGetPayload<T>>> : CheckSelect<T, Prisma__paymentClient<payment | null >, Prisma__paymentClient<paymentGetPayload<T> | null >>

    /**
     * Find the first Payment that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {paymentFindFirstArgs} args - Arguments to find a Payment
     * @example
     * // Get one Payment
     * const payment = await prisma.payment.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends paymentFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, paymentFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'payment'> extends True ? CheckSelect<T, Prisma__paymentClient<payment>, Prisma__paymentClient<paymentGetPayload<T>>> : CheckSelect<T, Prisma__paymentClient<payment | null >, Prisma__paymentClient<paymentGetPayload<T> | null >>

    /**
     * Find zero or more Payments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {paymentFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Payments
     * const payments = await prisma.payment.findMany()
     * 
     * // Get first 10 Payments
     * const payments = await prisma.payment.findMany({ take: 10 })
     * 
     * // Only select the `payment_id`
     * const paymentWithPayment_idOnly = await prisma.payment.findMany({ select: { payment_id: true } })
     * 
    **/
    findMany<T extends paymentFindManyArgs>(
      args?: SelectSubset<T, paymentFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<payment>>, PrismaPromise<Array<paymentGetPayload<T>>>>

    /**
     * Create a Payment.
     * @param {paymentCreateArgs} args - Arguments to create a Payment.
     * @example
     * // Create one Payment
     * const Payment = await prisma.payment.create({
     *   data: {
     *     // ... data to create a Payment
     *   }
     * })
     * 
    **/
    create<T extends paymentCreateArgs>(
      args: SelectSubset<T, paymentCreateArgs>
    ): CheckSelect<T, Prisma__paymentClient<payment>, Prisma__paymentClient<paymentGetPayload<T>>>

    /**
     * Create many Payments.
     *     @param {paymentCreateManyArgs} args - Arguments to create many Payments.
     *     @example
     *     // Create many Payments
     *     const payment = await prisma.payment.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends paymentCreateManyArgs>(
      args?: SelectSubset<T, paymentCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Payment.
     * @param {paymentDeleteArgs} args - Arguments to delete one Payment.
     * @example
     * // Delete one Payment
     * const Payment = await prisma.payment.delete({
     *   where: {
     *     // ... filter to delete one Payment
     *   }
     * })
     * 
    **/
    delete<T extends paymentDeleteArgs>(
      args: SelectSubset<T, paymentDeleteArgs>
    ): CheckSelect<T, Prisma__paymentClient<payment>, Prisma__paymentClient<paymentGetPayload<T>>>

    /**
     * Update one Payment.
     * @param {paymentUpdateArgs} args - Arguments to update one Payment.
     * @example
     * // Update one Payment
     * const payment = await prisma.payment.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends paymentUpdateArgs>(
      args: SelectSubset<T, paymentUpdateArgs>
    ): CheckSelect<T, Prisma__paymentClient<payment>, Prisma__paymentClient<paymentGetPayload<T>>>

    /**
     * Delete zero or more Payments.
     * @param {paymentDeleteManyArgs} args - Arguments to filter Payments to delete.
     * @example
     * // Delete a few Payments
     * const { count } = await prisma.payment.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends paymentDeleteManyArgs>(
      args?: SelectSubset<T, paymentDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Payments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {paymentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Payments
     * const payment = await prisma.payment.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends paymentUpdateManyArgs>(
      args: SelectSubset<T, paymentUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Payment.
     * @param {paymentUpsertArgs} args - Arguments to update or create a Payment.
     * @example
     * // Update or create a Payment
     * const payment = await prisma.payment.upsert({
     *   create: {
     *     // ... data to create a Payment
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Payment we want to update
     *   }
     * })
    **/
    upsert<T extends paymentUpsertArgs>(
      args: SelectSubset<T, paymentUpsertArgs>
    ): CheckSelect<T, Prisma__paymentClient<payment>, Prisma__paymentClient<paymentGetPayload<T>>>

    /**
     * Find one Payment that matches the filter or throw
     * `NotFoundError` if no matches were found.
     * @param {paymentFindUniqueOrThrowArgs} args - Arguments to find a Payment
     * @example
     * // Get one Payment
     * const payment = await prisma.payment.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends paymentFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, paymentFindUniqueOrThrowArgs>
    ): CheckSelect<T, Prisma__paymentClient<payment>, Prisma__paymentClient<paymentGetPayload<T>>>

    /**
     * Find the first Payment that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {paymentFindFirstOrThrowArgs} args - Arguments to find a Payment
     * @example
     * // Get one Payment
     * const payment = await prisma.payment.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends paymentFindFirstOrThrowArgs>(
      args?: SelectSubset<T, paymentFindFirstOrThrowArgs>
    ): CheckSelect<T, Prisma__paymentClient<payment>, Prisma__paymentClient<paymentGetPayload<T>>>

    /**
     * Count the number of Payments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {paymentCountArgs} args - Arguments to filter Payments to count.
     * @example
     * // Count the number of Payments
     * const count = await prisma.payment.count({
     *   where: {
     *     // ... the filter for the Payments we want to count
     *   }
     * })
    **/
    count<T extends paymentCountArgs>(
      args?: Subset<T, paymentCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PaymentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Payment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PaymentAggregateArgs>(args: Subset<T, PaymentAggregateArgs>): PrismaPromise<GetPaymentAggregateType<T>>

    /**
     * Group by Payment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PaymentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PaymentGroupByArgs['orderBy'] }
        : { orderBy?: PaymentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PaymentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPaymentGroupByPayload<T> : PrismaPromise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for payment.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__paymentClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * payment base type for findUnique actions
   */
  export type paymentFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the payment
     * 
    **/
    select?: paymentSelect | null
    /**
     * Filter, which payment to fetch.
     * 
    **/
    where: paymentWhereUniqueInput
  }

  /**
   * payment: findUnique
   */
  export interface paymentFindUniqueArgs extends paymentFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * payment base type for findFirst actions
   */
  export type paymentFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the payment
     * 
    **/
    select?: paymentSelect | null
    /**
     * Filter, which payment to fetch.
     * 
    **/
    where?: paymentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of payments to fetch.
     * 
    **/
    orderBy?: Enumerable<paymentOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for payments.
     * 
    **/
    cursor?: paymentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` payments from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` payments.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of payments.
     * 
    **/
    distinct?: Enumerable<PaymentScalarFieldEnum>
  }

  /**
   * payment: findFirst
   */
  export interface paymentFindFirstArgs extends paymentFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * payment findMany
   */
  export type paymentFindManyArgs = {
    /**
     * Select specific fields to fetch from the payment
     * 
    **/
    select?: paymentSelect | null
    /**
     * Filter, which payments to fetch.
     * 
    **/
    where?: paymentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of payments to fetch.
     * 
    **/
    orderBy?: Enumerable<paymentOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing payments.
     * 
    **/
    cursor?: paymentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` payments from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` payments.
     * 
    **/
    skip?: number
    distinct?: Enumerable<PaymentScalarFieldEnum>
  }


  /**
   * payment create
   */
  export type paymentCreateArgs = {
    /**
     * Select specific fields to fetch from the payment
     * 
    **/
    select?: paymentSelect | null
    /**
     * The data needed to create a payment.
     * 
    **/
    data: XOR<paymentCreateInput, paymentUncheckedCreateInput>
  }


  /**
   * payment createMany
   */
  export type paymentCreateManyArgs = {
    /**
     * The data used to create many payments.
     * 
    **/
    data: Enumerable<paymentCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * payment update
   */
  export type paymentUpdateArgs = {
    /**
     * Select specific fields to fetch from the payment
     * 
    **/
    select?: paymentSelect | null
    /**
     * The data needed to update a payment.
     * 
    **/
    data: XOR<paymentUpdateInput, paymentUncheckedUpdateInput>
    /**
     * Choose, which payment to update.
     * 
    **/
    where: paymentWhereUniqueInput
  }


  /**
   * payment updateMany
   */
  export type paymentUpdateManyArgs = {
    /**
     * The data used to update payments.
     * 
    **/
    data: XOR<paymentUpdateManyMutationInput, paymentUncheckedUpdateManyInput>
    /**
     * Filter which payments to update
     * 
    **/
    where?: paymentWhereInput
  }


  /**
   * payment upsert
   */
  export type paymentUpsertArgs = {
    /**
     * Select specific fields to fetch from the payment
     * 
    **/
    select?: paymentSelect | null
    /**
     * The filter to search for the payment to update in case it exists.
     * 
    **/
    where: paymentWhereUniqueInput
    /**
     * In case the payment found by the `where` argument doesn't exist, create a new payment with this data.
     * 
    **/
    create: XOR<paymentCreateInput, paymentUncheckedCreateInput>
    /**
     * In case the payment was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<paymentUpdateInput, paymentUncheckedUpdateInput>
  }


  /**
   * payment delete
   */
  export type paymentDeleteArgs = {
    /**
     * Select specific fields to fetch from the payment
     * 
    **/
    select?: paymentSelect | null
    /**
     * Filter which payment to delete.
     * 
    **/
    where: paymentWhereUniqueInput
  }


  /**
   * payment deleteMany
   */
  export type paymentDeleteManyArgs = {
    /**
     * Filter which payments to delete
     * 
    **/
    where?: paymentWhereInput
  }


  /**
   * payment: findUniqueOrThrow
   */
  export type paymentFindUniqueOrThrowArgs = paymentFindUniqueArgsBase
      

  /**
   * payment: findFirstOrThrow
   */
  export type paymentFindFirstOrThrowArgs = paymentFindFirstArgsBase
      

  /**
   * payment without action
   */
  export type paymentArgs = {
    /**
     * Select specific fields to fetch from the payment
     * 
    **/
    select?: paymentSelect | null
  }



  /**
   * Model repeat_course
   */


  export type AggregateRepeat_course = {
    _count: Repeat_courseCountAggregateOutputType | null
    _avg: Repeat_courseAvgAggregateOutputType | null
    _sum: Repeat_courseSumAggregateOutputType | null
    _min: Repeat_courseMinAggregateOutputType | null
    _max: Repeat_courseMaxAggregateOutputType | null
  }

  export type Repeat_courseAvgAggregateOutputType = {
    rc_id: number | null
    year: number | null
  }

  export type Repeat_courseSumAggregateOutputType = {
    rc_id: number | null
    year: number | null
  }

  export type Repeat_courseMinAggregateOutputType = {
    rc_id: number | null
    course_code: string | null
    course_name: string | null
    year: number | null
    semester: string | null
  }

  export type Repeat_courseMaxAggregateOutputType = {
    rc_id: number | null
    course_code: string | null
    course_name: string | null
    year: number | null
    semester: string | null
  }

  export type Repeat_courseCountAggregateOutputType = {
    rc_id: number
    course_code: number
    course_name: number
    year: number
    semester: number
    _all: number
  }


  export type Repeat_courseAvgAggregateInputType = {
    rc_id?: true
    year?: true
  }

  export type Repeat_courseSumAggregateInputType = {
    rc_id?: true
    year?: true
  }

  export type Repeat_courseMinAggregateInputType = {
    rc_id?: true
    course_code?: true
    course_name?: true
    year?: true
    semester?: true
  }

  export type Repeat_courseMaxAggregateInputType = {
    rc_id?: true
    course_code?: true
    course_name?: true
    year?: true
    semester?: true
  }

  export type Repeat_courseCountAggregateInputType = {
    rc_id?: true
    course_code?: true
    course_name?: true
    year?: true
    semester?: true
    _all?: true
  }

  export type Repeat_courseAggregateArgs = {
    /**
     * Filter which repeat_course to aggregate.
     * 
    **/
    where?: repeat_courseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of repeat_courses to fetch.
     * 
    **/
    orderBy?: Enumerable<repeat_courseOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: repeat_courseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` repeat_courses from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` repeat_courses.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned repeat_courses
    **/
    _count?: true | Repeat_courseCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Repeat_courseAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Repeat_courseSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Repeat_courseMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Repeat_courseMaxAggregateInputType
  }

  export type GetRepeat_courseAggregateType<T extends Repeat_courseAggregateArgs> = {
        [P in keyof T & keyof AggregateRepeat_course]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRepeat_course[P]>
      : GetScalarType<T[P], AggregateRepeat_course[P]>
  }




  export type Repeat_courseGroupByArgs = {
    where?: repeat_courseWhereInput
    orderBy?: Enumerable<repeat_courseOrderByWithAggregationInput>
    by: Array<Repeat_courseScalarFieldEnum>
    having?: repeat_courseScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Repeat_courseCountAggregateInputType | true
    _avg?: Repeat_courseAvgAggregateInputType
    _sum?: Repeat_courseSumAggregateInputType
    _min?: Repeat_courseMinAggregateInputType
    _max?: Repeat_courseMaxAggregateInputType
  }


  export type Repeat_courseGroupByOutputType = {
    rc_id: number
    course_code: string
    course_name: string
    year: number
    semester: string
    _count: Repeat_courseCountAggregateOutputType | null
    _avg: Repeat_courseAvgAggregateOutputType | null
    _sum: Repeat_courseSumAggregateOutputType | null
    _min: Repeat_courseMinAggregateOutputType | null
    _max: Repeat_courseMaxAggregateOutputType | null
  }

  type GetRepeat_courseGroupByPayload<T extends Repeat_courseGroupByArgs> = PrismaPromise<
    Array<
      PickArray<Repeat_courseGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Repeat_courseGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Repeat_courseGroupByOutputType[P]>
            : GetScalarType<T[P], Repeat_courseGroupByOutputType[P]>
        }
      >
    >


  export type repeat_courseSelect = {
    rc_id?: boolean
    course_code?: boolean
    course_name?: boolean
    year?: boolean
    semester?: boolean
  }

  export type repeat_courseGetPayload<
    S extends boolean | null | undefined | repeat_courseArgs,
    U = keyof S
      > = S extends true
        ? repeat_course
    : S extends undefined
    ? never
    : S extends repeat_courseArgs | repeat_courseFindManyArgs
    ?'include' extends U
    ? repeat_course 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
    P extends keyof repeat_course ? repeat_course[P] : never
  } 
    : repeat_course
  : repeat_course


  type repeat_courseCountArgs = Merge<
    Omit<repeat_courseFindManyArgs, 'select' | 'include'> & {
      select?: Repeat_courseCountAggregateInputType | true
    }
  >

  export interface repeat_courseDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one Repeat_course that matches the filter.
     * @param {repeat_courseFindUniqueArgs} args - Arguments to find a Repeat_course
     * @example
     * // Get one Repeat_course
     * const repeat_course = await prisma.repeat_course.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends repeat_courseFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, repeat_courseFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'repeat_course'> extends True ? CheckSelect<T, Prisma__repeat_courseClient<repeat_course>, Prisma__repeat_courseClient<repeat_courseGetPayload<T>>> : CheckSelect<T, Prisma__repeat_courseClient<repeat_course | null >, Prisma__repeat_courseClient<repeat_courseGetPayload<T> | null >>

    /**
     * Find the first Repeat_course that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {repeat_courseFindFirstArgs} args - Arguments to find a Repeat_course
     * @example
     * // Get one Repeat_course
     * const repeat_course = await prisma.repeat_course.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends repeat_courseFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, repeat_courseFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'repeat_course'> extends True ? CheckSelect<T, Prisma__repeat_courseClient<repeat_course>, Prisma__repeat_courseClient<repeat_courseGetPayload<T>>> : CheckSelect<T, Prisma__repeat_courseClient<repeat_course | null >, Prisma__repeat_courseClient<repeat_courseGetPayload<T> | null >>

    /**
     * Find zero or more Repeat_courses that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {repeat_courseFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Repeat_courses
     * const repeat_courses = await prisma.repeat_course.findMany()
     * 
     * // Get first 10 Repeat_courses
     * const repeat_courses = await prisma.repeat_course.findMany({ take: 10 })
     * 
     * // Only select the `rc_id`
     * const repeat_courseWithRc_idOnly = await prisma.repeat_course.findMany({ select: { rc_id: true } })
     * 
    **/
    findMany<T extends repeat_courseFindManyArgs>(
      args?: SelectSubset<T, repeat_courseFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<repeat_course>>, PrismaPromise<Array<repeat_courseGetPayload<T>>>>

    /**
     * Create a Repeat_course.
     * @param {repeat_courseCreateArgs} args - Arguments to create a Repeat_course.
     * @example
     * // Create one Repeat_course
     * const Repeat_course = await prisma.repeat_course.create({
     *   data: {
     *     // ... data to create a Repeat_course
     *   }
     * })
     * 
    **/
    create<T extends repeat_courseCreateArgs>(
      args: SelectSubset<T, repeat_courseCreateArgs>
    ): CheckSelect<T, Prisma__repeat_courseClient<repeat_course>, Prisma__repeat_courseClient<repeat_courseGetPayload<T>>>

    /**
     * Create many Repeat_courses.
     *     @param {repeat_courseCreateManyArgs} args - Arguments to create many Repeat_courses.
     *     @example
     *     // Create many Repeat_courses
     *     const repeat_course = await prisma.repeat_course.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends repeat_courseCreateManyArgs>(
      args?: SelectSubset<T, repeat_courseCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Repeat_course.
     * @param {repeat_courseDeleteArgs} args - Arguments to delete one Repeat_course.
     * @example
     * // Delete one Repeat_course
     * const Repeat_course = await prisma.repeat_course.delete({
     *   where: {
     *     // ... filter to delete one Repeat_course
     *   }
     * })
     * 
    **/
    delete<T extends repeat_courseDeleteArgs>(
      args: SelectSubset<T, repeat_courseDeleteArgs>
    ): CheckSelect<T, Prisma__repeat_courseClient<repeat_course>, Prisma__repeat_courseClient<repeat_courseGetPayload<T>>>

    /**
     * Update one Repeat_course.
     * @param {repeat_courseUpdateArgs} args - Arguments to update one Repeat_course.
     * @example
     * // Update one Repeat_course
     * const repeat_course = await prisma.repeat_course.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends repeat_courseUpdateArgs>(
      args: SelectSubset<T, repeat_courseUpdateArgs>
    ): CheckSelect<T, Prisma__repeat_courseClient<repeat_course>, Prisma__repeat_courseClient<repeat_courseGetPayload<T>>>

    /**
     * Delete zero or more Repeat_courses.
     * @param {repeat_courseDeleteManyArgs} args - Arguments to filter Repeat_courses to delete.
     * @example
     * // Delete a few Repeat_courses
     * const { count } = await prisma.repeat_course.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends repeat_courseDeleteManyArgs>(
      args?: SelectSubset<T, repeat_courseDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Repeat_courses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {repeat_courseUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Repeat_courses
     * const repeat_course = await prisma.repeat_course.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends repeat_courseUpdateManyArgs>(
      args: SelectSubset<T, repeat_courseUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Repeat_course.
     * @param {repeat_courseUpsertArgs} args - Arguments to update or create a Repeat_course.
     * @example
     * // Update or create a Repeat_course
     * const repeat_course = await prisma.repeat_course.upsert({
     *   create: {
     *     // ... data to create a Repeat_course
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Repeat_course we want to update
     *   }
     * })
    **/
    upsert<T extends repeat_courseUpsertArgs>(
      args: SelectSubset<T, repeat_courseUpsertArgs>
    ): CheckSelect<T, Prisma__repeat_courseClient<repeat_course>, Prisma__repeat_courseClient<repeat_courseGetPayload<T>>>

    /**
     * Find one Repeat_course that matches the filter or throw
     * `NotFoundError` if no matches were found.
     * @param {repeat_courseFindUniqueOrThrowArgs} args - Arguments to find a Repeat_course
     * @example
     * // Get one Repeat_course
     * const repeat_course = await prisma.repeat_course.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends repeat_courseFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, repeat_courseFindUniqueOrThrowArgs>
    ): CheckSelect<T, Prisma__repeat_courseClient<repeat_course>, Prisma__repeat_courseClient<repeat_courseGetPayload<T>>>

    /**
     * Find the first Repeat_course that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {repeat_courseFindFirstOrThrowArgs} args - Arguments to find a Repeat_course
     * @example
     * // Get one Repeat_course
     * const repeat_course = await prisma.repeat_course.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends repeat_courseFindFirstOrThrowArgs>(
      args?: SelectSubset<T, repeat_courseFindFirstOrThrowArgs>
    ): CheckSelect<T, Prisma__repeat_courseClient<repeat_course>, Prisma__repeat_courseClient<repeat_courseGetPayload<T>>>

    /**
     * Count the number of Repeat_courses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {repeat_courseCountArgs} args - Arguments to filter Repeat_courses to count.
     * @example
     * // Count the number of Repeat_courses
     * const count = await prisma.repeat_course.count({
     *   where: {
     *     // ... the filter for the Repeat_courses we want to count
     *   }
     * })
    **/
    count<T extends repeat_courseCountArgs>(
      args?: Subset<T, repeat_courseCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Repeat_courseCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Repeat_course.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Repeat_courseAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Repeat_courseAggregateArgs>(args: Subset<T, Repeat_courseAggregateArgs>): PrismaPromise<GetRepeat_courseAggregateType<T>>

    /**
     * Group by Repeat_course.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Repeat_courseGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends Repeat_courseGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: Repeat_courseGroupByArgs['orderBy'] }
        : { orderBy?: Repeat_courseGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, Repeat_courseGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRepeat_courseGroupByPayload<T> : PrismaPromise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for repeat_course.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__repeat_courseClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * repeat_course base type for findUnique actions
   */
  export type repeat_courseFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the repeat_course
     * 
    **/
    select?: repeat_courseSelect | null
    /**
     * Filter, which repeat_course to fetch.
     * 
    **/
    where: repeat_courseWhereUniqueInput
  }

  /**
   * repeat_course: findUnique
   */
  export interface repeat_courseFindUniqueArgs extends repeat_courseFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * repeat_course base type for findFirst actions
   */
  export type repeat_courseFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the repeat_course
     * 
    **/
    select?: repeat_courseSelect | null
    /**
     * Filter, which repeat_course to fetch.
     * 
    **/
    where?: repeat_courseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of repeat_courses to fetch.
     * 
    **/
    orderBy?: Enumerable<repeat_courseOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for repeat_courses.
     * 
    **/
    cursor?: repeat_courseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` repeat_courses from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` repeat_courses.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of repeat_courses.
     * 
    **/
    distinct?: Enumerable<Repeat_courseScalarFieldEnum>
  }

  /**
   * repeat_course: findFirst
   */
  export interface repeat_courseFindFirstArgs extends repeat_courseFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * repeat_course findMany
   */
  export type repeat_courseFindManyArgs = {
    /**
     * Select specific fields to fetch from the repeat_course
     * 
    **/
    select?: repeat_courseSelect | null
    /**
     * Filter, which repeat_courses to fetch.
     * 
    **/
    where?: repeat_courseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of repeat_courses to fetch.
     * 
    **/
    orderBy?: Enumerable<repeat_courseOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing repeat_courses.
     * 
    **/
    cursor?: repeat_courseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` repeat_courses from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` repeat_courses.
     * 
    **/
    skip?: number
    distinct?: Enumerable<Repeat_courseScalarFieldEnum>
  }


  /**
   * repeat_course create
   */
  export type repeat_courseCreateArgs = {
    /**
     * Select specific fields to fetch from the repeat_course
     * 
    **/
    select?: repeat_courseSelect | null
    /**
     * The data needed to create a repeat_course.
     * 
    **/
    data: XOR<repeat_courseCreateInput, repeat_courseUncheckedCreateInput>
  }


  /**
   * repeat_course createMany
   */
  export type repeat_courseCreateManyArgs = {
    /**
     * The data used to create many repeat_courses.
     * 
    **/
    data: Enumerable<repeat_courseCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * repeat_course update
   */
  export type repeat_courseUpdateArgs = {
    /**
     * Select specific fields to fetch from the repeat_course
     * 
    **/
    select?: repeat_courseSelect | null
    /**
     * The data needed to update a repeat_course.
     * 
    **/
    data: XOR<repeat_courseUpdateInput, repeat_courseUncheckedUpdateInput>
    /**
     * Choose, which repeat_course to update.
     * 
    **/
    where: repeat_courseWhereUniqueInput
  }


  /**
   * repeat_course updateMany
   */
  export type repeat_courseUpdateManyArgs = {
    /**
     * The data used to update repeat_courses.
     * 
    **/
    data: XOR<repeat_courseUpdateManyMutationInput, repeat_courseUncheckedUpdateManyInput>
    /**
     * Filter which repeat_courses to update
     * 
    **/
    where?: repeat_courseWhereInput
  }


  /**
   * repeat_course upsert
   */
  export type repeat_courseUpsertArgs = {
    /**
     * Select specific fields to fetch from the repeat_course
     * 
    **/
    select?: repeat_courseSelect | null
    /**
     * The filter to search for the repeat_course to update in case it exists.
     * 
    **/
    where: repeat_courseWhereUniqueInput
    /**
     * In case the repeat_course found by the `where` argument doesn't exist, create a new repeat_course with this data.
     * 
    **/
    create: XOR<repeat_courseCreateInput, repeat_courseUncheckedCreateInput>
    /**
     * In case the repeat_course was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<repeat_courseUpdateInput, repeat_courseUncheckedUpdateInput>
  }


  /**
   * repeat_course delete
   */
  export type repeat_courseDeleteArgs = {
    /**
     * Select specific fields to fetch from the repeat_course
     * 
    **/
    select?: repeat_courseSelect | null
    /**
     * Filter which repeat_course to delete.
     * 
    **/
    where: repeat_courseWhereUniqueInput
  }


  /**
   * repeat_course deleteMany
   */
  export type repeat_courseDeleteManyArgs = {
    /**
     * Filter which repeat_courses to delete
     * 
    **/
    where?: repeat_courseWhereInput
  }


  /**
   * repeat_course: findUniqueOrThrow
   */
  export type repeat_courseFindUniqueOrThrowArgs = repeat_courseFindUniqueArgsBase
      

  /**
   * repeat_course: findFirstOrThrow
   */
  export type repeat_courseFindFirstOrThrowArgs = repeat_courseFindFirstArgsBase
      

  /**
   * repeat_course without action
   */
  export type repeat_courseArgs = {
    /**
     * Select specific fields to fetch from the repeat_course
     * 
    **/
    select?: repeat_courseSelect | null
  }



  /**
   * Model report
   */


  export type AggregateReport = {
    _count: ReportCountAggregateOutputType | null
    _avg: ReportAvgAggregateOutputType | null
    _sum: ReportSumAggregateOutputType | null
    _min: ReportMinAggregateOutputType | null
    _max: ReportMaxAggregateOutputType | null
  }

  export type ReportAvgAggregateOutputType = {
    report_id: number | null
    year: number | null
    exam_sem_id: number | null
  }

  export type ReportSumAggregateOutputType = {
    report_id: number | null
    year: number | null
    exam_sem_id: number | null
  }

  export type ReportMinAggregateOutputType = {
    report_id: number | null
    course_name: string | null
    course_code: string | null
    year: number | null
    semester: string | null
    exam_sem_id: number | null
  }

  export type ReportMaxAggregateOutputType = {
    report_id: number | null
    course_name: string | null
    course_code: string | null
    year: number | null
    semester: string | null
    exam_sem_id: number | null
  }

  export type ReportCountAggregateOutputType = {
    report_id: number
    course_name: number
    course_code: number
    year: number
    semester: number
    exam_sem_id: number
    _all: number
  }


  export type ReportAvgAggregateInputType = {
    report_id?: true
    year?: true
    exam_sem_id?: true
  }

  export type ReportSumAggregateInputType = {
    report_id?: true
    year?: true
    exam_sem_id?: true
  }

  export type ReportMinAggregateInputType = {
    report_id?: true
    course_name?: true
    course_code?: true
    year?: true
    semester?: true
    exam_sem_id?: true
  }

  export type ReportMaxAggregateInputType = {
    report_id?: true
    course_name?: true
    course_code?: true
    year?: true
    semester?: true
    exam_sem_id?: true
  }

  export type ReportCountAggregateInputType = {
    report_id?: true
    course_name?: true
    course_code?: true
    year?: true
    semester?: true
    exam_sem_id?: true
    _all?: true
  }

  export type ReportAggregateArgs = {
    /**
     * Filter which report to aggregate.
     * 
    **/
    where?: reportWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of reports to fetch.
     * 
    **/
    orderBy?: Enumerable<reportOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: reportWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` reports from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` reports.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned reports
    **/
    _count?: true | ReportCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ReportAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ReportSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ReportMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ReportMaxAggregateInputType
  }

  export type GetReportAggregateType<T extends ReportAggregateArgs> = {
        [P in keyof T & keyof AggregateReport]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateReport[P]>
      : GetScalarType<T[P], AggregateReport[P]>
  }




  export type ReportGroupByArgs = {
    where?: reportWhereInput
    orderBy?: Enumerable<reportOrderByWithAggregationInput>
    by: Array<ReportScalarFieldEnum>
    having?: reportScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ReportCountAggregateInputType | true
    _avg?: ReportAvgAggregateInputType
    _sum?: ReportSumAggregateInputType
    _min?: ReportMinAggregateInputType
    _max?: ReportMaxAggregateInputType
  }


  export type ReportGroupByOutputType = {
    report_id: number
    course_name: string
    course_code: string
    year: number
    semester: string
    exam_sem_id: number
    _count: ReportCountAggregateOutputType | null
    _avg: ReportAvgAggregateOutputType | null
    _sum: ReportSumAggregateOutputType | null
    _min: ReportMinAggregateOutputType | null
    _max: ReportMaxAggregateOutputType | null
  }

  type GetReportGroupByPayload<T extends ReportGroupByArgs> = PrismaPromise<
    Array<
      PickArray<ReportGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ReportGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ReportGroupByOutputType[P]>
            : GetScalarType<T[P], ReportGroupByOutputType[P]>
        }
      >
    >


  export type reportSelect = {
    report_id?: boolean
    course_name?: boolean
    course_code?: boolean
    year?: boolean
    semester?: boolean
    exam_sem_id?: boolean
  }

  export type reportGetPayload<
    S extends boolean | null | undefined | reportArgs,
    U = keyof S
      > = S extends true
        ? report
    : S extends undefined
    ? never
    : S extends reportArgs | reportFindManyArgs
    ?'include' extends U
    ? report 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
    P extends keyof report ? report[P] : never
  } 
    : report
  : report


  type reportCountArgs = Merge<
    Omit<reportFindManyArgs, 'select' | 'include'> & {
      select?: ReportCountAggregateInputType | true
    }
  >

  export interface reportDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one Report that matches the filter.
     * @param {reportFindUniqueArgs} args - Arguments to find a Report
     * @example
     * // Get one Report
     * const report = await prisma.report.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends reportFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, reportFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'report'> extends True ? CheckSelect<T, Prisma__reportClient<report>, Prisma__reportClient<reportGetPayload<T>>> : CheckSelect<T, Prisma__reportClient<report | null >, Prisma__reportClient<reportGetPayload<T> | null >>

    /**
     * Find the first Report that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {reportFindFirstArgs} args - Arguments to find a Report
     * @example
     * // Get one Report
     * const report = await prisma.report.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends reportFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, reportFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'report'> extends True ? CheckSelect<T, Prisma__reportClient<report>, Prisma__reportClient<reportGetPayload<T>>> : CheckSelect<T, Prisma__reportClient<report | null >, Prisma__reportClient<reportGetPayload<T> | null >>

    /**
     * Find zero or more Reports that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {reportFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Reports
     * const reports = await prisma.report.findMany()
     * 
     * // Get first 10 Reports
     * const reports = await prisma.report.findMany({ take: 10 })
     * 
     * // Only select the `report_id`
     * const reportWithReport_idOnly = await prisma.report.findMany({ select: { report_id: true } })
     * 
    **/
    findMany<T extends reportFindManyArgs>(
      args?: SelectSubset<T, reportFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<report>>, PrismaPromise<Array<reportGetPayload<T>>>>

    /**
     * Create a Report.
     * @param {reportCreateArgs} args - Arguments to create a Report.
     * @example
     * // Create one Report
     * const Report = await prisma.report.create({
     *   data: {
     *     // ... data to create a Report
     *   }
     * })
     * 
    **/
    create<T extends reportCreateArgs>(
      args: SelectSubset<T, reportCreateArgs>
    ): CheckSelect<T, Prisma__reportClient<report>, Prisma__reportClient<reportGetPayload<T>>>

    /**
     * Create many Reports.
     *     @param {reportCreateManyArgs} args - Arguments to create many Reports.
     *     @example
     *     // Create many Reports
     *     const report = await prisma.report.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends reportCreateManyArgs>(
      args?: SelectSubset<T, reportCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Report.
     * @param {reportDeleteArgs} args - Arguments to delete one Report.
     * @example
     * // Delete one Report
     * const Report = await prisma.report.delete({
     *   where: {
     *     // ... filter to delete one Report
     *   }
     * })
     * 
    **/
    delete<T extends reportDeleteArgs>(
      args: SelectSubset<T, reportDeleteArgs>
    ): CheckSelect<T, Prisma__reportClient<report>, Prisma__reportClient<reportGetPayload<T>>>

    /**
     * Update one Report.
     * @param {reportUpdateArgs} args - Arguments to update one Report.
     * @example
     * // Update one Report
     * const report = await prisma.report.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends reportUpdateArgs>(
      args: SelectSubset<T, reportUpdateArgs>
    ): CheckSelect<T, Prisma__reportClient<report>, Prisma__reportClient<reportGetPayload<T>>>

    /**
     * Delete zero or more Reports.
     * @param {reportDeleteManyArgs} args - Arguments to filter Reports to delete.
     * @example
     * // Delete a few Reports
     * const { count } = await prisma.report.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends reportDeleteManyArgs>(
      args?: SelectSubset<T, reportDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Reports.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {reportUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Reports
     * const report = await prisma.report.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends reportUpdateManyArgs>(
      args: SelectSubset<T, reportUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Report.
     * @param {reportUpsertArgs} args - Arguments to update or create a Report.
     * @example
     * // Update or create a Report
     * const report = await prisma.report.upsert({
     *   create: {
     *     // ... data to create a Report
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Report we want to update
     *   }
     * })
    **/
    upsert<T extends reportUpsertArgs>(
      args: SelectSubset<T, reportUpsertArgs>
    ): CheckSelect<T, Prisma__reportClient<report>, Prisma__reportClient<reportGetPayload<T>>>

    /**
     * Find one Report that matches the filter or throw
     * `NotFoundError` if no matches were found.
     * @param {reportFindUniqueOrThrowArgs} args - Arguments to find a Report
     * @example
     * // Get one Report
     * const report = await prisma.report.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends reportFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, reportFindUniqueOrThrowArgs>
    ): CheckSelect<T, Prisma__reportClient<report>, Prisma__reportClient<reportGetPayload<T>>>

    /**
     * Find the first Report that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {reportFindFirstOrThrowArgs} args - Arguments to find a Report
     * @example
     * // Get one Report
     * const report = await prisma.report.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends reportFindFirstOrThrowArgs>(
      args?: SelectSubset<T, reportFindFirstOrThrowArgs>
    ): CheckSelect<T, Prisma__reportClient<report>, Prisma__reportClient<reportGetPayload<T>>>

    /**
     * Count the number of Reports.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {reportCountArgs} args - Arguments to filter Reports to count.
     * @example
     * // Count the number of Reports
     * const count = await prisma.report.count({
     *   where: {
     *     // ... the filter for the Reports we want to count
     *   }
     * })
    **/
    count<T extends reportCountArgs>(
      args?: Subset<T, reportCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ReportCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Report.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReportAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ReportAggregateArgs>(args: Subset<T, ReportAggregateArgs>): PrismaPromise<GetReportAggregateType<T>>

    /**
     * Group by Report.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReportGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ReportGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ReportGroupByArgs['orderBy'] }
        : { orderBy?: ReportGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ReportGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetReportGroupByPayload<T> : PrismaPromise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for report.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__reportClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * report base type for findUnique actions
   */
  export type reportFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the report
     * 
    **/
    select?: reportSelect | null
    /**
     * Filter, which report to fetch.
     * 
    **/
    where: reportWhereUniqueInput
  }

  /**
   * report: findUnique
   */
  export interface reportFindUniqueArgs extends reportFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * report base type for findFirst actions
   */
  export type reportFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the report
     * 
    **/
    select?: reportSelect | null
    /**
     * Filter, which report to fetch.
     * 
    **/
    where?: reportWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of reports to fetch.
     * 
    **/
    orderBy?: Enumerable<reportOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for reports.
     * 
    **/
    cursor?: reportWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` reports from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` reports.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of reports.
     * 
    **/
    distinct?: Enumerable<ReportScalarFieldEnum>
  }

  /**
   * report: findFirst
   */
  export interface reportFindFirstArgs extends reportFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * report findMany
   */
  export type reportFindManyArgs = {
    /**
     * Select specific fields to fetch from the report
     * 
    **/
    select?: reportSelect | null
    /**
     * Filter, which reports to fetch.
     * 
    **/
    where?: reportWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of reports to fetch.
     * 
    **/
    orderBy?: Enumerable<reportOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing reports.
     * 
    **/
    cursor?: reportWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` reports from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` reports.
     * 
    **/
    skip?: number
    distinct?: Enumerable<ReportScalarFieldEnum>
  }


  /**
   * report create
   */
  export type reportCreateArgs = {
    /**
     * Select specific fields to fetch from the report
     * 
    **/
    select?: reportSelect | null
    /**
     * The data needed to create a report.
     * 
    **/
    data: XOR<reportCreateInput, reportUncheckedCreateInput>
  }


  /**
   * report createMany
   */
  export type reportCreateManyArgs = {
    /**
     * The data used to create many reports.
     * 
    **/
    data: Enumerable<reportCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * report update
   */
  export type reportUpdateArgs = {
    /**
     * Select specific fields to fetch from the report
     * 
    **/
    select?: reportSelect | null
    /**
     * The data needed to update a report.
     * 
    **/
    data: XOR<reportUpdateInput, reportUncheckedUpdateInput>
    /**
     * Choose, which report to update.
     * 
    **/
    where: reportWhereUniqueInput
  }


  /**
   * report updateMany
   */
  export type reportUpdateManyArgs = {
    /**
     * The data used to update reports.
     * 
    **/
    data: XOR<reportUpdateManyMutationInput, reportUncheckedUpdateManyInput>
    /**
     * Filter which reports to update
     * 
    **/
    where?: reportWhereInput
  }


  /**
   * report upsert
   */
  export type reportUpsertArgs = {
    /**
     * Select specific fields to fetch from the report
     * 
    **/
    select?: reportSelect | null
    /**
     * The filter to search for the report to update in case it exists.
     * 
    **/
    where: reportWhereUniqueInput
    /**
     * In case the report found by the `where` argument doesn't exist, create a new report with this data.
     * 
    **/
    create: XOR<reportCreateInput, reportUncheckedCreateInput>
    /**
     * In case the report was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<reportUpdateInput, reportUncheckedUpdateInput>
  }


  /**
   * report delete
   */
  export type reportDeleteArgs = {
    /**
     * Select specific fields to fetch from the report
     * 
    **/
    select?: reportSelect | null
    /**
     * Filter which report to delete.
     * 
    **/
    where: reportWhereUniqueInput
  }


  /**
   * report deleteMany
   */
  export type reportDeleteManyArgs = {
    /**
     * Filter which reports to delete
     * 
    **/
    where?: reportWhereInput
  }


  /**
   * report: findUniqueOrThrow
   */
  export type reportFindUniqueOrThrowArgs = reportFindUniqueArgsBase
      

  /**
   * report: findFirstOrThrow
   */
  export type reportFindFirstOrThrowArgs = reportFindFirstArgsBase
      

  /**
   * report without action
   */
  export type reportArgs = {
    /**
     * Select specific fields to fetch from the report
     * 
    **/
    select?: reportSelect | null
  }



  /**
   * Model sar
   */


  export type AggregateSar = {
    _count: SarCountAggregateOutputType | null
    _avg: SarAvgAggregateOutputType | null
    _sum: SarSumAggregateOutputType | null
    _min: SarMinAggregateOutputType | null
    _max: SarMaxAggregateOutputType | null
  }

  export type SarAvgAggregateOutputType = {
    SAR_id: number | null
    user_id: number | null
    staff_id: number | null
    office_id: number | null
  }

  export type SarSumAggregateOutputType = {
    SAR_id: number | null
    user_id: number | null
    staff_id: number | null
    office_id: number | null
  }

  export type SarMinAggregateOutputType = {
    SAR_id: number | null
    user_id: number | null
    staff_id: number | null
    office_id: number | null
  }

  export type SarMaxAggregateOutputType = {
    SAR_id: number | null
    user_id: number | null
    staff_id: number | null
    office_id: number | null
  }

  export type SarCountAggregateOutputType = {
    SAR_id: number
    user_id: number
    staff_id: number
    office_id: number
    _all: number
  }


  export type SarAvgAggregateInputType = {
    SAR_id?: true
    user_id?: true
    staff_id?: true
    office_id?: true
  }

  export type SarSumAggregateInputType = {
    SAR_id?: true
    user_id?: true
    staff_id?: true
    office_id?: true
  }

  export type SarMinAggregateInputType = {
    SAR_id?: true
    user_id?: true
    staff_id?: true
    office_id?: true
  }

  export type SarMaxAggregateInputType = {
    SAR_id?: true
    user_id?: true
    staff_id?: true
    office_id?: true
  }

  export type SarCountAggregateInputType = {
    SAR_id?: true
    user_id?: true
    staff_id?: true
    office_id?: true
    _all?: true
  }

  export type SarAggregateArgs = {
    /**
     * Filter which sar to aggregate.
     * 
    **/
    where?: sarWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of sars to fetch.
     * 
    **/
    orderBy?: Enumerable<sarOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: sarWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` sars from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` sars.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned sars
    **/
    _count?: true | SarCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SarAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SarSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SarMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SarMaxAggregateInputType
  }

  export type GetSarAggregateType<T extends SarAggregateArgs> = {
        [P in keyof T & keyof AggregateSar]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSar[P]>
      : GetScalarType<T[P], AggregateSar[P]>
  }




  export type SarGroupByArgs = {
    where?: sarWhereInput
    orderBy?: Enumerable<sarOrderByWithAggregationInput>
    by: Array<SarScalarFieldEnum>
    having?: sarScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SarCountAggregateInputType | true
    _avg?: SarAvgAggregateInputType
    _sum?: SarSumAggregateInputType
    _min?: SarMinAggregateInputType
    _max?: SarMaxAggregateInputType
  }


  export type SarGroupByOutputType = {
    SAR_id: number
    user_id: number
    staff_id: number
    office_id: number
    _count: SarCountAggregateOutputType | null
    _avg: SarAvgAggregateOutputType | null
    _sum: SarSumAggregateOutputType | null
    _min: SarMinAggregateOutputType | null
    _max: SarMaxAggregateOutputType | null
  }

  type GetSarGroupByPayload<T extends SarGroupByArgs> = PrismaPromise<
    Array<
      PickArray<SarGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SarGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SarGroupByOutputType[P]>
            : GetScalarType<T[P], SarGroupByOutputType[P]>
        }
      >
    >


  export type sarSelect = {
    SAR_id?: boolean
    user_id?: boolean
    staff_id?: boolean
    office_id?: boolean
  }

  export type sarGetPayload<
    S extends boolean | null | undefined | sarArgs,
    U = keyof S
      > = S extends true
        ? sar
    : S extends undefined
    ? never
    : S extends sarArgs | sarFindManyArgs
    ?'include' extends U
    ? sar 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
    P extends keyof sar ? sar[P] : never
  } 
    : sar
  : sar


  type sarCountArgs = Merge<
    Omit<sarFindManyArgs, 'select' | 'include'> & {
      select?: SarCountAggregateInputType | true
    }
  >

  export interface sarDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one Sar that matches the filter.
     * @param {sarFindUniqueArgs} args - Arguments to find a Sar
     * @example
     * // Get one Sar
     * const sar = await prisma.sar.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends sarFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, sarFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'sar'> extends True ? CheckSelect<T, Prisma__sarClient<sar>, Prisma__sarClient<sarGetPayload<T>>> : CheckSelect<T, Prisma__sarClient<sar | null >, Prisma__sarClient<sarGetPayload<T> | null >>

    /**
     * Find the first Sar that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {sarFindFirstArgs} args - Arguments to find a Sar
     * @example
     * // Get one Sar
     * const sar = await prisma.sar.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends sarFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, sarFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'sar'> extends True ? CheckSelect<T, Prisma__sarClient<sar>, Prisma__sarClient<sarGetPayload<T>>> : CheckSelect<T, Prisma__sarClient<sar | null >, Prisma__sarClient<sarGetPayload<T> | null >>

    /**
     * Find zero or more Sars that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {sarFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Sars
     * const sars = await prisma.sar.findMany()
     * 
     * // Get first 10 Sars
     * const sars = await prisma.sar.findMany({ take: 10 })
     * 
     * // Only select the `SAR_id`
     * const sarWithSAR_idOnly = await prisma.sar.findMany({ select: { SAR_id: true } })
     * 
    **/
    findMany<T extends sarFindManyArgs>(
      args?: SelectSubset<T, sarFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<sar>>, PrismaPromise<Array<sarGetPayload<T>>>>

    /**
     * Create a Sar.
     * @param {sarCreateArgs} args - Arguments to create a Sar.
     * @example
     * // Create one Sar
     * const Sar = await prisma.sar.create({
     *   data: {
     *     // ... data to create a Sar
     *   }
     * })
     * 
    **/
    create<T extends sarCreateArgs>(
      args: SelectSubset<T, sarCreateArgs>
    ): CheckSelect<T, Prisma__sarClient<sar>, Prisma__sarClient<sarGetPayload<T>>>

    /**
     * Create many Sars.
     *     @param {sarCreateManyArgs} args - Arguments to create many Sars.
     *     @example
     *     // Create many Sars
     *     const sar = await prisma.sar.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends sarCreateManyArgs>(
      args?: SelectSubset<T, sarCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Sar.
     * @param {sarDeleteArgs} args - Arguments to delete one Sar.
     * @example
     * // Delete one Sar
     * const Sar = await prisma.sar.delete({
     *   where: {
     *     // ... filter to delete one Sar
     *   }
     * })
     * 
    **/
    delete<T extends sarDeleteArgs>(
      args: SelectSubset<T, sarDeleteArgs>
    ): CheckSelect<T, Prisma__sarClient<sar>, Prisma__sarClient<sarGetPayload<T>>>

    /**
     * Update one Sar.
     * @param {sarUpdateArgs} args - Arguments to update one Sar.
     * @example
     * // Update one Sar
     * const sar = await prisma.sar.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends sarUpdateArgs>(
      args: SelectSubset<T, sarUpdateArgs>
    ): CheckSelect<T, Prisma__sarClient<sar>, Prisma__sarClient<sarGetPayload<T>>>

    /**
     * Delete zero or more Sars.
     * @param {sarDeleteManyArgs} args - Arguments to filter Sars to delete.
     * @example
     * // Delete a few Sars
     * const { count } = await prisma.sar.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends sarDeleteManyArgs>(
      args?: SelectSubset<T, sarDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Sars.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {sarUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Sars
     * const sar = await prisma.sar.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends sarUpdateManyArgs>(
      args: SelectSubset<T, sarUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Sar.
     * @param {sarUpsertArgs} args - Arguments to update or create a Sar.
     * @example
     * // Update or create a Sar
     * const sar = await prisma.sar.upsert({
     *   create: {
     *     // ... data to create a Sar
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Sar we want to update
     *   }
     * })
    **/
    upsert<T extends sarUpsertArgs>(
      args: SelectSubset<T, sarUpsertArgs>
    ): CheckSelect<T, Prisma__sarClient<sar>, Prisma__sarClient<sarGetPayload<T>>>

    /**
     * Find one Sar that matches the filter or throw
     * `NotFoundError` if no matches were found.
     * @param {sarFindUniqueOrThrowArgs} args - Arguments to find a Sar
     * @example
     * // Get one Sar
     * const sar = await prisma.sar.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends sarFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, sarFindUniqueOrThrowArgs>
    ): CheckSelect<T, Prisma__sarClient<sar>, Prisma__sarClient<sarGetPayload<T>>>

    /**
     * Find the first Sar that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {sarFindFirstOrThrowArgs} args - Arguments to find a Sar
     * @example
     * // Get one Sar
     * const sar = await prisma.sar.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends sarFindFirstOrThrowArgs>(
      args?: SelectSubset<T, sarFindFirstOrThrowArgs>
    ): CheckSelect<T, Prisma__sarClient<sar>, Prisma__sarClient<sarGetPayload<T>>>

    /**
     * Count the number of Sars.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {sarCountArgs} args - Arguments to filter Sars to count.
     * @example
     * // Count the number of Sars
     * const count = await prisma.sar.count({
     *   where: {
     *     // ... the filter for the Sars we want to count
     *   }
     * })
    **/
    count<T extends sarCountArgs>(
      args?: Subset<T, sarCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SarCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Sar.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SarAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SarAggregateArgs>(args: Subset<T, SarAggregateArgs>): PrismaPromise<GetSarAggregateType<T>>

    /**
     * Group by Sar.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SarGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SarGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SarGroupByArgs['orderBy'] }
        : { orderBy?: SarGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SarGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSarGroupByPayload<T> : PrismaPromise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for sar.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__sarClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * sar base type for findUnique actions
   */
  export type sarFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the sar
     * 
    **/
    select?: sarSelect | null
    /**
     * Filter, which sar to fetch.
     * 
    **/
    where: sarWhereUniqueInput
  }

  /**
   * sar: findUnique
   */
  export interface sarFindUniqueArgs extends sarFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * sar base type for findFirst actions
   */
  export type sarFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the sar
     * 
    **/
    select?: sarSelect | null
    /**
     * Filter, which sar to fetch.
     * 
    **/
    where?: sarWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of sars to fetch.
     * 
    **/
    orderBy?: Enumerable<sarOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for sars.
     * 
    **/
    cursor?: sarWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` sars from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` sars.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of sars.
     * 
    **/
    distinct?: Enumerable<SarScalarFieldEnum>
  }

  /**
   * sar: findFirst
   */
  export interface sarFindFirstArgs extends sarFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * sar findMany
   */
  export type sarFindManyArgs = {
    /**
     * Select specific fields to fetch from the sar
     * 
    **/
    select?: sarSelect | null
    /**
     * Filter, which sars to fetch.
     * 
    **/
    where?: sarWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of sars to fetch.
     * 
    **/
    orderBy?: Enumerable<sarOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing sars.
     * 
    **/
    cursor?: sarWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` sars from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` sars.
     * 
    **/
    skip?: number
    distinct?: Enumerable<SarScalarFieldEnum>
  }


  /**
   * sar create
   */
  export type sarCreateArgs = {
    /**
     * Select specific fields to fetch from the sar
     * 
    **/
    select?: sarSelect | null
    /**
     * The data needed to create a sar.
     * 
    **/
    data: XOR<sarCreateInput, sarUncheckedCreateInput>
  }


  /**
   * sar createMany
   */
  export type sarCreateManyArgs = {
    /**
     * The data used to create many sars.
     * 
    **/
    data: Enumerable<sarCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * sar update
   */
  export type sarUpdateArgs = {
    /**
     * Select specific fields to fetch from the sar
     * 
    **/
    select?: sarSelect | null
    /**
     * The data needed to update a sar.
     * 
    **/
    data: XOR<sarUpdateInput, sarUncheckedUpdateInput>
    /**
     * Choose, which sar to update.
     * 
    **/
    where: sarWhereUniqueInput
  }


  /**
   * sar updateMany
   */
  export type sarUpdateManyArgs = {
    /**
     * The data used to update sars.
     * 
    **/
    data: XOR<sarUpdateManyMutationInput, sarUncheckedUpdateManyInput>
    /**
     * Filter which sars to update
     * 
    **/
    where?: sarWhereInput
  }


  /**
   * sar upsert
   */
  export type sarUpsertArgs = {
    /**
     * Select specific fields to fetch from the sar
     * 
    **/
    select?: sarSelect | null
    /**
     * The filter to search for the sar to update in case it exists.
     * 
    **/
    where: sarWhereUniqueInput
    /**
     * In case the sar found by the `where` argument doesn't exist, create a new sar with this data.
     * 
    **/
    create: XOR<sarCreateInput, sarUncheckedCreateInput>
    /**
     * In case the sar was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<sarUpdateInput, sarUncheckedUpdateInput>
  }


  /**
   * sar delete
   */
  export type sarDeleteArgs = {
    /**
     * Select specific fields to fetch from the sar
     * 
    **/
    select?: sarSelect | null
    /**
     * Filter which sar to delete.
     * 
    **/
    where: sarWhereUniqueInput
  }


  /**
   * sar deleteMany
   */
  export type sarDeleteManyArgs = {
    /**
     * Filter which sars to delete
     * 
    **/
    where?: sarWhereInput
  }


  /**
   * sar: findUniqueOrThrow
   */
  export type sarFindUniqueOrThrowArgs = sarFindUniqueArgsBase
      

  /**
   * sar: findFirstOrThrow
   */
  export type sarFindFirstOrThrowArgs = sarFindFirstArgsBase
      

  /**
   * sar without action
   */
  export type sarArgs = {
    /**
     * Select specific fields to fetch from the sar
     * 
    **/
    select?: sarSelect | null
  }



  /**
   * Model staff
   */


  export type AggregateStaff = {
    _count: StaffCountAggregateOutputType | null
    _avg: StaffAvgAggregateOutputType | null
    _sum: StaffSumAggregateOutputType | null
    _min: StaffMinAggregateOutputType | null
    _max: StaffMaxAggregateOutputType | null
  }

  export type StaffAvgAggregateOutputType = {
    staff_id: number | null
    user_id: number | null
  }

  export type StaffSumAggregateOutputType = {
    staff_id: number | null
    user_id: number | null
  }

  export type StaffMinAggregateOutputType = {
    staff_id: number | null
    user_id: number | null
  }

  export type StaffMaxAggregateOutputType = {
    staff_id: number | null
    user_id: number | null
  }

  export type StaffCountAggregateOutputType = {
    staff_id: number
    user_id: number
    _all: number
  }


  export type StaffAvgAggregateInputType = {
    staff_id?: true
    user_id?: true
  }

  export type StaffSumAggregateInputType = {
    staff_id?: true
    user_id?: true
  }

  export type StaffMinAggregateInputType = {
    staff_id?: true
    user_id?: true
  }

  export type StaffMaxAggregateInputType = {
    staff_id?: true
    user_id?: true
  }

  export type StaffCountAggregateInputType = {
    staff_id?: true
    user_id?: true
    _all?: true
  }

  export type StaffAggregateArgs = {
    /**
     * Filter which staff to aggregate.
     * 
    **/
    where?: staffWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of staff to fetch.
     * 
    **/
    orderBy?: Enumerable<staffOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: staffWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` staff from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` staff.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned staff
    **/
    _count?: true | StaffCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: StaffAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: StaffSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: StaffMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: StaffMaxAggregateInputType
  }

  export type GetStaffAggregateType<T extends StaffAggregateArgs> = {
        [P in keyof T & keyof AggregateStaff]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateStaff[P]>
      : GetScalarType<T[P], AggregateStaff[P]>
  }




  export type StaffGroupByArgs = {
    where?: staffWhereInput
    orderBy?: Enumerable<staffOrderByWithAggregationInput>
    by: Array<StaffScalarFieldEnum>
    having?: staffScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: StaffCountAggregateInputType | true
    _avg?: StaffAvgAggregateInputType
    _sum?: StaffSumAggregateInputType
    _min?: StaffMinAggregateInputType
    _max?: StaffMaxAggregateInputType
  }


  export type StaffGroupByOutputType = {
    staff_id: number
    user_id: number
    _count: StaffCountAggregateOutputType | null
    _avg: StaffAvgAggregateOutputType | null
    _sum: StaffSumAggregateOutputType | null
    _min: StaffMinAggregateOutputType | null
    _max: StaffMaxAggregateOutputType | null
  }

  type GetStaffGroupByPayload<T extends StaffGroupByArgs> = PrismaPromise<
    Array<
      PickArray<StaffGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof StaffGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], StaffGroupByOutputType[P]>
            : GetScalarType<T[P], StaffGroupByOutputType[P]>
        }
      >
    >


  export type staffSelect = {
    staff_id?: boolean
    user_id?: boolean
  }

  export type staffGetPayload<
    S extends boolean | null | undefined | staffArgs,
    U = keyof S
      > = S extends true
        ? staff
    : S extends undefined
    ? never
    : S extends staffArgs | staffFindManyArgs
    ?'include' extends U
    ? staff 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
    P extends keyof staff ? staff[P] : never
  } 
    : staff
  : staff


  type staffCountArgs = Merge<
    Omit<staffFindManyArgs, 'select' | 'include'> & {
      select?: StaffCountAggregateInputType | true
    }
  >

  export interface staffDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one Staff that matches the filter.
     * @param {staffFindUniqueArgs} args - Arguments to find a Staff
     * @example
     * // Get one Staff
     * const staff = await prisma.staff.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends staffFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, staffFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'staff'> extends True ? CheckSelect<T, Prisma__staffClient<staff>, Prisma__staffClient<staffGetPayload<T>>> : CheckSelect<T, Prisma__staffClient<staff | null >, Prisma__staffClient<staffGetPayload<T> | null >>

    /**
     * Find the first Staff that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {staffFindFirstArgs} args - Arguments to find a Staff
     * @example
     * // Get one Staff
     * const staff = await prisma.staff.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends staffFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, staffFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'staff'> extends True ? CheckSelect<T, Prisma__staffClient<staff>, Prisma__staffClient<staffGetPayload<T>>> : CheckSelect<T, Prisma__staffClient<staff | null >, Prisma__staffClient<staffGetPayload<T> | null >>

    /**
     * Find zero or more Staff that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {staffFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Staff
     * const staff = await prisma.staff.findMany()
     * 
     * // Get first 10 Staff
     * const staff = await prisma.staff.findMany({ take: 10 })
     * 
     * // Only select the `staff_id`
     * const staffWithStaff_idOnly = await prisma.staff.findMany({ select: { staff_id: true } })
     * 
    **/
    findMany<T extends staffFindManyArgs>(
      args?: SelectSubset<T, staffFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<staff>>, PrismaPromise<Array<staffGetPayload<T>>>>

    /**
     * Create a Staff.
     * @param {staffCreateArgs} args - Arguments to create a Staff.
     * @example
     * // Create one Staff
     * const Staff = await prisma.staff.create({
     *   data: {
     *     // ... data to create a Staff
     *   }
     * })
     * 
    **/
    create<T extends staffCreateArgs>(
      args: SelectSubset<T, staffCreateArgs>
    ): CheckSelect<T, Prisma__staffClient<staff>, Prisma__staffClient<staffGetPayload<T>>>

    /**
     * Create many Staff.
     *     @param {staffCreateManyArgs} args - Arguments to create many Staff.
     *     @example
     *     // Create many Staff
     *     const staff = await prisma.staff.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends staffCreateManyArgs>(
      args?: SelectSubset<T, staffCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Staff.
     * @param {staffDeleteArgs} args - Arguments to delete one Staff.
     * @example
     * // Delete one Staff
     * const Staff = await prisma.staff.delete({
     *   where: {
     *     // ... filter to delete one Staff
     *   }
     * })
     * 
    **/
    delete<T extends staffDeleteArgs>(
      args: SelectSubset<T, staffDeleteArgs>
    ): CheckSelect<T, Prisma__staffClient<staff>, Prisma__staffClient<staffGetPayload<T>>>

    /**
     * Update one Staff.
     * @param {staffUpdateArgs} args - Arguments to update one Staff.
     * @example
     * // Update one Staff
     * const staff = await prisma.staff.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends staffUpdateArgs>(
      args: SelectSubset<T, staffUpdateArgs>
    ): CheckSelect<T, Prisma__staffClient<staff>, Prisma__staffClient<staffGetPayload<T>>>

    /**
     * Delete zero or more Staff.
     * @param {staffDeleteManyArgs} args - Arguments to filter Staff to delete.
     * @example
     * // Delete a few Staff
     * const { count } = await prisma.staff.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends staffDeleteManyArgs>(
      args?: SelectSubset<T, staffDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Staff.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {staffUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Staff
     * const staff = await prisma.staff.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends staffUpdateManyArgs>(
      args: SelectSubset<T, staffUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Staff.
     * @param {staffUpsertArgs} args - Arguments to update or create a Staff.
     * @example
     * // Update or create a Staff
     * const staff = await prisma.staff.upsert({
     *   create: {
     *     // ... data to create a Staff
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Staff we want to update
     *   }
     * })
    **/
    upsert<T extends staffUpsertArgs>(
      args: SelectSubset<T, staffUpsertArgs>
    ): CheckSelect<T, Prisma__staffClient<staff>, Prisma__staffClient<staffGetPayload<T>>>

    /**
     * Find one Staff that matches the filter or throw
     * `NotFoundError` if no matches were found.
     * @param {staffFindUniqueOrThrowArgs} args - Arguments to find a Staff
     * @example
     * // Get one Staff
     * const staff = await prisma.staff.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends staffFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, staffFindUniqueOrThrowArgs>
    ): CheckSelect<T, Prisma__staffClient<staff>, Prisma__staffClient<staffGetPayload<T>>>

    /**
     * Find the first Staff that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {staffFindFirstOrThrowArgs} args - Arguments to find a Staff
     * @example
     * // Get one Staff
     * const staff = await prisma.staff.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends staffFindFirstOrThrowArgs>(
      args?: SelectSubset<T, staffFindFirstOrThrowArgs>
    ): CheckSelect<T, Prisma__staffClient<staff>, Prisma__staffClient<staffGetPayload<T>>>

    /**
     * Count the number of Staff.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {staffCountArgs} args - Arguments to filter Staff to count.
     * @example
     * // Count the number of Staff
     * const count = await prisma.staff.count({
     *   where: {
     *     // ... the filter for the Staff we want to count
     *   }
     * })
    **/
    count<T extends staffCountArgs>(
      args?: Subset<T, staffCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], StaffCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Staff.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StaffAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends StaffAggregateArgs>(args: Subset<T, StaffAggregateArgs>): PrismaPromise<GetStaffAggregateType<T>>

    /**
     * Group by Staff.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StaffGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends StaffGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: StaffGroupByArgs['orderBy'] }
        : { orderBy?: StaffGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, StaffGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetStaffGroupByPayload<T> : PrismaPromise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for staff.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__staffClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * staff base type for findUnique actions
   */
  export type staffFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the staff
     * 
    **/
    select?: staffSelect | null
    /**
     * Filter, which staff to fetch.
     * 
    **/
    where: staffWhereUniqueInput
  }

  /**
   * staff: findUnique
   */
  export interface staffFindUniqueArgs extends staffFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * staff base type for findFirst actions
   */
  export type staffFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the staff
     * 
    **/
    select?: staffSelect | null
    /**
     * Filter, which staff to fetch.
     * 
    **/
    where?: staffWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of staff to fetch.
     * 
    **/
    orderBy?: Enumerable<staffOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for staff.
     * 
    **/
    cursor?: staffWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` staff from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` staff.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of staff.
     * 
    **/
    distinct?: Enumerable<StaffScalarFieldEnum>
  }

  /**
   * staff: findFirst
   */
  export interface staffFindFirstArgs extends staffFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * staff findMany
   */
  export type staffFindManyArgs = {
    /**
     * Select specific fields to fetch from the staff
     * 
    **/
    select?: staffSelect | null
    /**
     * Filter, which staff to fetch.
     * 
    **/
    where?: staffWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of staff to fetch.
     * 
    **/
    orderBy?: Enumerable<staffOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing staff.
     * 
    **/
    cursor?: staffWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` staff from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` staff.
     * 
    **/
    skip?: number
    distinct?: Enumerable<StaffScalarFieldEnum>
  }


  /**
   * staff create
   */
  export type staffCreateArgs = {
    /**
     * Select specific fields to fetch from the staff
     * 
    **/
    select?: staffSelect | null
    /**
     * The data needed to create a staff.
     * 
    **/
    data: XOR<staffCreateInput, staffUncheckedCreateInput>
  }


  /**
   * staff createMany
   */
  export type staffCreateManyArgs = {
    /**
     * The data used to create many staff.
     * 
    **/
    data: Enumerable<staffCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * staff update
   */
  export type staffUpdateArgs = {
    /**
     * Select specific fields to fetch from the staff
     * 
    **/
    select?: staffSelect | null
    /**
     * The data needed to update a staff.
     * 
    **/
    data: XOR<staffUpdateInput, staffUncheckedUpdateInput>
    /**
     * Choose, which staff to update.
     * 
    **/
    where: staffWhereUniqueInput
  }


  /**
   * staff updateMany
   */
  export type staffUpdateManyArgs = {
    /**
     * The data used to update staff.
     * 
    **/
    data: XOR<staffUpdateManyMutationInput, staffUncheckedUpdateManyInput>
    /**
     * Filter which staff to update
     * 
    **/
    where?: staffWhereInput
  }


  /**
   * staff upsert
   */
  export type staffUpsertArgs = {
    /**
     * Select specific fields to fetch from the staff
     * 
    **/
    select?: staffSelect | null
    /**
     * The filter to search for the staff to update in case it exists.
     * 
    **/
    where: staffWhereUniqueInput
    /**
     * In case the staff found by the `where` argument doesn't exist, create a new staff with this data.
     * 
    **/
    create: XOR<staffCreateInput, staffUncheckedCreateInput>
    /**
     * In case the staff was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<staffUpdateInput, staffUncheckedUpdateInput>
  }


  /**
   * staff delete
   */
  export type staffDeleteArgs = {
    /**
     * Select specific fields to fetch from the staff
     * 
    **/
    select?: staffSelect | null
    /**
     * Filter which staff to delete.
     * 
    **/
    where: staffWhereUniqueInput
  }


  /**
   * staff deleteMany
   */
  export type staffDeleteManyArgs = {
    /**
     * Filter which staff to delete
     * 
    **/
    where?: staffWhereInput
  }


  /**
   * staff: findUniqueOrThrow
   */
  export type staffFindUniqueOrThrowArgs = staffFindUniqueArgsBase
      

  /**
   * staff: findFirstOrThrow
   */
  export type staffFindFirstOrThrowArgs = staffFindFirstArgsBase
      

  /**
   * staff without action
   */
  export type staffArgs = {
    /**
     * Select specific fields to fetch from the staff
     * 
    **/
    select?: staffSelect | null
  }



  /**
   * Model student
   */


  export type AggregateStudent = {
    _count: StudentCountAggregateOutputType | null
    _avg: StudentAvgAggregateOutputType | null
    _sum: StudentSumAggregateOutputType | null
    _min: StudentMinAggregateOutputType | null
    _max: StudentMaxAggregateOutputType | null
  }

  export type StudentAvgAggregateOutputType = {
    index_no: number | null
    user_id: number | null
    student_temp_no: number | null
    AL_index_no: number | null
    rank: number | null
    GPA: number | null
    ac_year_ID: number | null
  }

  export type StudentSumAggregateOutputType = {
    index_no: number | null
    user_id: number | null
    student_temp_no: number | null
    AL_index_no: number | null
    rank: number | null
    GPA: number | null
    ac_year_ID: number | null
  }

  export type StudentMinAggregateOutputType = {
    index_no: number | null
    user_id: number | null
    nic: string | null
    gender: string | null
    initials: string | null
    title: string | null
    general_eng: string | null
    district_no: string | null
    intake: string | null
    reg_no: string | null
    telep_1: string | null
    telep_2: string | null
    address_no: string | null
    address_city: string | null
    address_street: string | null
    address_4: string | null
    student_temp_no: number | null
    district_name: string | null
    name_initial: string | null
    full_name: string | null
    syllabus: string | null
    AL_index_no: number | null
    rank: number | null
    GPA: number | null
    ac_year_ID: number | null
  }

  export type StudentMaxAggregateOutputType = {
    index_no: number | null
    user_id: number | null
    nic: string | null
    gender: string | null
    initials: string | null
    title: string | null
    general_eng: string | null
    district_no: string | null
    intake: string | null
    reg_no: string | null
    telep_1: string | null
    telep_2: string | null
    address_no: string | null
    address_city: string | null
    address_street: string | null
    address_4: string | null
    student_temp_no: number | null
    district_name: string | null
    name_initial: string | null
    full_name: string | null
    syllabus: string | null
    AL_index_no: number | null
    rank: number | null
    GPA: number | null
    ac_year_ID: number | null
  }

  export type StudentCountAggregateOutputType = {
    index_no: number
    user_id: number
    nic: number
    gender: number
    initials: number
    title: number
    general_eng: number
    district_no: number
    intake: number
    reg_no: number
    telep_1: number
    telep_2: number
    address_no: number
    address_city: number
    address_street: number
    address_4: number
    student_temp_no: number
    district_name: number
    name_initial: number
    full_name: number
    syllabus: number
    AL_index_no: number
    rank: number
    GPA: number
    ac_year_ID: number
    _all: number
  }


  export type StudentAvgAggregateInputType = {
    index_no?: true
    user_id?: true
    student_temp_no?: true
    AL_index_no?: true
    rank?: true
    GPA?: true
    ac_year_ID?: true
  }

  export type StudentSumAggregateInputType = {
    index_no?: true
    user_id?: true
    student_temp_no?: true
    AL_index_no?: true
    rank?: true
    GPA?: true
    ac_year_ID?: true
  }

  export type StudentMinAggregateInputType = {
    index_no?: true
    user_id?: true
    nic?: true
    gender?: true
    initials?: true
    title?: true
    general_eng?: true
    district_no?: true
    intake?: true
    reg_no?: true
    telep_1?: true
    telep_2?: true
    address_no?: true
    address_city?: true
    address_street?: true
    address_4?: true
    student_temp_no?: true
    district_name?: true
    name_initial?: true
    full_name?: true
    syllabus?: true
    AL_index_no?: true
    rank?: true
    GPA?: true
    ac_year_ID?: true
  }

  export type StudentMaxAggregateInputType = {
    index_no?: true
    user_id?: true
    nic?: true
    gender?: true
    initials?: true
    title?: true
    general_eng?: true
    district_no?: true
    intake?: true
    reg_no?: true
    telep_1?: true
    telep_2?: true
    address_no?: true
    address_city?: true
    address_street?: true
    address_4?: true
    student_temp_no?: true
    district_name?: true
    name_initial?: true
    full_name?: true
    syllabus?: true
    AL_index_no?: true
    rank?: true
    GPA?: true
    ac_year_ID?: true
  }

  export type StudentCountAggregateInputType = {
    index_no?: true
    user_id?: true
    nic?: true
    gender?: true
    initials?: true
    title?: true
    general_eng?: true
    district_no?: true
    intake?: true
    reg_no?: true
    telep_1?: true
    telep_2?: true
    address_no?: true
    address_city?: true
    address_street?: true
    address_4?: true
    student_temp_no?: true
    district_name?: true
    name_initial?: true
    full_name?: true
    syllabus?: true
    AL_index_no?: true
    rank?: true
    GPA?: true
    ac_year_ID?: true
    _all?: true
  }

  export type StudentAggregateArgs = {
    /**
     * Filter which student to aggregate.
     * 
    **/
    where?: studentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of students to fetch.
     * 
    **/
    orderBy?: Enumerable<studentOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: studentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` students from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` students.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned students
    **/
    _count?: true | StudentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: StudentAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: StudentSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: StudentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: StudentMaxAggregateInputType
  }

  export type GetStudentAggregateType<T extends StudentAggregateArgs> = {
        [P in keyof T & keyof AggregateStudent]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateStudent[P]>
      : GetScalarType<T[P], AggregateStudent[P]>
  }




  export type StudentGroupByArgs = {
    where?: studentWhereInput
    orderBy?: Enumerable<studentOrderByWithAggregationInput>
    by: Array<StudentScalarFieldEnum>
    having?: studentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: StudentCountAggregateInputType | true
    _avg?: StudentAvgAggregateInputType
    _sum?: StudentSumAggregateInputType
    _min?: StudentMinAggregateInputType
    _max?: StudentMaxAggregateInputType
  }


  export type StudentGroupByOutputType = {
    index_no: number
    user_id: number
    nic: string
    gender: string
    initials: string
    title: string
    general_eng: string
    district_no: string
    intake: string
    reg_no: string
    telep_1: string
    telep_2: string
    address_no: string
    address_city: string
    address_street: string
    address_4: string
    student_temp_no: number
    district_name: string
    name_initial: string
    full_name: string
    syllabus: string
    AL_index_no: number
    rank: number
    GPA: number
    ac_year_ID: number
    _count: StudentCountAggregateOutputType | null
    _avg: StudentAvgAggregateOutputType | null
    _sum: StudentSumAggregateOutputType | null
    _min: StudentMinAggregateOutputType | null
    _max: StudentMaxAggregateOutputType | null
  }

  type GetStudentGroupByPayload<T extends StudentGroupByArgs> = PrismaPromise<
    Array<
      PickArray<StudentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof StudentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], StudentGroupByOutputType[P]>
            : GetScalarType<T[P], StudentGroupByOutputType[P]>
        }
      >
    >


  export type studentSelect = {
    index_no?: boolean
    user_id?: boolean
    nic?: boolean
    gender?: boolean
    initials?: boolean
    title?: boolean
    general_eng?: boolean
    district_no?: boolean
    intake?: boolean
    reg_no?: boolean
    telep_1?: boolean
    telep_2?: boolean
    address_no?: boolean
    address_city?: boolean
    address_street?: boolean
    address_4?: boolean
    student_temp_no?: boolean
    district_name?: boolean
    name_initial?: boolean
    full_name?: boolean
    syllabus?: boolean
    AL_index_no?: boolean
    rank?: boolean
    GPA?: boolean
    ac_year_ID?: boolean
  }

  export type studentGetPayload<
    S extends boolean | null | undefined | studentArgs,
    U = keyof S
      > = S extends true
        ? student
    : S extends undefined
    ? never
    : S extends studentArgs | studentFindManyArgs
    ?'include' extends U
    ? student 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
    P extends keyof student ? student[P] : never
  } 
    : student
  : student


  type studentCountArgs = Merge<
    Omit<studentFindManyArgs, 'select' | 'include'> & {
      select?: StudentCountAggregateInputType | true
    }
  >

  export interface studentDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one Student that matches the filter.
     * @param {studentFindUniqueArgs} args - Arguments to find a Student
     * @example
     * // Get one Student
     * const student = await prisma.student.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends studentFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, studentFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'student'> extends True ? CheckSelect<T, Prisma__studentClient<student>, Prisma__studentClient<studentGetPayload<T>>> : CheckSelect<T, Prisma__studentClient<student | null >, Prisma__studentClient<studentGetPayload<T> | null >>

    /**
     * Find the first Student that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {studentFindFirstArgs} args - Arguments to find a Student
     * @example
     * // Get one Student
     * const student = await prisma.student.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends studentFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, studentFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'student'> extends True ? CheckSelect<T, Prisma__studentClient<student>, Prisma__studentClient<studentGetPayload<T>>> : CheckSelect<T, Prisma__studentClient<student | null >, Prisma__studentClient<studentGetPayload<T> | null >>

    /**
     * Find zero or more Students that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {studentFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Students
     * const students = await prisma.student.findMany()
     * 
     * // Get first 10 Students
     * const students = await prisma.student.findMany({ take: 10 })
     * 
     * // Only select the `index_no`
     * const studentWithIndex_noOnly = await prisma.student.findMany({ select: { index_no: true } })
     * 
    **/
    findMany<T extends studentFindManyArgs>(
      args?: SelectSubset<T, studentFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<student>>, PrismaPromise<Array<studentGetPayload<T>>>>

    /**
     * Create a Student.
     * @param {studentCreateArgs} args - Arguments to create a Student.
     * @example
     * // Create one Student
     * const Student = await prisma.student.create({
     *   data: {
     *     // ... data to create a Student
     *   }
     * })
     * 
    **/
    create<T extends studentCreateArgs>(
      args: SelectSubset<T, studentCreateArgs>
    ): CheckSelect<T, Prisma__studentClient<student>, Prisma__studentClient<studentGetPayload<T>>>

    /**
     * Create many Students.
     *     @param {studentCreateManyArgs} args - Arguments to create many Students.
     *     @example
     *     // Create many Students
     *     const student = await prisma.student.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends studentCreateManyArgs>(
      args?: SelectSubset<T, studentCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Student.
     * @param {studentDeleteArgs} args - Arguments to delete one Student.
     * @example
     * // Delete one Student
     * const Student = await prisma.student.delete({
     *   where: {
     *     // ... filter to delete one Student
     *   }
     * })
     * 
    **/
    delete<T extends studentDeleteArgs>(
      args: SelectSubset<T, studentDeleteArgs>
    ): CheckSelect<T, Prisma__studentClient<student>, Prisma__studentClient<studentGetPayload<T>>>

    /**
     * Update one Student.
     * @param {studentUpdateArgs} args - Arguments to update one Student.
     * @example
     * // Update one Student
     * const student = await prisma.student.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends studentUpdateArgs>(
      args: SelectSubset<T, studentUpdateArgs>
    ): CheckSelect<T, Prisma__studentClient<student>, Prisma__studentClient<studentGetPayload<T>>>

    /**
     * Delete zero or more Students.
     * @param {studentDeleteManyArgs} args - Arguments to filter Students to delete.
     * @example
     * // Delete a few Students
     * const { count } = await prisma.student.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends studentDeleteManyArgs>(
      args?: SelectSubset<T, studentDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Students.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {studentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Students
     * const student = await prisma.student.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends studentUpdateManyArgs>(
      args: SelectSubset<T, studentUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Student.
     * @param {studentUpsertArgs} args - Arguments to update or create a Student.
     * @example
     * // Update or create a Student
     * const student = await prisma.student.upsert({
     *   create: {
     *     // ... data to create a Student
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Student we want to update
     *   }
     * })
    **/
    upsert<T extends studentUpsertArgs>(
      args: SelectSubset<T, studentUpsertArgs>
    ): CheckSelect<T, Prisma__studentClient<student>, Prisma__studentClient<studentGetPayload<T>>>

    /**
     * Find one Student that matches the filter or throw
     * `NotFoundError` if no matches were found.
     * @param {studentFindUniqueOrThrowArgs} args - Arguments to find a Student
     * @example
     * // Get one Student
     * const student = await prisma.student.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends studentFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, studentFindUniqueOrThrowArgs>
    ): CheckSelect<T, Prisma__studentClient<student>, Prisma__studentClient<studentGetPayload<T>>>

    /**
     * Find the first Student that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {studentFindFirstOrThrowArgs} args - Arguments to find a Student
     * @example
     * // Get one Student
     * const student = await prisma.student.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends studentFindFirstOrThrowArgs>(
      args?: SelectSubset<T, studentFindFirstOrThrowArgs>
    ): CheckSelect<T, Prisma__studentClient<student>, Prisma__studentClient<studentGetPayload<T>>>

    /**
     * Count the number of Students.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {studentCountArgs} args - Arguments to filter Students to count.
     * @example
     * // Count the number of Students
     * const count = await prisma.student.count({
     *   where: {
     *     // ... the filter for the Students we want to count
     *   }
     * })
    **/
    count<T extends studentCountArgs>(
      args?: Subset<T, studentCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], StudentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Student.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends StudentAggregateArgs>(args: Subset<T, StudentAggregateArgs>): PrismaPromise<GetStudentAggregateType<T>>

    /**
     * Group by Student.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends StudentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: StudentGroupByArgs['orderBy'] }
        : { orderBy?: StudentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, StudentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetStudentGroupByPayload<T> : PrismaPromise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for student.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__studentClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * student base type for findUnique actions
   */
  export type studentFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the student
     * 
    **/
    select?: studentSelect | null
    /**
     * Filter, which student to fetch.
     * 
    **/
    where: studentWhereUniqueInput
  }

  /**
   * student: findUnique
   */
  export interface studentFindUniqueArgs extends studentFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * student base type for findFirst actions
   */
  export type studentFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the student
     * 
    **/
    select?: studentSelect | null
    /**
     * Filter, which student to fetch.
     * 
    **/
    where?: studentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of students to fetch.
     * 
    **/
    orderBy?: Enumerable<studentOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for students.
     * 
    **/
    cursor?: studentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` students from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` students.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of students.
     * 
    **/
    distinct?: Enumerable<StudentScalarFieldEnum>
  }

  /**
   * student: findFirst
   */
  export interface studentFindFirstArgs extends studentFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * student findMany
   */
  export type studentFindManyArgs = {
    /**
     * Select specific fields to fetch from the student
     * 
    **/
    select?: studentSelect | null
    /**
     * Filter, which students to fetch.
     * 
    **/
    where?: studentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of students to fetch.
     * 
    **/
    orderBy?: Enumerable<studentOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing students.
     * 
    **/
    cursor?: studentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` students from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` students.
     * 
    **/
    skip?: number
    distinct?: Enumerable<StudentScalarFieldEnum>
  }


  /**
   * student create
   */
  export type studentCreateArgs = {
    /**
     * Select specific fields to fetch from the student
     * 
    **/
    select?: studentSelect | null
    /**
     * The data needed to create a student.
     * 
    **/
    data: XOR<studentCreateInput, studentUncheckedCreateInput>
  }


  /**
   * student createMany
   */
  export type studentCreateManyArgs = {
    /**
     * The data used to create many students.
     * 
    **/
    data: Enumerable<studentCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * student update
   */
  export type studentUpdateArgs = {
    /**
     * Select specific fields to fetch from the student
     * 
    **/
    select?: studentSelect | null
    /**
     * The data needed to update a student.
     * 
    **/
    data: XOR<studentUpdateInput, studentUncheckedUpdateInput>
    /**
     * Choose, which student to update.
     * 
    **/
    where: studentWhereUniqueInput
  }


  /**
   * student updateMany
   */
  export type studentUpdateManyArgs = {
    /**
     * The data used to update students.
     * 
    **/
    data: XOR<studentUpdateManyMutationInput, studentUncheckedUpdateManyInput>
    /**
     * Filter which students to update
     * 
    **/
    where?: studentWhereInput
  }


  /**
   * student upsert
   */
  export type studentUpsertArgs = {
    /**
     * Select specific fields to fetch from the student
     * 
    **/
    select?: studentSelect | null
    /**
     * The filter to search for the student to update in case it exists.
     * 
    **/
    where: studentWhereUniqueInput
    /**
     * In case the student found by the `where` argument doesn't exist, create a new student with this data.
     * 
    **/
    create: XOR<studentCreateInput, studentUncheckedCreateInput>
    /**
     * In case the student was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<studentUpdateInput, studentUncheckedUpdateInput>
  }


  /**
   * student delete
   */
  export type studentDeleteArgs = {
    /**
     * Select specific fields to fetch from the student
     * 
    **/
    select?: studentSelect | null
    /**
     * Filter which student to delete.
     * 
    **/
    where: studentWhereUniqueInput
  }


  /**
   * student deleteMany
   */
  export type studentDeleteManyArgs = {
    /**
     * Filter which students to delete
     * 
    **/
    where?: studentWhereInput
  }


  /**
   * student: findUniqueOrThrow
   */
  export type studentFindUniqueOrThrowArgs = studentFindUniqueArgsBase
      

  /**
   * student: findFirstOrThrow
   */
  export type studentFindFirstOrThrowArgs = studentFindFirstArgsBase
      

  /**
   * student without action
   */
  export type studentArgs = {
    /**
     * Select specific fields to fetch from the student
     * 
    **/
    select?: studentSelect | null
  }



  /**
   * Model subject_report
   */


  export type AggregateSubject_report = {
    _count: Subject_reportCountAggregateOutputType | null
    _avg: Subject_reportAvgAggregateOutputType | null
    _sum: Subject_reportSumAggregateOutputType | null
    _min: Subject_reportMinAggregateOutputType | null
    _max: Subject_reportMaxAggregateOutputType | null
  }

  export type Subject_reportAvgAggregateOutputType = {
    subject_id: number | null
    no_of_student: number | null
    report_id: number | null
  }

  export type Subject_reportSumAggregateOutputType = {
    subject_id: number | null
    no_of_student: number | null
    report_id: number | null
  }

  export type Subject_reportMinAggregateOutputType = {
    subject_id: number | null
    no_of_student: number | null
    report_id: number | null
  }

  export type Subject_reportMaxAggregateOutputType = {
    subject_id: number | null
    no_of_student: number | null
    report_id: number | null
  }

  export type Subject_reportCountAggregateOutputType = {
    subject_id: number
    no_of_student: number
    report_id: number
    _all: number
  }


  export type Subject_reportAvgAggregateInputType = {
    subject_id?: true
    no_of_student?: true
    report_id?: true
  }

  export type Subject_reportSumAggregateInputType = {
    subject_id?: true
    no_of_student?: true
    report_id?: true
  }

  export type Subject_reportMinAggregateInputType = {
    subject_id?: true
    no_of_student?: true
    report_id?: true
  }

  export type Subject_reportMaxAggregateInputType = {
    subject_id?: true
    no_of_student?: true
    report_id?: true
  }

  export type Subject_reportCountAggregateInputType = {
    subject_id?: true
    no_of_student?: true
    report_id?: true
    _all?: true
  }

  export type Subject_reportAggregateArgs = {
    /**
     * Filter which subject_report to aggregate.
     * 
    **/
    where?: subject_reportWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of subject_reports to fetch.
     * 
    **/
    orderBy?: Enumerable<subject_reportOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: subject_reportWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` subject_reports from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` subject_reports.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned subject_reports
    **/
    _count?: true | Subject_reportCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Subject_reportAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Subject_reportSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Subject_reportMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Subject_reportMaxAggregateInputType
  }

  export type GetSubject_reportAggregateType<T extends Subject_reportAggregateArgs> = {
        [P in keyof T & keyof AggregateSubject_report]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSubject_report[P]>
      : GetScalarType<T[P], AggregateSubject_report[P]>
  }




  export type Subject_reportGroupByArgs = {
    where?: subject_reportWhereInput
    orderBy?: Enumerable<subject_reportOrderByWithAggregationInput>
    by: Array<Subject_reportScalarFieldEnum>
    having?: subject_reportScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Subject_reportCountAggregateInputType | true
    _avg?: Subject_reportAvgAggregateInputType
    _sum?: Subject_reportSumAggregateInputType
    _min?: Subject_reportMinAggregateInputType
    _max?: Subject_reportMaxAggregateInputType
  }


  export type Subject_reportGroupByOutputType = {
    subject_id: number
    no_of_student: number
    report_id: number
    _count: Subject_reportCountAggregateOutputType | null
    _avg: Subject_reportAvgAggregateOutputType | null
    _sum: Subject_reportSumAggregateOutputType | null
    _min: Subject_reportMinAggregateOutputType | null
    _max: Subject_reportMaxAggregateOutputType | null
  }

  type GetSubject_reportGroupByPayload<T extends Subject_reportGroupByArgs> = PrismaPromise<
    Array<
      PickArray<Subject_reportGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Subject_reportGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Subject_reportGroupByOutputType[P]>
            : GetScalarType<T[P], Subject_reportGroupByOutputType[P]>
        }
      >
    >


  export type subject_reportSelect = {
    subject_id?: boolean
    no_of_student?: boolean
    report_id?: boolean
  }

  export type subject_reportGetPayload<
    S extends boolean | null | undefined | subject_reportArgs,
    U = keyof S
      > = S extends true
        ? subject_report
    : S extends undefined
    ? never
    : S extends subject_reportArgs | subject_reportFindManyArgs
    ?'include' extends U
    ? subject_report 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
    P extends keyof subject_report ? subject_report[P] : never
  } 
    : subject_report
  : subject_report


  type subject_reportCountArgs = Merge<
    Omit<subject_reportFindManyArgs, 'select' | 'include'> & {
      select?: Subject_reportCountAggregateInputType | true
    }
  >

  export interface subject_reportDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one Subject_report that matches the filter.
     * @param {subject_reportFindUniqueArgs} args - Arguments to find a Subject_report
     * @example
     * // Get one Subject_report
     * const subject_report = await prisma.subject_report.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends subject_reportFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, subject_reportFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'subject_report'> extends True ? CheckSelect<T, Prisma__subject_reportClient<subject_report>, Prisma__subject_reportClient<subject_reportGetPayload<T>>> : CheckSelect<T, Prisma__subject_reportClient<subject_report | null >, Prisma__subject_reportClient<subject_reportGetPayload<T> | null >>

    /**
     * Find the first Subject_report that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {subject_reportFindFirstArgs} args - Arguments to find a Subject_report
     * @example
     * // Get one Subject_report
     * const subject_report = await prisma.subject_report.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends subject_reportFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, subject_reportFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'subject_report'> extends True ? CheckSelect<T, Prisma__subject_reportClient<subject_report>, Prisma__subject_reportClient<subject_reportGetPayload<T>>> : CheckSelect<T, Prisma__subject_reportClient<subject_report | null >, Prisma__subject_reportClient<subject_reportGetPayload<T> | null >>

    /**
     * Find zero or more Subject_reports that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {subject_reportFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Subject_reports
     * const subject_reports = await prisma.subject_report.findMany()
     * 
     * // Get first 10 Subject_reports
     * const subject_reports = await prisma.subject_report.findMany({ take: 10 })
     * 
     * // Only select the `subject_id`
     * const subject_reportWithSubject_idOnly = await prisma.subject_report.findMany({ select: { subject_id: true } })
     * 
    **/
    findMany<T extends subject_reportFindManyArgs>(
      args?: SelectSubset<T, subject_reportFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<subject_report>>, PrismaPromise<Array<subject_reportGetPayload<T>>>>

    /**
     * Create a Subject_report.
     * @param {subject_reportCreateArgs} args - Arguments to create a Subject_report.
     * @example
     * // Create one Subject_report
     * const Subject_report = await prisma.subject_report.create({
     *   data: {
     *     // ... data to create a Subject_report
     *   }
     * })
     * 
    **/
    create<T extends subject_reportCreateArgs>(
      args: SelectSubset<T, subject_reportCreateArgs>
    ): CheckSelect<T, Prisma__subject_reportClient<subject_report>, Prisma__subject_reportClient<subject_reportGetPayload<T>>>

    /**
     * Create many Subject_reports.
     *     @param {subject_reportCreateManyArgs} args - Arguments to create many Subject_reports.
     *     @example
     *     // Create many Subject_reports
     *     const subject_report = await prisma.subject_report.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends subject_reportCreateManyArgs>(
      args?: SelectSubset<T, subject_reportCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Subject_report.
     * @param {subject_reportDeleteArgs} args - Arguments to delete one Subject_report.
     * @example
     * // Delete one Subject_report
     * const Subject_report = await prisma.subject_report.delete({
     *   where: {
     *     // ... filter to delete one Subject_report
     *   }
     * })
     * 
    **/
    delete<T extends subject_reportDeleteArgs>(
      args: SelectSubset<T, subject_reportDeleteArgs>
    ): CheckSelect<T, Prisma__subject_reportClient<subject_report>, Prisma__subject_reportClient<subject_reportGetPayload<T>>>

    /**
     * Update one Subject_report.
     * @param {subject_reportUpdateArgs} args - Arguments to update one Subject_report.
     * @example
     * // Update one Subject_report
     * const subject_report = await prisma.subject_report.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends subject_reportUpdateArgs>(
      args: SelectSubset<T, subject_reportUpdateArgs>
    ): CheckSelect<T, Prisma__subject_reportClient<subject_report>, Prisma__subject_reportClient<subject_reportGetPayload<T>>>

    /**
     * Delete zero or more Subject_reports.
     * @param {subject_reportDeleteManyArgs} args - Arguments to filter Subject_reports to delete.
     * @example
     * // Delete a few Subject_reports
     * const { count } = await prisma.subject_report.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends subject_reportDeleteManyArgs>(
      args?: SelectSubset<T, subject_reportDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Subject_reports.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {subject_reportUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Subject_reports
     * const subject_report = await prisma.subject_report.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends subject_reportUpdateManyArgs>(
      args: SelectSubset<T, subject_reportUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Subject_report.
     * @param {subject_reportUpsertArgs} args - Arguments to update or create a Subject_report.
     * @example
     * // Update or create a Subject_report
     * const subject_report = await prisma.subject_report.upsert({
     *   create: {
     *     // ... data to create a Subject_report
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Subject_report we want to update
     *   }
     * })
    **/
    upsert<T extends subject_reportUpsertArgs>(
      args: SelectSubset<T, subject_reportUpsertArgs>
    ): CheckSelect<T, Prisma__subject_reportClient<subject_report>, Prisma__subject_reportClient<subject_reportGetPayload<T>>>

    /**
     * Find one Subject_report that matches the filter or throw
     * `NotFoundError` if no matches were found.
     * @param {subject_reportFindUniqueOrThrowArgs} args - Arguments to find a Subject_report
     * @example
     * // Get one Subject_report
     * const subject_report = await prisma.subject_report.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends subject_reportFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, subject_reportFindUniqueOrThrowArgs>
    ): CheckSelect<T, Prisma__subject_reportClient<subject_report>, Prisma__subject_reportClient<subject_reportGetPayload<T>>>

    /**
     * Find the first Subject_report that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {subject_reportFindFirstOrThrowArgs} args - Arguments to find a Subject_report
     * @example
     * // Get one Subject_report
     * const subject_report = await prisma.subject_report.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends subject_reportFindFirstOrThrowArgs>(
      args?: SelectSubset<T, subject_reportFindFirstOrThrowArgs>
    ): CheckSelect<T, Prisma__subject_reportClient<subject_report>, Prisma__subject_reportClient<subject_reportGetPayload<T>>>

    /**
     * Count the number of Subject_reports.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {subject_reportCountArgs} args - Arguments to filter Subject_reports to count.
     * @example
     * // Count the number of Subject_reports
     * const count = await prisma.subject_report.count({
     *   where: {
     *     // ... the filter for the Subject_reports we want to count
     *   }
     * })
    **/
    count<T extends subject_reportCountArgs>(
      args?: Subset<T, subject_reportCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Subject_reportCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Subject_report.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Subject_reportAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Subject_reportAggregateArgs>(args: Subset<T, Subject_reportAggregateArgs>): PrismaPromise<GetSubject_reportAggregateType<T>>

    /**
     * Group by Subject_report.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Subject_reportGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends Subject_reportGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: Subject_reportGroupByArgs['orderBy'] }
        : { orderBy?: Subject_reportGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, Subject_reportGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSubject_reportGroupByPayload<T> : PrismaPromise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for subject_report.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__subject_reportClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * subject_report base type for findUnique actions
   */
  export type subject_reportFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the subject_report
     * 
    **/
    select?: subject_reportSelect | null
    /**
     * Filter, which subject_report to fetch.
     * 
    **/
    where: subject_reportWhereUniqueInput
  }

  /**
   * subject_report: findUnique
   */
  export interface subject_reportFindUniqueArgs extends subject_reportFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * subject_report base type for findFirst actions
   */
  export type subject_reportFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the subject_report
     * 
    **/
    select?: subject_reportSelect | null
    /**
     * Filter, which subject_report to fetch.
     * 
    **/
    where?: subject_reportWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of subject_reports to fetch.
     * 
    **/
    orderBy?: Enumerable<subject_reportOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for subject_reports.
     * 
    **/
    cursor?: subject_reportWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` subject_reports from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` subject_reports.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of subject_reports.
     * 
    **/
    distinct?: Enumerable<Subject_reportScalarFieldEnum>
  }

  /**
   * subject_report: findFirst
   */
  export interface subject_reportFindFirstArgs extends subject_reportFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * subject_report findMany
   */
  export type subject_reportFindManyArgs = {
    /**
     * Select specific fields to fetch from the subject_report
     * 
    **/
    select?: subject_reportSelect | null
    /**
     * Filter, which subject_reports to fetch.
     * 
    **/
    where?: subject_reportWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of subject_reports to fetch.
     * 
    **/
    orderBy?: Enumerable<subject_reportOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing subject_reports.
     * 
    **/
    cursor?: subject_reportWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` subject_reports from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` subject_reports.
     * 
    **/
    skip?: number
    distinct?: Enumerable<Subject_reportScalarFieldEnum>
  }


  /**
   * subject_report create
   */
  export type subject_reportCreateArgs = {
    /**
     * Select specific fields to fetch from the subject_report
     * 
    **/
    select?: subject_reportSelect | null
    /**
     * The data needed to create a subject_report.
     * 
    **/
    data: XOR<subject_reportCreateInput, subject_reportUncheckedCreateInput>
  }


  /**
   * subject_report createMany
   */
  export type subject_reportCreateManyArgs = {
    /**
     * The data used to create many subject_reports.
     * 
    **/
    data: Enumerable<subject_reportCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * subject_report update
   */
  export type subject_reportUpdateArgs = {
    /**
     * Select specific fields to fetch from the subject_report
     * 
    **/
    select?: subject_reportSelect | null
    /**
     * The data needed to update a subject_report.
     * 
    **/
    data: XOR<subject_reportUpdateInput, subject_reportUncheckedUpdateInput>
    /**
     * Choose, which subject_report to update.
     * 
    **/
    where: subject_reportWhereUniqueInput
  }


  /**
   * subject_report updateMany
   */
  export type subject_reportUpdateManyArgs = {
    /**
     * The data used to update subject_reports.
     * 
    **/
    data: XOR<subject_reportUpdateManyMutationInput, subject_reportUncheckedUpdateManyInput>
    /**
     * Filter which subject_reports to update
     * 
    **/
    where?: subject_reportWhereInput
  }


  /**
   * subject_report upsert
   */
  export type subject_reportUpsertArgs = {
    /**
     * Select specific fields to fetch from the subject_report
     * 
    **/
    select?: subject_reportSelect | null
    /**
     * The filter to search for the subject_report to update in case it exists.
     * 
    **/
    where: subject_reportWhereUniqueInput
    /**
     * In case the subject_report found by the `where` argument doesn't exist, create a new subject_report with this data.
     * 
    **/
    create: XOR<subject_reportCreateInput, subject_reportUncheckedCreateInput>
    /**
     * In case the subject_report was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<subject_reportUpdateInput, subject_reportUncheckedUpdateInput>
  }


  /**
   * subject_report delete
   */
  export type subject_reportDeleteArgs = {
    /**
     * Select specific fields to fetch from the subject_report
     * 
    **/
    select?: subject_reportSelect | null
    /**
     * Filter which subject_report to delete.
     * 
    **/
    where: subject_reportWhereUniqueInput
  }


  /**
   * subject_report deleteMany
   */
  export type subject_reportDeleteManyArgs = {
    /**
     * Filter which subject_reports to delete
     * 
    **/
    where?: subject_reportWhereInput
  }


  /**
   * subject_report: findUniqueOrThrow
   */
  export type subject_reportFindUniqueOrThrowArgs = subject_reportFindUniqueArgsBase
      

  /**
   * subject_report: findFirstOrThrow
   */
  export type subject_reportFindFirstOrThrowArgs = subject_reportFindFirstArgsBase
      

  /**
   * subject_report without action
   */
  export type subject_reportArgs = {
    /**
     * Select specific fields to fetch from the subject_report
     * 
    **/
    select?: subject_reportSelect | null
  }



  /**
   * Model system_pages
   */


  export type AggregateSystem_pages = {
    _count: System_pagesCountAggregateOutputType | null
    _avg: System_pagesAvgAggregateOutputType | null
    _sum: System_pagesSumAggregateOutputType | null
    _min: System_pagesMinAggregateOutputType | null
    _max: System_pagesMaxAggregateOutputType | null
  }

  export type System_pagesAvgAggregateOutputType = {
    page_id: number | null
    admin_id: number | null
  }

  export type System_pagesSumAggregateOutputType = {
    page_id: number | null
    admin_id: number | null
  }

  export type System_pagesMinAggregateOutputType = {
    page_id: number | null
    content: string | null
    admin_id: number | null
  }

  export type System_pagesMaxAggregateOutputType = {
    page_id: number | null
    content: string | null
    admin_id: number | null
  }

  export type System_pagesCountAggregateOutputType = {
    page_id: number
    content: number
    admin_id: number
    _all: number
  }


  export type System_pagesAvgAggregateInputType = {
    page_id?: true
    admin_id?: true
  }

  export type System_pagesSumAggregateInputType = {
    page_id?: true
    admin_id?: true
  }

  export type System_pagesMinAggregateInputType = {
    page_id?: true
    content?: true
    admin_id?: true
  }

  export type System_pagesMaxAggregateInputType = {
    page_id?: true
    content?: true
    admin_id?: true
  }

  export type System_pagesCountAggregateInputType = {
    page_id?: true
    content?: true
    admin_id?: true
    _all?: true
  }

  export type System_pagesAggregateArgs = {
    /**
     * Filter which system_pages to aggregate.
     * 
    **/
    where?: system_pagesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of system_pages to fetch.
     * 
    **/
    orderBy?: Enumerable<system_pagesOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: system_pagesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` system_pages from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` system_pages.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned system_pages
    **/
    _count?: true | System_pagesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: System_pagesAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: System_pagesSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: System_pagesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: System_pagesMaxAggregateInputType
  }

  export type GetSystem_pagesAggregateType<T extends System_pagesAggregateArgs> = {
        [P in keyof T & keyof AggregateSystem_pages]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSystem_pages[P]>
      : GetScalarType<T[P], AggregateSystem_pages[P]>
  }




  export type System_pagesGroupByArgs = {
    where?: system_pagesWhereInput
    orderBy?: Enumerable<system_pagesOrderByWithAggregationInput>
    by: Array<System_pagesScalarFieldEnum>
    having?: system_pagesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: System_pagesCountAggregateInputType | true
    _avg?: System_pagesAvgAggregateInputType
    _sum?: System_pagesSumAggregateInputType
    _min?: System_pagesMinAggregateInputType
    _max?: System_pagesMaxAggregateInputType
  }


  export type System_pagesGroupByOutputType = {
    page_id: number
    content: string
    admin_id: number
    _count: System_pagesCountAggregateOutputType | null
    _avg: System_pagesAvgAggregateOutputType | null
    _sum: System_pagesSumAggregateOutputType | null
    _min: System_pagesMinAggregateOutputType | null
    _max: System_pagesMaxAggregateOutputType | null
  }

  type GetSystem_pagesGroupByPayload<T extends System_pagesGroupByArgs> = PrismaPromise<
    Array<
      PickArray<System_pagesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof System_pagesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], System_pagesGroupByOutputType[P]>
            : GetScalarType<T[P], System_pagesGroupByOutputType[P]>
        }
      >
    >


  export type system_pagesSelect = {
    page_id?: boolean
    content?: boolean
    admin_id?: boolean
  }

  export type system_pagesGetPayload<
    S extends boolean | null | undefined | system_pagesArgs,
    U = keyof S
      > = S extends true
        ? system_pages
    : S extends undefined
    ? never
    : S extends system_pagesArgs | system_pagesFindManyArgs
    ?'include' extends U
    ? system_pages 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
    P extends keyof system_pages ? system_pages[P] : never
  } 
    : system_pages
  : system_pages


  type system_pagesCountArgs = Merge<
    Omit<system_pagesFindManyArgs, 'select' | 'include'> & {
      select?: System_pagesCountAggregateInputType | true
    }
  >

  export interface system_pagesDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one System_pages that matches the filter.
     * @param {system_pagesFindUniqueArgs} args - Arguments to find a System_pages
     * @example
     * // Get one System_pages
     * const system_pages = await prisma.system_pages.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends system_pagesFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, system_pagesFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'system_pages'> extends True ? CheckSelect<T, Prisma__system_pagesClient<system_pages>, Prisma__system_pagesClient<system_pagesGetPayload<T>>> : CheckSelect<T, Prisma__system_pagesClient<system_pages | null >, Prisma__system_pagesClient<system_pagesGetPayload<T> | null >>

    /**
     * Find the first System_pages that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {system_pagesFindFirstArgs} args - Arguments to find a System_pages
     * @example
     * // Get one System_pages
     * const system_pages = await prisma.system_pages.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends system_pagesFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, system_pagesFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'system_pages'> extends True ? CheckSelect<T, Prisma__system_pagesClient<system_pages>, Prisma__system_pagesClient<system_pagesGetPayload<T>>> : CheckSelect<T, Prisma__system_pagesClient<system_pages | null >, Prisma__system_pagesClient<system_pagesGetPayload<T> | null >>

    /**
     * Find zero or more System_pages that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {system_pagesFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all System_pages
     * const system_pages = await prisma.system_pages.findMany()
     * 
     * // Get first 10 System_pages
     * const system_pages = await prisma.system_pages.findMany({ take: 10 })
     * 
     * // Only select the `page_id`
     * const system_pagesWithPage_idOnly = await prisma.system_pages.findMany({ select: { page_id: true } })
     * 
    **/
    findMany<T extends system_pagesFindManyArgs>(
      args?: SelectSubset<T, system_pagesFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<system_pages>>, PrismaPromise<Array<system_pagesGetPayload<T>>>>

    /**
     * Create a System_pages.
     * @param {system_pagesCreateArgs} args - Arguments to create a System_pages.
     * @example
     * // Create one System_pages
     * const System_pages = await prisma.system_pages.create({
     *   data: {
     *     // ... data to create a System_pages
     *   }
     * })
     * 
    **/
    create<T extends system_pagesCreateArgs>(
      args: SelectSubset<T, system_pagesCreateArgs>
    ): CheckSelect<T, Prisma__system_pagesClient<system_pages>, Prisma__system_pagesClient<system_pagesGetPayload<T>>>

    /**
     * Create many System_pages.
     *     @param {system_pagesCreateManyArgs} args - Arguments to create many System_pages.
     *     @example
     *     // Create many System_pages
     *     const system_pages = await prisma.system_pages.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends system_pagesCreateManyArgs>(
      args?: SelectSubset<T, system_pagesCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a System_pages.
     * @param {system_pagesDeleteArgs} args - Arguments to delete one System_pages.
     * @example
     * // Delete one System_pages
     * const System_pages = await prisma.system_pages.delete({
     *   where: {
     *     // ... filter to delete one System_pages
     *   }
     * })
     * 
    **/
    delete<T extends system_pagesDeleteArgs>(
      args: SelectSubset<T, system_pagesDeleteArgs>
    ): CheckSelect<T, Prisma__system_pagesClient<system_pages>, Prisma__system_pagesClient<system_pagesGetPayload<T>>>

    /**
     * Update one System_pages.
     * @param {system_pagesUpdateArgs} args - Arguments to update one System_pages.
     * @example
     * // Update one System_pages
     * const system_pages = await prisma.system_pages.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends system_pagesUpdateArgs>(
      args: SelectSubset<T, system_pagesUpdateArgs>
    ): CheckSelect<T, Prisma__system_pagesClient<system_pages>, Prisma__system_pagesClient<system_pagesGetPayload<T>>>

    /**
     * Delete zero or more System_pages.
     * @param {system_pagesDeleteManyArgs} args - Arguments to filter System_pages to delete.
     * @example
     * // Delete a few System_pages
     * const { count } = await prisma.system_pages.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends system_pagesDeleteManyArgs>(
      args?: SelectSubset<T, system_pagesDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more System_pages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {system_pagesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many System_pages
     * const system_pages = await prisma.system_pages.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends system_pagesUpdateManyArgs>(
      args: SelectSubset<T, system_pagesUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one System_pages.
     * @param {system_pagesUpsertArgs} args - Arguments to update or create a System_pages.
     * @example
     * // Update or create a System_pages
     * const system_pages = await prisma.system_pages.upsert({
     *   create: {
     *     // ... data to create a System_pages
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the System_pages we want to update
     *   }
     * })
    **/
    upsert<T extends system_pagesUpsertArgs>(
      args: SelectSubset<T, system_pagesUpsertArgs>
    ): CheckSelect<T, Prisma__system_pagesClient<system_pages>, Prisma__system_pagesClient<system_pagesGetPayload<T>>>

    /**
     * Find one System_pages that matches the filter or throw
     * `NotFoundError` if no matches were found.
     * @param {system_pagesFindUniqueOrThrowArgs} args - Arguments to find a System_pages
     * @example
     * // Get one System_pages
     * const system_pages = await prisma.system_pages.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends system_pagesFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, system_pagesFindUniqueOrThrowArgs>
    ): CheckSelect<T, Prisma__system_pagesClient<system_pages>, Prisma__system_pagesClient<system_pagesGetPayload<T>>>

    /**
     * Find the first System_pages that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {system_pagesFindFirstOrThrowArgs} args - Arguments to find a System_pages
     * @example
     * // Get one System_pages
     * const system_pages = await prisma.system_pages.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends system_pagesFindFirstOrThrowArgs>(
      args?: SelectSubset<T, system_pagesFindFirstOrThrowArgs>
    ): CheckSelect<T, Prisma__system_pagesClient<system_pages>, Prisma__system_pagesClient<system_pagesGetPayload<T>>>

    /**
     * Count the number of System_pages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {system_pagesCountArgs} args - Arguments to filter System_pages to count.
     * @example
     * // Count the number of System_pages
     * const count = await prisma.system_pages.count({
     *   where: {
     *     // ... the filter for the System_pages we want to count
     *   }
     * })
    **/
    count<T extends system_pagesCountArgs>(
      args?: Subset<T, system_pagesCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], System_pagesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a System_pages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {System_pagesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends System_pagesAggregateArgs>(args: Subset<T, System_pagesAggregateArgs>): PrismaPromise<GetSystem_pagesAggregateType<T>>

    /**
     * Group by System_pages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {System_pagesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends System_pagesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: System_pagesGroupByArgs['orderBy'] }
        : { orderBy?: System_pagesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, System_pagesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSystem_pagesGroupByPayload<T> : PrismaPromise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for system_pages.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__system_pagesClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * system_pages base type for findUnique actions
   */
  export type system_pagesFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the system_pages
     * 
    **/
    select?: system_pagesSelect | null
    /**
     * Filter, which system_pages to fetch.
     * 
    **/
    where: system_pagesWhereUniqueInput
  }

  /**
   * system_pages: findUnique
   */
  export interface system_pagesFindUniqueArgs extends system_pagesFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * system_pages base type for findFirst actions
   */
  export type system_pagesFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the system_pages
     * 
    **/
    select?: system_pagesSelect | null
    /**
     * Filter, which system_pages to fetch.
     * 
    **/
    where?: system_pagesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of system_pages to fetch.
     * 
    **/
    orderBy?: Enumerable<system_pagesOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for system_pages.
     * 
    **/
    cursor?: system_pagesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` system_pages from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` system_pages.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of system_pages.
     * 
    **/
    distinct?: Enumerable<System_pagesScalarFieldEnum>
  }

  /**
   * system_pages: findFirst
   */
  export interface system_pagesFindFirstArgs extends system_pagesFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * system_pages findMany
   */
  export type system_pagesFindManyArgs = {
    /**
     * Select specific fields to fetch from the system_pages
     * 
    **/
    select?: system_pagesSelect | null
    /**
     * Filter, which system_pages to fetch.
     * 
    **/
    where?: system_pagesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of system_pages to fetch.
     * 
    **/
    orderBy?: Enumerable<system_pagesOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing system_pages.
     * 
    **/
    cursor?: system_pagesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` system_pages from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` system_pages.
     * 
    **/
    skip?: number
    distinct?: Enumerable<System_pagesScalarFieldEnum>
  }


  /**
   * system_pages create
   */
  export type system_pagesCreateArgs = {
    /**
     * Select specific fields to fetch from the system_pages
     * 
    **/
    select?: system_pagesSelect | null
    /**
     * The data needed to create a system_pages.
     * 
    **/
    data: XOR<system_pagesCreateInput, system_pagesUncheckedCreateInput>
  }


  /**
   * system_pages createMany
   */
  export type system_pagesCreateManyArgs = {
    /**
     * The data used to create many system_pages.
     * 
    **/
    data: Enumerable<system_pagesCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * system_pages update
   */
  export type system_pagesUpdateArgs = {
    /**
     * Select specific fields to fetch from the system_pages
     * 
    **/
    select?: system_pagesSelect | null
    /**
     * The data needed to update a system_pages.
     * 
    **/
    data: XOR<system_pagesUpdateInput, system_pagesUncheckedUpdateInput>
    /**
     * Choose, which system_pages to update.
     * 
    **/
    where: system_pagesWhereUniqueInput
  }


  /**
   * system_pages updateMany
   */
  export type system_pagesUpdateManyArgs = {
    /**
     * The data used to update system_pages.
     * 
    **/
    data: XOR<system_pagesUpdateManyMutationInput, system_pagesUncheckedUpdateManyInput>
    /**
     * Filter which system_pages to update
     * 
    **/
    where?: system_pagesWhereInput
  }


  /**
   * system_pages upsert
   */
  export type system_pagesUpsertArgs = {
    /**
     * Select specific fields to fetch from the system_pages
     * 
    **/
    select?: system_pagesSelect | null
    /**
     * The filter to search for the system_pages to update in case it exists.
     * 
    **/
    where: system_pagesWhereUniqueInput
    /**
     * In case the system_pages found by the `where` argument doesn't exist, create a new system_pages with this data.
     * 
    **/
    create: XOR<system_pagesCreateInput, system_pagesUncheckedCreateInput>
    /**
     * In case the system_pages was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<system_pagesUpdateInput, system_pagesUncheckedUpdateInput>
  }


  /**
   * system_pages delete
   */
  export type system_pagesDeleteArgs = {
    /**
     * Select specific fields to fetch from the system_pages
     * 
    **/
    select?: system_pagesSelect | null
    /**
     * Filter which system_pages to delete.
     * 
    **/
    where: system_pagesWhereUniqueInput
  }


  /**
   * system_pages deleteMany
   */
  export type system_pagesDeleteManyArgs = {
    /**
     * Filter which system_pages to delete
     * 
    **/
    where?: system_pagesWhereInput
  }


  /**
   * system_pages: findUniqueOrThrow
   */
  export type system_pagesFindUniqueOrThrowArgs = system_pagesFindUniqueArgsBase
      

  /**
   * system_pages: findFirstOrThrow
   */
  export type system_pagesFindFirstOrThrowArgs = system_pagesFindFirstArgsBase
      

  /**
   * system_pages without action
   */
  export type system_pagesArgs = {
    /**
     * Select specific fields to fetch from the system_pages
     * 
    **/
    select?: system_pagesSelect | null
  }



  /**
   * Model transcript
   */


  export type AggregateTranscript = {
    _count: TranscriptCountAggregateOutputType | null
    _avg: TranscriptAvgAggregateOutputType | null
    _sum: TranscriptSumAggregateOutputType | null
    _min: TranscriptMinAggregateOutputType | null
    _max: TranscriptMaxAggregateOutputType | null
  }

  export type TranscriptAvgAggregateOutputType = {
    transcript_id: number | null
    letter_id: number | null
  }

  export type TranscriptSumAggregateOutputType = {
    transcript_id: number | null
    letter_id: number | null
  }

  export type TranscriptMinAggregateOutputType = {
    transcript_id: number | null
    letter_id: number | null
  }

  export type TranscriptMaxAggregateOutputType = {
    transcript_id: number | null
    letter_id: number | null
  }

  export type TranscriptCountAggregateOutputType = {
    transcript_id: number
    letter_id: number
    _all: number
  }


  export type TranscriptAvgAggregateInputType = {
    transcript_id?: true
    letter_id?: true
  }

  export type TranscriptSumAggregateInputType = {
    transcript_id?: true
    letter_id?: true
  }

  export type TranscriptMinAggregateInputType = {
    transcript_id?: true
    letter_id?: true
  }

  export type TranscriptMaxAggregateInputType = {
    transcript_id?: true
    letter_id?: true
  }

  export type TranscriptCountAggregateInputType = {
    transcript_id?: true
    letter_id?: true
    _all?: true
  }

  export type TranscriptAggregateArgs = {
    /**
     * Filter which transcript to aggregate.
     * 
    **/
    where?: transcriptWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of transcripts to fetch.
     * 
    **/
    orderBy?: Enumerable<transcriptOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: transcriptWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` transcripts from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` transcripts.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned transcripts
    **/
    _count?: true | TranscriptCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TranscriptAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TranscriptSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TranscriptMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TranscriptMaxAggregateInputType
  }

  export type GetTranscriptAggregateType<T extends TranscriptAggregateArgs> = {
        [P in keyof T & keyof AggregateTranscript]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTranscript[P]>
      : GetScalarType<T[P], AggregateTranscript[P]>
  }




  export type TranscriptGroupByArgs = {
    where?: transcriptWhereInput
    orderBy?: Enumerable<transcriptOrderByWithAggregationInput>
    by: Array<TranscriptScalarFieldEnum>
    having?: transcriptScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TranscriptCountAggregateInputType | true
    _avg?: TranscriptAvgAggregateInputType
    _sum?: TranscriptSumAggregateInputType
    _min?: TranscriptMinAggregateInputType
    _max?: TranscriptMaxAggregateInputType
  }


  export type TranscriptGroupByOutputType = {
    transcript_id: number
    letter_id: number
    _count: TranscriptCountAggregateOutputType | null
    _avg: TranscriptAvgAggregateOutputType | null
    _sum: TranscriptSumAggregateOutputType | null
    _min: TranscriptMinAggregateOutputType | null
    _max: TranscriptMaxAggregateOutputType | null
  }

  type GetTranscriptGroupByPayload<T extends TranscriptGroupByArgs> = PrismaPromise<
    Array<
      PickArray<TranscriptGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TranscriptGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TranscriptGroupByOutputType[P]>
            : GetScalarType<T[P], TranscriptGroupByOutputType[P]>
        }
      >
    >


  export type transcriptSelect = {
    transcript_id?: boolean
    letter_id?: boolean
  }

  export type transcriptGetPayload<
    S extends boolean | null | undefined | transcriptArgs,
    U = keyof S
      > = S extends true
        ? transcript
    : S extends undefined
    ? never
    : S extends transcriptArgs | transcriptFindManyArgs
    ?'include' extends U
    ? transcript 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
    P extends keyof transcript ? transcript[P] : never
  } 
    : transcript
  : transcript


  type transcriptCountArgs = Merge<
    Omit<transcriptFindManyArgs, 'select' | 'include'> & {
      select?: TranscriptCountAggregateInputType | true
    }
  >

  export interface transcriptDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one Transcript that matches the filter.
     * @param {transcriptFindUniqueArgs} args - Arguments to find a Transcript
     * @example
     * // Get one Transcript
     * const transcript = await prisma.transcript.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends transcriptFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, transcriptFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'transcript'> extends True ? CheckSelect<T, Prisma__transcriptClient<transcript>, Prisma__transcriptClient<transcriptGetPayload<T>>> : CheckSelect<T, Prisma__transcriptClient<transcript | null >, Prisma__transcriptClient<transcriptGetPayload<T> | null >>

    /**
     * Find the first Transcript that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {transcriptFindFirstArgs} args - Arguments to find a Transcript
     * @example
     * // Get one Transcript
     * const transcript = await prisma.transcript.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends transcriptFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, transcriptFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'transcript'> extends True ? CheckSelect<T, Prisma__transcriptClient<transcript>, Prisma__transcriptClient<transcriptGetPayload<T>>> : CheckSelect<T, Prisma__transcriptClient<transcript | null >, Prisma__transcriptClient<transcriptGetPayload<T> | null >>

    /**
     * Find zero or more Transcripts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {transcriptFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Transcripts
     * const transcripts = await prisma.transcript.findMany()
     * 
     * // Get first 10 Transcripts
     * const transcripts = await prisma.transcript.findMany({ take: 10 })
     * 
     * // Only select the `transcript_id`
     * const transcriptWithTranscript_idOnly = await prisma.transcript.findMany({ select: { transcript_id: true } })
     * 
    **/
    findMany<T extends transcriptFindManyArgs>(
      args?: SelectSubset<T, transcriptFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<transcript>>, PrismaPromise<Array<transcriptGetPayload<T>>>>

    /**
     * Create a Transcript.
     * @param {transcriptCreateArgs} args - Arguments to create a Transcript.
     * @example
     * // Create one Transcript
     * const Transcript = await prisma.transcript.create({
     *   data: {
     *     // ... data to create a Transcript
     *   }
     * })
     * 
    **/
    create<T extends transcriptCreateArgs>(
      args: SelectSubset<T, transcriptCreateArgs>
    ): CheckSelect<T, Prisma__transcriptClient<transcript>, Prisma__transcriptClient<transcriptGetPayload<T>>>

    /**
     * Create many Transcripts.
     *     @param {transcriptCreateManyArgs} args - Arguments to create many Transcripts.
     *     @example
     *     // Create many Transcripts
     *     const transcript = await prisma.transcript.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends transcriptCreateManyArgs>(
      args?: SelectSubset<T, transcriptCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Transcript.
     * @param {transcriptDeleteArgs} args - Arguments to delete one Transcript.
     * @example
     * // Delete one Transcript
     * const Transcript = await prisma.transcript.delete({
     *   where: {
     *     // ... filter to delete one Transcript
     *   }
     * })
     * 
    **/
    delete<T extends transcriptDeleteArgs>(
      args: SelectSubset<T, transcriptDeleteArgs>
    ): CheckSelect<T, Prisma__transcriptClient<transcript>, Prisma__transcriptClient<transcriptGetPayload<T>>>

    /**
     * Update one Transcript.
     * @param {transcriptUpdateArgs} args - Arguments to update one Transcript.
     * @example
     * // Update one Transcript
     * const transcript = await prisma.transcript.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends transcriptUpdateArgs>(
      args: SelectSubset<T, transcriptUpdateArgs>
    ): CheckSelect<T, Prisma__transcriptClient<transcript>, Prisma__transcriptClient<transcriptGetPayload<T>>>

    /**
     * Delete zero or more Transcripts.
     * @param {transcriptDeleteManyArgs} args - Arguments to filter Transcripts to delete.
     * @example
     * // Delete a few Transcripts
     * const { count } = await prisma.transcript.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends transcriptDeleteManyArgs>(
      args?: SelectSubset<T, transcriptDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Transcripts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {transcriptUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Transcripts
     * const transcript = await prisma.transcript.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends transcriptUpdateManyArgs>(
      args: SelectSubset<T, transcriptUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Transcript.
     * @param {transcriptUpsertArgs} args - Arguments to update or create a Transcript.
     * @example
     * // Update or create a Transcript
     * const transcript = await prisma.transcript.upsert({
     *   create: {
     *     // ... data to create a Transcript
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Transcript we want to update
     *   }
     * })
    **/
    upsert<T extends transcriptUpsertArgs>(
      args: SelectSubset<T, transcriptUpsertArgs>
    ): CheckSelect<T, Prisma__transcriptClient<transcript>, Prisma__transcriptClient<transcriptGetPayload<T>>>

    /**
     * Find one Transcript that matches the filter or throw
     * `NotFoundError` if no matches were found.
     * @param {transcriptFindUniqueOrThrowArgs} args - Arguments to find a Transcript
     * @example
     * // Get one Transcript
     * const transcript = await prisma.transcript.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends transcriptFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, transcriptFindUniqueOrThrowArgs>
    ): CheckSelect<T, Prisma__transcriptClient<transcript>, Prisma__transcriptClient<transcriptGetPayload<T>>>

    /**
     * Find the first Transcript that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {transcriptFindFirstOrThrowArgs} args - Arguments to find a Transcript
     * @example
     * // Get one Transcript
     * const transcript = await prisma.transcript.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends transcriptFindFirstOrThrowArgs>(
      args?: SelectSubset<T, transcriptFindFirstOrThrowArgs>
    ): CheckSelect<T, Prisma__transcriptClient<transcript>, Prisma__transcriptClient<transcriptGetPayload<T>>>

    /**
     * Count the number of Transcripts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {transcriptCountArgs} args - Arguments to filter Transcripts to count.
     * @example
     * // Count the number of Transcripts
     * const count = await prisma.transcript.count({
     *   where: {
     *     // ... the filter for the Transcripts we want to count
     *   }
     * })
    **/
    count<T extends transcriptCountArgs>(
      args?: Subset<T, transcriptCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TranscriptCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Transcript.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TranscriptAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TranscriptAggregateArgs>(args: Subset<T, TranscriptAggregateArgs>): PrismaPromise<GetTranscriptAggregateType<T>>

    /**
     * Group by Transcript.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TranscriptGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TranscriptGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TranscriptGroupByArgs['orderBy'] }
        : { orderBy?: TranscriptGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TranscriptGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTranscriptGroupByPayload<T> : PrismaPromise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for transcript.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__transcriptClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * transcript base type for findUnique actions
   */
  export type transcriptFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the transcript
     * 
    **/
    select?: transcriptSelect | null
    /**
     * Filter, which transcript to fetch.
     * 
    **/
    where: transcriptWhereUniqueInput
  }

  /**
   * transcript: findUnique
   */
  export interface transcriptFindUniqueArgs extends transcriptFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * transcript base type for findFirst actions
   */
  export type transcriptFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the transcript
     * 
    **/
    select?: transcriptSelect | null
    /**
     * Filter, which transcript to fetch.
     * 
    **/
    where?: transcriptWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of transcripts to fetch.
     * 
    **/
    orderBy?: Enumerable<transcriptOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for transcripts.
     * 
    **/
    cursor?: transcriptWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` transcripts from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` transcripts.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of transcripts.
     * 
    **/
    distinct?: Enumerable<TranscriptScalarFieldEnum>
  }

  /**
   * transcript: findFirst
   */
  export interface transcriptFindFirstArgs extends transcriptFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * transcript findMany
   */
  export type transcriptFindManyArgs = {
    /**
     * Select specific fields to fetch from the transcript
     * 
    **/
    select?: transcriptSelect | null
    /**
     * Filter, which transcripts to fetch.
     * 
    **/
    where?: transcriptWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of transcripts to fetch.
     * 
    **/
    orderBy?: Enumerable<transcriptOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing transcripts.
     * 
    **/
    cursor?: transcriptWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` transcripts from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` transcripts.
     * 
    **/
    skip?: number
    distinct?: Enumerable<TranscriptScalarFieldEnum>
  }


  /**
   * transcript create
   */
  export type transcriptCreateArgs = {
    /**
     * Select specific fields to fetch from the transcript
     * 
    **/
    select?: transcriptSelect | null
    /**
     * The data needed to create a transcript.
     * 
    **/
    data: XOR<transcriptCreateInput, transcriptUncheckedCreateInput>
  }


  /**
   * transcript createMany
   */
  export type transcriptCreateManyArgs = {
    /**
     * The data used to create many transcripts.
     * 
    **/
    data: Enumerable<transcriptCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * transcript update
   */
  export type transcriptUpdateArgs = {
    /**
     * Select specific fields to fetch from the transcript
     * 
    **/
    select?: transcriptSelect | null
    /**
     * The data needed to update a transcript.
     * 
    **/
    data: XOR<transcriptUpdateInput, transcriptUncheckedUpdateInput>
    /**
     * Choose, which transcript to update.
     * 
    **/
    where: transcriptWhereUniqueInput
  }


  /**
   * transcript updateMany
   */
  export type transcriptUpdateManyArgs = {
    /**
     * The data used to update transcripts.
     * 
    **/
    data: XOR<transcriptUpdateManyMutationInput, transcriptUncheckedUpdateManyInput>
    /**
     * Filter which transcripts to update
     * 
    **/
    where?: transcriptWhereInput
  }


  /**
   * transcript upsert
   */
  export type transcriptUpsertArgs = {
    /**
     * Select specific fields to fetch from the transcript
     * 
    **/
    select?: transcriptSelect | null
    /**
     * The filter to search for the transcript to update in case it exists.
     * 
    **/
    where: transcriptWhereUniqueInput
    /**
     * In case the transcript found by the `where` argument doesn't exist, create a new transcript with this data.
     * 
    **/
    create: XOR<transcriptCreateInput, transcriptUncheckedCreateInput>
    /**
     * In case the transcript was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<transcriptUpdateInput, transcriptUncheckedUpdateInput>
  }


  /**
   * transcript delete
   */
  export type transcriptDeleteArgs = {
    /**
     * Select specific fields to fetch from the transcript
     * 
    **/
    select?: transcriptSelect | null
    /**
     * Filter which transcript to delete.
     * 
    **/
    where: transcriptWhereUniqueInput
  }


  /**
   * transcript deleteMany
   */
  export type transcriptDeleteManyArgs = {
    /**
     * Filter which transcripts to delete
     * 
    **/
    where?: transcriptWhereInput
  }


  /**
   * transcript: findUniqueOrThrow
   */
  export type transcriptFindUniqueOrThrowArgs = transcriptFindUniqueArgsBase
      

  /**
   * transcript: findFirstOrThrow
   */
  export type transcriptFindFirstOrThrowArgs = transcriptFindFirstArgsBase
      

  /**
   * transcript without action
   */
  export type transcriptArgs = {
    /**
     * Select specific fields to fetch from the transcript
     * 
    **/
    select?: transcriptSelect | null
  }



  /**
   * Model user
   */


  export type AggregateUser = {
    _count: UserCountAggregateOutputType | null
    _avg: UserAvgAggregateOutputType | null
    _sum: UserSumAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  export type UserAvgAggregateOutputType = {
    user_id: number | null
  }

  export type UserSumAggregateOutputType = {
    user_id: number | null
  }

  export type UserMinAggregateOutputType = {
    user_id: number | null
    user_name: string | null
    password: string | null
    email: string | null
    user_type: string | null
    f_name: string | null
    l_name: string | null
    profile_pic: string | null
  }

  export type UserMaxAggregateOutputType = {
    user_id: number | null
    user_name: string | null
    password: string | null
    email: string | null
    user_type: string | null
    f_name: string | null
    l_name: string | null
    profile_pic: string | null
  }

  export type UserCountAggregateOutputType = {
    user_id: number
    user_name: number
    password: number
    email: number
    user_type: number
    f_name: number
    l_name: number
    profile_pic: number
    _all: number
  }


  export type UserAvgAggregateInputType = {
    user_id?: true
  }

  export type UserSumAggregateInputType = {
    user_id?: true
  }

  export type UserMinAggregateInputType = {
    user_id?: true
    user_name?: true
    password?: true
    email?: true
    user_type?: true
    f_name?: true
    l_name?: true
    profile_pic?: true
  }

  export type UserMaxAggregateInputType = {
    user_id?: true
    user_name?: true
    password?: true
    email?: true
    user_type?: true
    f_name?: true
    l_name?: true
    profile_pic?: true
  }

  export type UserCountAggregateInputType = {
    user_id?: true
    user_name?: true
    password?: true
    email?: true
    user_type?: true
    f_name?: true
    l_name?: true
    profile_pic?: true
    _all?: true
  }

  export type UserAggregateArgs = {
    /**
     * Filter which user to aggregate.
     * 
    **/
    where?: userWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of users to fetch.
     * 
    **/
    orderBy?: Enumerable<userOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: userWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` users from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` users.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned users
    **/
    _count?: true | UserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UserAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UserSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserMaxAggregateInputType
  }

  export type GetUserAggregateType<T extends UserAggregateArgs> = {
        [P in keyof T & keyof AggregateUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser[P]>
      : GetScalarType<T[P], AggregateUser[P]>
  }




  export type UserGroupByArgs = {
    where?: userWhereInput
    orderBy?: Enumerable<userOrderByWithAggregationInput>
    by: Array<UserScalarFieldEnum>
    having?: userScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserCountAggregateInputType | true
    _avg?: UserAvgAggregateInputType
    _sum?: UserSumAggregateInputType
    _min?: UserMinAggregateInputType
    _max?: UserMaxAggregateInputType
  }


  export type UserGroupByOutputType = {
    user_id: number
    user_name: string
    password: string
    email: string
    user_type: string
    f_name: string
    l_name: string
    profile_pic: string | null
    _count: UserCountAggregateOutputType | null
    _avg: UserAvgAggregateOutputType | null
    _sum: UserSumAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  type GetUserGroupByPayload<T extends UserGroupByArgs> = PrismaPromise<
    Array<
      PickArray<UserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserGroupByOutputType[P]>
            : GetScalarType<T[P], UserGroupByOutputType[P]>
        }
      >
    >


  export type userSelect = {
    user_id?: boolean
    user_name?: boolean
    password?: boolean
    email?: boolean
    user_type?: boolean
    f_name?: boolean
    l_name?: boolean
    profile_pic?: boolean
  }

  export type userGetPayload<
    S extends boolean | null | undefined | userArgs,
    U = keyof S
      > = S extends true
        ? user
    : S extends undefined
    ? never
    : S extends userArgs | userFindManyArgs
    ?'include' extends U
    ? user 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
    P extends keyof user ? user[P] : never
  } 
    : user
  : user


  type userCountArgs = Merge<
    Omit<userFindManyArgs, 'select' | 'include'> & {
      select?: UserCountAggregateInputType | true
    }
  >

  export interface userDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one User that matches the filter.
     * @param {userFindUniqueArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends userFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, userFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'user'> extends True ? CheckSelect<T, Prisma__userClient<user>, Prisma__userClient<userGetPayload<T>>> : CheckSelect<T, Prisma__userClient<user | null >, Prisma__userClient<userGetPayload<T> | null >>

    /**
     * Find the first User that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {userFindFirstArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends userFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, userFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'user'> extends True ? CheckSelect<T, Prisma__userClient<user>, Prisma__userClient<userGetPayload<T>>> : CheckSelect<T, Prisma__userClient<user | null >, Prisma__userClient<userGetPayload<T> | null >>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {userFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.user.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.user.findMany({ take: 10 })
     * 
     * // Only select the `user_id`
     * const userWithUser_idOnly = await prisma.user.findMany({ select: { user_id: true } })
     * 
    **/
    findMany<T extends userFindManyArgs>(
      args?: SelectSubset<T, userFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<user>>, PrismaPromise<Array<userGetPayload<T>>>>

    /**
     * Create a User.
     * @param {userCreateArgs} args - Arguments to create a User.
     * @example
     * // Create one User
     * const User = await prisma.user.create({
     *   data: {
     *     // ... data to create a User
     *   }
     * })
     * 
    **/
    create<T extends userCreateArgs>(
      args: SelectSubset<T, userCreateArgs>
    ): CheckSelect<T, Prisma__userClient<user>, Prisma__userClient<userGetPayload<T>>>

    /**
     * Create many Users.
     *     @param {userCreateManyArgs} args - Arguments to create many Users.
     *     @example
     *     // Create many Users
     *     const user = await prisma.user.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends userCreateManyArgs>(
      args?: SelectSubset<T, userCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a User.
     * @param {userDeleteArgs} args - Arguments to delete one User.
     * @example
     * // Delete one User
     * const User = await prisma.user.delete({
     *   where: {
     *     // ... filter to delete one User
     *   }
     * })
     * 
    **/
    delete<T extends userDeleteArgs>(
      args: SelectSubset<T, userDeleteArgs>
    ): CheckSelect<T, Prisma__userClient<user>, Prisma__userClient<userGetPayload<T>>>

    /**
     * Update one User.
     * @param {userUpdateArgs} args - Arguments to update one User.
     * @example
     * // Update one User
     * const user = await prisma.user.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends userUpdateArgs>(
      args: SelectSubset<T, userUpdateArgs>
    ): CheckSelect<T, Prisma__userClient<user>, Prisma__userClient<userGetPayload<T>>>

    /**
     * Delete zero or more Users.
     * @param {userDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.user.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends userDeleteManyArgs>(
      args?: SelectSubset<T, userDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {userUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends userUpdateManyArgs>(
      args: SelectSubset<T, userUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one User.
     * @param {userUpsertArgs} args - Arguments to update or create a User.
     * @example
     * // Update or create a User
     * const user = await prisma.user.upsert({
     *   create: {
     *     // ... data to create a User
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User we want to update
     *   }
     * })
    **/
    upsert<T extends userUpsertArgs>(
      args: SelectSubset<T, userUpsertArgs>
    ): CheckSelect<T, Prisma__userClient<user>, Prisma__userClient<userGetPayload<T>>>

    /**
     * Find one User that matches the filter or throw
     * `NotFoundError` if no matches were found.
     * @param {userFindUniqueOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends userFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, userFindUniqueOrThrowArgs>
    ): CheckSelect<T, Prisma__userClient<user>, Prisma__userClient<userGetPayload<T>>>

    /**
     * Find the first User that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {userFindFirstOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends userFindFirstOrThrowArgs>(
      args?: SelectSubset<T, userFindFirstOrThrowArgs>
    ): CheckSelect<T, Prisma__userClient<user>, Prisma__userClient<userGetPayload<T>>>

    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {userCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.user.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends userCountArgs>(
      args?: Subset<T, userCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserAggregateArgs>(args: Subset<T, UserAggregateArgs>): PrismaPromise<GetUserAggregateType<T>>

    /**
     * Group by User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserGroupByArgs['orderBy'] }
        : { orderBy?: UserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserGroupByPayload<T> : PrismaPromise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for user.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__userClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * user base type for findUnique actions
   */
  export type userFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the user
     * 
    **/
    select?: userSelect | null
    /**
     * Filter, which user to fetch.
     * 
    **/
    where: userWhereUniqueInput
  }

  /**
   * user: findUnique
   */
  export interface userFindUniqueArgs extends userFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * user base type for findFirst actions
   */
  export type userFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the user
     * 
    **/
    select?: userSelect | null
    /**
     * Filter, which user to fetch.
     * 
    **/
    where?: userWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of users to fetch.
     * 
    **/
    orderBy?: Enumerable<userOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for users.
     * 
    **/
    cursor?: userWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` users from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` users.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of users.
     * 
    **/
    distinct?: Enumerable<UserScalarFieldEnum>
  }

  /**
   * user: findFirst
   */
  export interface userFindFirstArgs extends userFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * user findMany
   */
  export type userFindManyArgs = {
    /**
     * Select specific fields to fetch from the user
     * 
    **/
    select?: userSelect | null
    /**
     * Filter, which users to fetch.
     * 
    **/
    where?: userWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of users to fetch.
     * 
    **/
    orderBy?: Enumerable<userOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing users.
     * 
    **/
    cursor?: userWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` users from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` users.
     * 
    **/
    skip?: number
    distinct?: Enumerable<UserScalarFieldEnum>
  }


  /**
   * user create
   */
  export type userCreateArgs = {
    /**
     * Select specific fields to fetch from the user
     * 
    **/
    select?: userSelect | null
    /**
     * The data needed to create a user.
     * 
    **/
    data: XOR<userCreateInput, userUncheckedCreateInput>
  }


  /**
   * user createMany
   */
  export type userCreateManyArgs = {
    /**
     * The data used to create many users.
     * 
    **/
    data: Enumerable<userCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * user update
   */
  export type userUpdateArgs = {
    /**
     * Select specific fields to fetch from the user
     * 
    **/
    select?: userSelect | null
    /**
     * The data needed to update a user.
     * 
    **/
    data: XOR<userUpdateInput, userUncheckedUpdateInput>
    /**
     * Choose, which user to update.
     * 
    **/
    where: userWhereUniqueInput
  }


  /**
   * user updateMany
   */
  export type userUpdateManyArgs = {
    /**
     * The data used to update users.
     * 
    **/
    data: XOR<userUpdateManyMutationInput, userUncheckedUpdateManyInput>
    /**
     * Filter which users to update
     * 
    **/
    where?: userWhereInput
  }


  /**
   * user upsert
   */
  export type userUpsertArgs = {
    /**
     * Select specific fields to fetch from the user
     * 
    **/
    select?: userSelect | null
    /**
     * The filter to search for the user to update in case it exists.
     * 
    **/
    where: userWhereUniqueInput
    /**
     * In case the user found by the `where` argument doesn't exist, create a new user with this data.
     * 
    **/
    create: XOR<userCreateInput, userUncheckedCreateInput>
    /**
     * In case the user was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<userUpdateInput, userUncheckedUpdateInput>
  }


  /**
   * user delete
   */
  export type userDeleteArgs = {
    /**
     * Select specific fields to fetch from the user
     * 
    **/
    select?: userSelect | null
    /**
     * Filter which user to delete.
     * 
    **/
    where: userWhereUniqueInput
  }


  /**
   * user deleteMany
   */
  export type userDeleteManyArgs = {
    /**
     * Filter which users to delete
     * 
    **/
    where?: userWhereInput
  }


  /**
   * user: findUniqueOrThrow
   */
  export type userFindUniqueOrThrowArgs = userFindUniqueArgsBase
      

  /**
   * user: findFirstOrThrow
   */
  export type userFindFirstOrThrowArgs = userFindFirstArgsBase
      

  /**
   * user without action
   */
  export type userArgs = {
    /**
     * Select specific fields to fetch from the user
     * 
    **/
    select?: userSelect | null
  }



  /**
   * Enums
   */

  // Based on
  // https://github.com/microsoft/TypeScript/issues/3192#issuecomment-261720275

  export const Academic_yearScalarFieldEnum: {
    ac_year_ID: 'ac_year_ID',
    no_of_student: 'no_of_student',
    year: 'year'
  };

  export type Academic_yearScalarFieldEnum = (typeof Academic_yearScalarFieldEnum)[keyof typeof Academic_yearScalarFieldEnum]


  export const AdmissionScalarFieldEnum: {
    admission_id: 'admission_id',
    exam_hall: 'exam_hall',
    course_name: 'course_name',
    course_code: 'course_code',
    exan_date: 'exan_date',
    exam_time: 'exam_time',
    attendence_verify: 'attendence_verify'
  };

  export type AdmissionScalarFieldEnum = (typeof AdmissionScalarFieldEnum)[keyof typeof AdmissionScalarFieldEnum]


  export const AnnouncementScalarFieldEnum: {
    annou_id: 'annou_id',
    content: 'content',
    admin_id: 'admin_id'
  };

  export type AnnouncementScalarFieldEnum = (typeof AnnouncementScalarFieldEnum)[keyof typeof AnnouncementScalarFieldEnum]


  export const Assign_marksScalarFieldEnum: {
    assigment_id: 'assigment_id',
    sub_marks: 'sub_marks',
    total_marks: 'total_marks',
    assign_precentage: 'assign_precentage',
    mark_id: 'mark_id'
  };

  export type Assign_marksScalarFieldEnum = (typeof Assign_marksScalarFieldEnum)[keyof typeof Assign_marksScalarFieldEnum]


  export const AssignmentsScalarFieldEnum: {
    assignment_id: 'assignment_id',
    name: 'name',
    description: 'description',
    contribution: 'contribution',
    lecturer_id: 'lecturer_id',
    course_id: 'course_id'
  };

  export type AssignmentsScalarFieldEnum = (typeof AssignmentsScalarFieldEnum)[keyof typeof AssignmentsScalarFieldEnum]


  export const ConfirmScalarFieldEnum: {
    confirm_id: 'confirm_id',
    letter_id: 'letter_id'
  };

  export type ConfirmScalarFieldEnum = (typeof ConfirmScalarFieldEnum)[keyof typeof ConfirmScalarFieldEnum]


  export const CourseScalarFieldEnum: {
    course_id: 'course_id',
    year: 'year',
    semester: 'semester',
    course_name: 'course_name',
    course_code: 'course_code',
    lecture_name: 'lecture_name',
    ac_year_ID: 'ac_year_ID'
  };

  export type CourseScalarFieldEnum = (typeof CourseScalarFieldEnum)[keyof typeof CourseScalarFieldEnum]


  export const DirectorScalarFieldEnum: {
    director_id: 'director_id',
    user_id: 'user_id'
  };

  export type DirectorScalarFieldEnum = (typeof DirectorScalarFieldEnum)[keyof typeof DirectorScalarFieldEnum]


  export const ExamScalarFieldEnum: {
    exam_sem_id: 'exam_sem_id',
    semester: 'semester',
    year: 'year'
  };

  export type ExamScalarFieldEnum = (typeof ExamScalarFieldEnum)[keyof typeof ExamScalarFieldEnum]


  export const Exam_markScalarFieldEnum: {
    mark_id: 'mark_id',
    course_code: 'course_code',
    course_name: 'course_name',
    grade: 'grade',
    total_mark: 'total_mark',
    director_status: 'director_status',
    head_of_exam_status: 'head_of_exam_status',
    exam_sem_id: 'exam_sem_id',
    director_id: 'director_id',
    head_of_exam_id: 'head_of_exam_id',
    index_no: 'index_no'
  };

  export type Exam_markScalarFieldEnum = (typeof Exam_markScalarFieldEnum)[keyof typeof Exam_markScalarFieldEnum]


  export const Exam_timetableScalarFieldEnum: {
    timetable_id: 'timetable_id',
    exam_date: 'exam_date',
    exam_time: 'exam_time',
    course_code: 'course_code',
    course_name: 'course_name',
    exam_sem_id: 'exam_sem_id'
  };

  export type Exam_timetableScalarFieldEnum = (typeof Exam_timetableScalarFieldEnum)[keyof typeof Exam_timetableScalarFieldEnum]


  export const Head_of_exam_boardScalarFieldEnum: {
    head_of_exam_ID: 'head_of_exam_ID',
    user_id: 'user_id',
    staff_id: 'staff_id'
  };

  export type Head_of_exam_boardScalarFieldEnum = (typeof Head_of_exam_boardScalarFieldEnum)[keyof typeof Head_of_exam_boardScalarFieldEnum]


  export const Lecture_questionScalarFieldEnum: {
    exam_paper_id: 'exam_paper_id',
    lecture_id: 'lecture_id'
  };

  export type Lecture_questionScalarFieldEnum = (typeof Lecture_questionScalarFieldEnum)[keyof typeof Lecture_questionScalarFieldEnum]


  export const LecturerScalarFieldEnum: {
    lecturer_id: 'lecturer_id',
    degree: 'degree',
    user_id: 'user_id'
  };

  export type LecturerScalarFieldEnum = (typeof LecturerScalarFieldEnum)[keyof typeof LecturerScalarFieldEnum]


  export const Lecturer_coursesScalarFieldEnum: {
    user_id: 'user_id',
    course_id: 'course_id'
  };

  export type Lecturer_coursesScalarFieldEnum = (typeof Lecturer_coursesScalarFieldEnum)[keyof typeof Lecturer_coursesScalarFieldEnum]


  export const LetterScalarFieldEnum: {
    letter_id: 'letter_id',
    email: 'email',
    another_email: 'another_email',
    final_quali: 'final_quali',
    id_no: 'id_no',
    duration: 'duration',
    degree_status: 'degree_status',
    study_year: 'study_year',
    index_no: 'index_no',
    reg_no: 'reg_no',
    degree_prog: 'degree_prog',
    address: 'address',
    contact_no: 'contact_no',
    another_cont_no: 'another_cont_no',
    payment_voucher: 'payment_voucher'
  };

  export type LetterScalarFieldEnum = (typeof LetterScalarFieldEnum)[keyof typeof LetterScalarFieldEnum]


  export const MaScalarFieldEnum: {
    MA_id: 'MA_id',
    user_id: 'user_id',
    staff_id: 'staff_id',
    office_id: 'office_id',
    letter_id: 'letter_id'
  };

  export type MaScalarFieldEnum = (typeof MaScalarFieldEnum)[keyof typeof MaScalarFieldEnum]


  export const Mis_reportScalarFieldEnum: {
    mis_id: 'mis_id',
    report_id: 'report_id'
  };

  export type Mis_reportScalarFieldEnum = (typeof Mis_reportScalarFieldEnum)[keyof typeof Mis_reportScalarFieldEnum]


  export const Paper_marksScalarFieldEnum: {
    paper_id: 'paper_id',
    sub_marks: 'sub_marks',
    total_marks: 'total_marks',
    paper_precentage: 'paper_precentage',
    mark_id: 'mark_id'
  };

  export type Paper_marksScalarFieldEnum = (typeof Paper_marksScalarFieldEnum)[keyof typeof Paper_marksScalarFieldEnum]


  export const Paper_questionScalarFieldEnum: {
    exam_paper_id: 'exam_paper_id',
    course_code: 'course_code',
    course_name: 'course_name',
    question_no: 'question_no',
    exam_sem_id: 'exam_sem_id'
  };

  export type Paper_questionScalarFieldEnum = (typeof Paper_questionScalarFieldEnum)[keyof typeof Paper_questionScalarFieldEnum]


  export const PaymentScalarFieldEnum: {
    payment_id: 'payment_id',
    payment_date: 'payment_date',
    amount: 'amount',
    status: 'status',
    index_no: 'index_no',
    ac_year_ID: 'ac_year_ID'
  };

  export type PaymentScalarFieldEnum = (typeof PaymentScalarFieldEnum)[keyof typeof PaymentScalarFieldEnum]


  export const Repeat_courseScalarFieldEnum: {
    rc_id: 'rc_id',
    course_code: 'course_code',
    course_name: 'course_name',
    year: 'year',
    semester: 'semester'
  };

  export type Repeat_courseScalarFieldEnum = (typeof Repeat_courseScalarFieldEnum)[keyof typeof Repeat_courseScalarFieldEnum]


  export const ReportScalarFieldEnum: {
    report_id: 'report_id',
    course_name: 'course_name',
    course_code: 'course_code',
    year: 'year',
    semester: 'semester',
    exam_sem_id: 'exam_sem_id'
  };

  export type ReportScalarFieldEnum = (typeof ReportScalarFieldEnum)[keyof typeof ReportScalarFieldEnum]


  export const SarScalarFieldEnum: {
    SAR_id: 'SAR_id',
    user_id: 'user_id',
    staff_id: 'staff_id',
    office_id: 'office_id'
  };

  export type SarScalarFieldEnum = (typeof SarScalarFieldEnum)[keyof typeof SarScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const StaffScalarFieldEnum: {
    staff_id: 'staff_id',
    user_id: 'user_id'
  };

  export type StaffScalarFieldEnum = (typeof StaffScalarFieldEnum)[keyof typeof StaffScalarFieldEnum]


  export const StudentScalarFieldEnum: {
    index_no: 'index_no',
    user_id: 'user_id',
    nic: 'nic',
    gender: 'gender',
    initials: 'initials',
    title: 'title',
    general_eng: 'general_eng',
    district_no: 'district_no',
    intake: 'intake',
    reg_no: 'reg_no',
    telep_1: 'telep_1',
    telep_2: 'telep_2',
    address_no: 'address_no',
    address_city: 'address_city',
    address_street: 'address_street',
    address_4: 'address_4',
    student_temp_no: 'student_temp_no',
    district_name: 'district_name',
    name_initial: 'name_initial',
    full_name: 'full_name',
    syllabus: 'syllabus',
    AL_index_no: 'AL_index_no',
    rank: 'rank',
    GPA: 'GPA',
    ac_year_ID: 'ac_year_ID'
  };

  export type StudentScalarFieldEnum = (typeof StudentScalarFieldEnum)[keyof typeof StudentScalarFieldEnum]


  export const Subject_reportScalarFieldEnum: {
    subject_id: 'subject_id',
    no_of_student: 'no_of_student',
    report_id: 'report_id'
  };

  export type Subject_reportScalarFieldEnum = (typeof Subject_reportScalarFieldEnum)[keyof typeof Subject_reportScalarFieldEnum]


  export const System_pagesScalarFieldEnum: {
    page_id: 'page_id',
    content: 'content',
    admin_id: 'admin_id'
  };

  export type System_pagesScalarFieldEnum = (typeof System_pagesScalarFieldEnum)[keyof typeof System_pagesScalarFieldEnum]


  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const TranscriptScalarFieldEnum: {
    transcript_id: 'transcript_id',
    letter_id: 'letter_id'
  };

  export type TranscriptScalarFieldEnum = (typeof TranscriptScalarFieldEnum)[keyof typeof TranscriptScalarFieldEnum]


  export const UserScalarFieldEnum: {
    user_id: 'user_id',
    user_name: 'user_name',
    password: 'password',
    email: 'email',
    user_type: 'user_type',
    f_name: 'f_name',
    l_name: 'l_name',
    profile_pic: 'profile_pic'
  };

  export type UserScalarFieldEnum = (typeof UserScalarFieldEnum)[keyof typeof UserScalarFieldEnum]


  /**
   * Deep Input Types
   */


  export type academic_yearWhereInput = {
    AND?: Enumerable<academic_yearWhereInput>
    OR?: Enumerable<academic_yearWhereInput>
    NOT?: Enumerable<academic_yearWhereInput>
    ac_year_ID?: IntFilter | number
    no_of_student?: IntFilter | number
    year?: IntFilter | number
  }

  export type academic_yearOrderByWithRelationInput = {
    ac_year_ID?: SortOrder
    no_of_student?: SortOrder
    year?: SortOrder
  }

  export type academic_yearWhereUniqueInput = {
    ac_year_ID?: number
  }

  export type academic_yearOrderByWithAggregationInput = {
    ac_year_ID?: SortOrder
    no_of_student?: SortOrder
    year?: SortOrder
    _count?: academic_yearCountOrderByAggregateInput
    _avg?: academic_yearAvgOrderByAggregateInput
    _max?: academic_yearMaxOrderByAggregateInput
    _min?: academic_yearMinOrderByAggregateInput
    _sum?: academic_yearSumOrderByAggregateInput
  }

  export type academic_yearScalarWhereWithAggregatesInput = {
    AND?: Enumerable<academic_yearScalarWhereWithAggregatesInput>
    OR?: Enumerable<academic_yearScalarWhereWithAggregatesInput>
    NOT?: Enumerable<academic_yearScalarWhereWithAggregatesInput>
    ac_year_ID?: IntWithAggregatesFilter | number
    no_of_student?: IntWithAggregatesFilter | number
    year?: IntWithAggregatesFilter | number
  }

  export type admissionWhereInput = {
    AND?: Enumerable<admissionWhereInput>
    OR?: Enumerable<admissionWhereInput>
    NOT?: Enumerable<admissionWhereInput>
    admission_id?: IntFilter | number
    exam_hall?: StringFilter | string
    course_name?: StringFilter | string
    course_code?: StringFilter | string
    exan_date?: DateTimeFilter | Date | string
    exam_time?: DateTimeFilter | Date | string
    attendence_verify?: StringFilter | string
  }

  export type admissionOrderByWithRelationInput = {
    admission_id?: SortOrder
    exam_hall?: SortOrder
    course_name?: SortOrder
    course_code?: SortOrder
    exan_date?: SortOrder
    exam_time?: SortOrder
    attendence_verify?: SortOrder
  }

  export type admissionWhereUniqueInput = {
    admission_id?: number
  }

  export type admissionOrderByWithAggregationInput = {
    admission_id?: SortOrder
    exam_hall?: SortOrder
    course_name?: SortOrder
    course_code?: SortOrder
    exan_date?: SortOrder
    exam_time?: SortOrder
    attendence_verify?: SortOrder
    _count?: admissionCountOrderByAggregateInput
    _avg?: admissionAvgOrderByAggregateInput
    _max?: admissionMaxOrderByAggregateInput
    _min?: admissionMinOrderByAggregateInput
    _sum?: admissionSumOrderByAggregateInput
  }

  export type admissionScalarWhereWithAggregatesInput = {
    AND?: Enumerable<admissionScalarWhereWithAggregatesInput>
    OR?: Enumerable<admissionScalarWhereWithAggregatesInput>
    NOT?: Enumerable<admissionScalarWhereWithAggregatesInput>
    admission_id?: IntWithAggregatesFilter | number
    exam_hall?: StringWithAggregatesFilter | string
    course_name?: StringWithAggregatesFilter | string
    course_code?: StringWithAggregatesFilter | string
    exan_date?: DateTimeWithAggregatesFilter | Date | string
    exam_time?: DateTimeWithAggregatesFilter | Date | string
    attendence_verify?: StringWithAggregatesFilter | string
  }

  export type announcementWhereInput = {
    AND?: Enumerable<announcementWhereInput>
    OR?: Enumerable<announcementWhereInput>
    NOT?: Enumerable<announcementWhereInput>
    annou_id?: IntFilter | number
    content?: StringFilter | string
    admin_id?: IntFilter | number
  }

  export type announcementOrderByWithRelationInput = {
    annou_id?: SortOrder
    content?: SortOrder
    admin_id?: SortOrder
  }

  export type announcementWhereUniqueInput = {
    annou_id?: number
  }

  export type announcementOrderByWithAggregationInput = {
    annou_id?: SortOrder
    content?: SortOrder
    admin_id?: SortOrder
    _count?: announcementCountOrderByAggregateInput
    _avg?: announcementAvgOrderByAggregateInput
    _max?: announcementMaxOrderByAggregateInput
    _min?: announcementMinOrderByAggregateInput
    _sum?: announcementSumOrderByAggregateInput
  }

  export type announcementScalarWhereWithAggregatesInput = {
    AND?: Enumerable<announcementScalarWhereWithAggregatesInput>
    OR?: Enumerable<announcementScalarWhereWithAggregatesInput>
    NOT?: Enumerable<announcementScalarWhereWithAggregatesInput>
    annou_id?: IntWithAggregatesFilter | number
    content?: StringWithAggregatesFilter | string
    admin_id?: IntWithAggregatesFilter | number
  }

  export type assign_marksWhereInput = {
    AND?: Enumerable<assign_marksWhereInput>
    OR?: Enumerable<assign_marksWhereInput>
    NOT?: Enumerable<assign_marksWhereInput>
    assigment_id?: IntFilter | number
    sub_marks?: IntFilter | number
    total_marks?: IntFilter | number
    assign_precentage?: IntFilter | number
    mark_id?: IntFilter | number
  }

  export type assign_marksOrderByWithRelationInput = {
    assigment_id?: SortOrder
    sub_marks?: SortOrder
    total_marks?: SortOrder
    assign_precentage?: SortOrder
    mark_id?: SortOrder
  }

  export type assign_marksWhereUniqueInput = {
    assigment_id?: number
  }

  export type assign_marksOrderByWithAggregationInput = {
    assigment_id?: SortOrder
    sub_marks?: SortOrder
    total_marks?: SortOrder
    assign_precentage?: SortOrder
    mark_id?: SortOrder
    _count?: assign_marksCountOrderByAggregateInput
    _avg?: assign_marksAvgOrderByAggregateInput
    _max?: assign_marksMaxOrderByAggregateInput
    _min?: assign_marksMinOrderByAggregateInput
    _sum?: assign_marksSumOrderByAggregateInput
  }

  export type assign_marksScalarWhereWithAggregatesInput = {
    AND?: Enumerable<assign_marksScalarWhereWithAggregatesInput>
    OR?: Enumerable<assign_marksScalarWhereWithAggregatesInput>
    NOT?: Enumerable<assign_marksScalarWhereWithAggregatesInput>
    assigment_id?: IntWithAggregatesFilter | number
    sub_marks?: IntWithAggregatesFilter | number
    total_marks?: IntWithAggregatesFilter | number
    assign_precentage?: IntWithAggregatesFilter | number
    mark_id?: IntWithAggregatesFilter | number
  }

  export type assignmentsWhereInput = {
    AND?: Enumerable<assignmentsWhereInput>
    OR?: Enumerable<assignmentsWhereInput>
    NOT?: Enumerable<assignmentsWhereInput>
    assignment_id?: IntFilter | number
    name?: StringFilter | string
    description?: StringFilter | string
    contribution?: IntFilter | number
    lecturer_id?: IntFilter | number
    course_id?: IntFilter | number
  }

  export type assignmentsOrderByWithRelationInput = {
    assignment_id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    contribution?: SortOrder
    lecturer_id?: SortOrder
    course_id?: SortOrder
  }

  export type assignmentsWhereUniqueInput = {
    assignment_id?: number
  }

  export type assignmentsOrderByWithAggregationInput = {
    assignment_id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    contribution?: SortOrder
    lecturer_id?: SortOrder
    course_id?: SortOrder
    _count?: assignmentsCountOrderByAggregateInput
    _avg?: assignmentsAvgOrderByAggregateInput
    _max?: assignmentsMaxOrderByAggregateInput
    _min?: assignmentsMinOrderByAggregateInput
    _sum?: assignmentsSumOrderByAggregateInput
  }

  export type assignmentsScalarWhereWithAggregatesInput = {
    AND?: Enumerable<assignmentsScalarWhereWithAggregatesInput>
    OR?: Enumerable<assignmentsScalarWhereWithAggregatesInput>
    NOT?: Enumerable<assignmentsScalarWhereWithAggregatesInput>
    assignment_id?: IntWithAggregatesFilter | number
    name?: StringWithAggregatesFilter | string
    description?: StringWithAggregatesFilter | string
    contribution?: IntWithAggregatesFilter | number
    lecturer_id?: IntWithAggregatesFilter | number
    course_id?: IntWithAggregatesFilter | number
  }

  export type confirmWhereInput = {
    AND?: Enumerable<confirmWhereInput>
    OR?: Enumerable<confirmWhereInput>
    NOT?: Enumerable<confirmWhereInput>
    confirm_id?: IntFilter | number
    letter_id?: IntFilter | number
  }

  export type confirmOrderByWithRelationInput = {
    confirm_id?: SortOrder
    letter_id?: SortOrder
  }

  export type confirmWhereUniqueInput = {
    confirm_id?: number
  }

  export type confirmOrderByWithAggregationInput = {
    confirm_id?: SortOrder
    letter_id?: SortOrder
    _count?: confirmCountOrderByAggregateInput
    _avg?: confirmAvgOrderByAggregateInput
    _max?: confirmMaxOrderByAggregateInput
    _min?: confirmMinOrderByAggregateInput
    _sum?: confirmSumOrderByAggregateInput
  }

  export type confirmScalarWhereWithAggregatesInput = {
    AND?: Enumerable<confirmScalarWhereWithAggregatesInput>
    OR?: Enumerable<confirmScalarWhereWithAggregatesInput>
    NOT?: Enumerable<confirmScalarWhereWithAggregatesInput>
    confirm_id?: IntWithAggregatesFilter | number
    letter_id?: IntWithAggregatesFilter | number
  }

  export type courseWhereInput = {
    AND?: Enumerable<courseWhereInput>
    OR?: Enumerable<courseWhereInput>
    NOT?: Enumerable<courseWhereInput>
    course_id?: IntFilter | number
    year?: IntFilter | number
    semester?: StringFilter | string
    course_name?: StringFilter | string
    course_code?: StringFilter | string
    lecture_name?: StringFilter | string
    ac_year_ID?: IntFilter | number
  }

  export type courseOrderByWithRelationInput = {
    course_id?: SortOrder
    year?: SortOrder
    semester?: SortOrder
    course_name?: SortOrder
    course_code?: SortOrder
    lecture_name?: SortOrder
    ac_year_ID?: SortOrder
  }

  export type courseWhereUniqueInput = {
    course_id?: number
  }

  export type courseOrderByWithAggregationInput = {
    course_id?: SortOrder
    year?: SortOrder
    semester?: SortOrder
    course_name?: SortOrder
    course_code?: SortOrder
    lecture_name?: SortOrder
    ac_year_ID?: SortOrder
    _count?: courseCountOrderByAggregateInput
    _avg?: courseAvgOrderByAggregateInput
    _max?: courseMaxOrderByAggregateInput
    _min?: courseMinOrderByAggregateInput
    _sum?: courseSumOrderByAggregateInput
  }

  export type courseScalarWhereWithAggregatesInput = {
    AND?: Enumerable<courseScalarWhereWithAggregatesInput>
    OR?: Enumerable<courseScalarWhereWithAggregatesInput>
    NOT?: Enumerable<courseScalarWhereWithAggregatesInput>
    course_id?: IntWithAggregatesFilter | number
    year?: IntWithAggregatesFilter | number
    semester?: StringWithAggregatesFilter | string
    course_name?: StringWithAggregatesFilter | string
    course_code?: StringWithAggregatesFilter | string
    lecture_name?: StringWithAggregatesFilter | string
    ac_year_ID?: IntWithAggregatesFilter | number
  }

  export type directorWhereInput = {
    AND?: Enumerable<directorWhereInput>
    OR?: Enumerable<directorWhereInput>
    NOT?: Enumerable<directorWhereInput>
    director_id?: IntFilter | number
    user_id?: IntFilter | number
  }

  export type directorOrderByWithRelationInput = {
    director_id?: SortOrder
    user_id?: SortOrder
  }

  export type directorWhereUniqueInput = {
    director_id?: number
  }

  export type directorOrderByWithAggregationInput = {
    director_id?: SortOrder
    user_id?: SortOrder
    _count?: directorCountOrderByAggregateInput
    _avg?: directorAvgOrderByAggregateInput
    _max?: directorMaxOrderByAggregateInput
    _min?: directorMinOrderByAggregateInput
    _sum?: directorSumOrderByAggregateInput
  }

  export type directorScalarWhereWithAggregatesInput = {
    AND?: Enumerable<directorScalarWhereWithAggregatesInput>
    OR?: Enumerable<directorScalarWhereWithAggregatesInput>
    NOT?: Enumerable<directorScalarWhereWithAggregatesInput>
    director_id?: IntWithAggregatesFilter | number
    user_id?: IntWithAggregatesFilter | number
  }

  export type examWhereInput = {
    AND?: Enumerable<examWhereInput>
    OR?: Enumerable<examWhereInput>
    NOT?: Enumerable<examWhereInput>
    exam_sem_id?: IntFilter | number
    semester?: IntFilter | number
    year?: IntFilter | number
  }

  export type examOrderByWithRelationInput = {
    exam_sem_id?: SortOrder
    semester?: SortOrder
    year?: SortOrder
  }

  export type examWhereUniqueInput = {
    exam_sem_id?: number
  }

  export type examOrderByWithAggregationInput = {
    exam_sem_id?: SortOrder
    semester?: SortOrder
    year?: SortOrder
    _count?: examCountOrderByAggregateInput
    _avg?: examAvgOrderByAggregateInput
    _max?: examMaxOrderByAggregateInput
    _min?: examMinOrderByAggregateInput
    _sum?: examSumOrderByAggregateInput
  }

  export type examScalarWhereWithAggregatesInput = {
    AND?: Enumerable<examScalarWhereWithAggregatesInput>
    OR?: Enumerable<examScalarWhereWithAggregatesInput>
    NOT?: Enumerable<examScalarWhereWithAggregatesInput>
    exam_sem_id?: IntWithAggregatesFilter | number
    semester?: IntWithAggregatesFilter | number
    year?: IntWithAggregatesFilter | number
  }

  export type exam_markWhereInput = {
    AND?: Enumerable<exam_markWhereInput>
    OR?: Enumerable<exam_markWhereInput>
    NOT?: Enumerable<exam_markWhereInput>
    mark_id?: IntFilter | number
    course_code?: StringFilter | string
    course_name?: StringFilter | string
    grade?: StringFilter | string
    total_mark?: IntFilter | number
    director_status?: StringFilter | string
    head_of_exam_status?: StringFilter | string
    exam_sem_id?: IntFilter | number
    director_id?: IntFilter | number
    head_of_exam_id?: IntFilter | number
    index_no?: IntFilter | number
  }

  export type exam_markOrderByWithRelationInput = {
    mark_id?: SortOrder
    course_code?: SortOrder
    course_name?: SortOrder
    grade?: SortOrder
    total_mark?: SortOrder
    director_status?: SortOrder
    head_of_exam_status?: SortOrder
    exam_sem_id?: SortOrder
    director_id?: SortOrder
    head_of_exam_id?: SortOrder
    index_no?: SortOrder
  }

  export type exam_markWhereUniqueInput = {
    mark_id?: number
  }

  export type exam_markOrderByWithAggregationInput = {
    mark_id?: SortOrder
    course_code?: SortOrder
    course_name?: SortOrder
    grade?: SortOrder
    total_mark?: SortOrder
    director_status?: SortOrder
    head_of_exam_status?: SortOrder
    exam_sem_id?: SortOrder
    director_id?: SortOrder
    head_of_exam_id?: SortOrder
    index_no?: SortOrder
    _count?: exam_markCountOrderByAggregateInput
    _avg?: exam_markAvgOrderByAggregateInput
    _max?: exam_markMaxOrderByAggregateInput
    _min?: exam_markMinOrderByAggregateInput
    _sum?: exam_markSumOrderByAggregateInput
  }

  export type exam_markScalarWhereWithAggregatesInput = {
    AND?: Enumerable<exam_markScalarWhereWithAggregatesInput>
    OR?: Enumerable<exam_markScalarWhereWithAggregatesInput>
    NOT?: Enumerable<exam_markScalarWhereWithAggregatesInput>
    mark_id?: IntWithAggregatesFilter | number
    course_code?: StringWithAggregatesFilter | string
    course_name?: StringWithAggregatesFilter | string
    grade?: StringWithAggregatesFilter | string
    total_mark?: IntWithAggregatesFilter | number
    director_status?: StringWithAggregatesFilter | string
    head_of_exam_status?: StringWithAggregatesFilter | string
    exam_sem_id?: IntWithAggregatesFilter | number
    director_id?: IntWithAggregatesFilter | number
    head_of_exam_id?: IntWithAggregatesFilter | number
    index_no?: IntWithAggregatesFilter | number
  }

  export type exam_timetableWhereInput = {
    AND?: Enumerable<exam_timetableWhereInput>
    OR?: Enumerable<exam_timetableWhereInput>
    NOT?: Enumerable<exam_timetableWhereInput>
    timetable_id?: IntFilter | number
    exam_date?: DateTimeFilter | Date | string
    exam_time?: DateTimeFilter | Date | string
    course_code?: StringFilter | string
    course_name?: StringFilter | string
    exam_sem_id?: IntFilter | number
  }

  export type exam_timetableOrderByWithRelationInput = {
    timetable_id?: SortOrder
    exam_date?: SortOrder
    exam_time?: SortOrder
    course_code?: SortOrder
    course_name?: SortOrder
    exam_sem_id?: SortOrder
  }

  export type exam_timetableWhereUniqueInput = {
    timetable_id?: number
  }

  export type exam_timetableOrderByWithAggregationInput = {
    timetable_id?: SortOrder
    exam_date?: SortOrder
    exam_time?: SortOrder
    course_code?: SortOrder
    course_name?: SortOrder
    exam_sem_id?: SortOrder
    _count?: exam_timetableCountOrderByAggregateInput
    _avg?: exam_timetableAvgOrderByAggregateInput
    _max?: exam_timetableMaxOrderByAggregateInput
    _min?: exam_timetableMinOrderByAggregateInput
    _sum?: exam_timetableSumOrderByAggregateInput
  }

  export type exam_timetableScalarWhereWithAggregatesInput = {
    AND?: Enumerable<exam_timetableScalarWhereWithAggregatesInput>
    OR?: Enumerable<exam_timetableScalarWhereWithAggregatesInput>
    NOT?: Enumerable<exam_timetableScalarWhereWithAggregatesInput>
    timetable_id?: IntWithAggregatesFilter | number
    exam_date?: DateTimeWithAggregatesFilter | Date | string
    exam_time?: DateTimeWithAggregatesFilter | Date | string
    course_code?: StringWithAggregatesFilter | string
    course_name?: StringWithAggregatesFilter | string
    exam_sem_id?: IntWithAggregatesFilter | number
  }

  export type head_of_exam_boardWhereInput = {
    AND?: Enumerable<head_of_exam_boardWhereInput>
    OR?: Enumerable<head_of_exam_boardWhereInput>
    NOT?: Enumerable<head_of_exam_boardWhereInput>
    head_of_exam_ID?: IntFilter | number
    user_id?: IntFilter | number
    staff_id?: IntFilter | number
  }

  export type head_of_exam_boardOrderByWithRelationInput = {
    head_of_exam_ID?: SortOrder
    user_id?: SortOrder
    staff_id?: SortOrder
  }

  export type head_of_exam_boardWhereUniqueInput = {
    head_of_exam_ID?: number
  }

  export type head_of_exam_boardOrderByWithAggregationInput = {
    head_of_exam_ID?: SortOrder
    user_id?: SortOrder
    staff_id?: SortOrder
    _count?: head_of_exam_boardCountOrderByAggregateInput
    _avg?: head_of_exam_boardAvgOrderByAggregateInput
    _max?: head_of_exam_boardMaxOrderByAggregateInput
    _min?: head_of_exam_boardMinOrderByAggregateInput
    _sum?: head_of_exam_boardSumOrderByAggregateInput
  }

  export type head_of_exam_boardScalarWhereWithAggregatesInput = {
    AND?: Enumerable<head_of_exam_boardScalarWhereWithAggregatesInput>
    OR?: Enumerable<head_of_exam_boardScalarWhereWithAggregatesInput>
    NOT?: Enumerable<head_of_exam_boardScalarWhereWithAggregatesInput>
    head_of_exam_ID?: IntWithAggregatesFilter | number
    user_id?: IntWithAggregatesFilter | number
    staff_id?: IntWithAggregatesFilter | number
  }

  export type lecture_questionWhereInput = {
    AND?: Enumerable<lecture_questionWhereInput>
    OR?: Enumerable<lecture_questionWhereInput>
    NOT?: Enumerable<lecture_questionWhereInput>
    exam_paper_id?: IntFilter | number
    lecture_id?: IntFilter | number
  }

  export type lecture_questionOrderByWithRelationInput = {
    exam_paper_id?: SortOrder
    lecture_id?: SortOrder
  }

  export type lecture_questionWhereUniqueInput = {
    exam_paper_id?: number
  }

  export type lecture_questionOrderByWithAggregationInput = {
    exam_paper_id?: SortOrder
    lecture_id?: SortOrder
    _count?: lecture_questionCountOrderByAggregateInput
    _avg?: lecture_questionAvgOrderByAggregateInput
    _max?: lecture_questionMaxOrderByAggregateInput
    _min?: lecture_questionMinOrderByAggregateInput
    _sum?: lecture_questionSumOrderByAggregateInput
  }

  export type lecture_questionScalarWhereWithAggregatesInput = {
    AND?: Enumerable<lecture_questionScalarWhereWithAggregatesInput>
    OR?: Enumerable<lecture_questionScalarWhereWithAggregatesInput>
    NOT?: Enumerable<lecture_questionScalarWhereWithAggregatesInput>
    exam_paper_id?: IntWithAggregatesFilter | number
    lecture_id?: IntWithAggregatesFilter | number
  }

  export type lecturerWhereInput = {
    AND?: Enumerable<lecturerWhereInput>
    OR?: Enumerable<lecturerWhereInput>
    NOT?: Enumerable<lecturerWhereInput>
    lecturer_id?: IntFilter | number
    degree?: StringFilter | string
    user_id?: IntFilter | number
  }

  export type lecturerOrderByWithRelationInput = {
    lecturer_id?: SortOrder
    degree?: SortOrder
    user_id?: SortOrder
  }

  export type lecturerWhereUniqueInput = {
    lecturer_id?: number
  }

  export type lecturerOrderByWithAggregationInput = {
    lecturer_id?: SortOrder
    degree?: SortOrder
    user_id?: SortOrder
    _count?: lecturerCountOrderByAggregateInput
    _avg?: lecturerAvgOrderByAggregateInput
    _max?: lecturerMaxOrderByAggregateInput
    _min?: lecturerMinOrderByAggregateInput
    _sum?: lecturerSumOrderByAggregateInput
  }

  export type lecturerScalarWhereWithAggregatesInput = {
    AND?: Enumerable<lecturerScalarWhereWithAggregatesInput>
    OR?: Enumerable<lecturerScalarWhereWithAggregatesInput>
    NOT?: Enumerable<lecturerScalarWhereWithAggregatesInput>
    lecturer_id?: IntWithAggregatesFilter | number
    degree?: StringWithAggregatesFilter | string
    user_id?: IntWithAggregatesFilter | number
  }

  export type lecturer_coursesWhereInput = {
    AND?: Enumerable<lecturer_coursesWhereInput>
    OR?: Enumerable<lecturer_coursesWhereInput>
    NOT?: Enumerable<lecturer_coursesWhereInput>
    user_id?: IntFilter | number
    course_id?: IntFilter | number
  }

  export type lecturer_coursesOrderByWithRelationInput = {
    user_id?: SortOrder
    course_id?: SortOrder
  }

  export type lecturer_coursesWhereUniqueInput = {
    user_id_course_id?: lecturer_coursesUser_idCourse_idCompoundUniqueInput
  }

  export type lecturer_coursesOrderByWithAggregationInput = {
    user_id?: SortOrder
    course_id?: SortOrder
    _count?: lecturer_coursesCountOrderByAggregateInput
    _avg?: lecturer_coursesAvgOrderByAggregateInput
    _max?: lecturer_coursesMaxOrderByAggregateInput
    _min?: lecturer_coursesMinOrderByAggregateInput
    _sum?: lecturer_coursesSumOrderByAggregateInput
  }

  export type lecturer_coursesScalarWhereWithAggregatesInput = {
    AND?: Enumerable<lecturer_coursesScalarWhereWithAggregatesInput>
    OR?: Enumerable<lecturer_coursesScalarWhereWithAggregatesInput>
    NOT?: Enumerable<lecturer_coursesScalarWhereWithAggregatesInput>
    user_id?: IntWithAggregatesFilter | number
    course_id?: IntWithAggregatesFilter | number
  }

  export type letterWhereInput = {
    AND?: Enumerable<letterWhereInput>
    OR?: Enumerable<letterWhereInput>
    NOT?: Enumerable<letterWhereInput>
    letter_id?: IntFilter | number
    email?: StringFilter | string
    another_email?: StringFilter | string
    final_quali?: StringFilter | string
    id_no?: StringFilter | string
    duration?: IntFilter | number
    degree_status?: StringFilter | string
    study_year?: IntFilter | number
    index_no?: IntFilter | number
    reg_no?: StringFilter | string
    degree_prog?: StringFilter | string
    address?: StringFilter | string
    contact_no?: StringFilter | string
    another_cont_no?: StringFilter | string
    payment_voucher?: StringFilter | string
  }

  export type letterOrderByWithRelationInput = {
    letter_id?: SortOrder
    email?: SortOrder
    another_email?: SortOrder
    final_quali?: SortOrder
    id_no?: SortOrder
    duration?: SortOrder
    degree_status?: SortOrder
    study_year?: SortOrder
    index_no?: SortOrder
    reg_no?: SortOrder
    degree_prog?: SortOrder
    address?: SortOrder
    contact_no?: SortOrder
    another_cont_no?: SortOrder
    payment_voucher?: SortOrder
  }

  export type letterWhereUniqueInput = {
    letter_id?: number
  }

  export type letterOrderByWithAggregationInput = {
    letter_id?: SortOrder
    email?: SortOrder
    another_email?: SortOrder
    final_quali?: SortOrder
    id_no?: SortOrder
    duration?: SortOrder
    degree_status?: SortOrder
    study_year?: SortOrder
    index_no?: SortOrder
    reg_no?: SortOrder
    degree_prog?: SortOrder
    address?: SortOrder
    contact_no?: SortOrder
    another_cont_no?: SortOrder
    payment_voucher?: SortOrder
    _count?: letterCountOrderByAggregateInput
    _avg?: letterAvgOrderByAggregateInput
    _max?: letterMaxOrderByAggregateInput
    _min?: letterMinOrderByAggregateInput
    _sum?: letterSumOrderByAggregateInput
  }

  export type letterScalarWhereWithAggregatesInput = {
    AND?: Enumerable<letterScalarWhereWithAggregatesInput>
    OR?: Enumerable<letterScalarWhereWithAggregatesInput>
    NOT?: Enumerable<letterScalarWhereWithAggregatesInput>
    letter_id?: IntWithAggregatesFilter | number
    email?: StringWithAggregatesFilter | string
    another_email?: StringWithAggregatesFilter | string
    final_quali?: StringWithAggregatesFilter | string
    id_no?: StringWithAggregatesFilter | string
    duration?: IntWithAggregatesFilter | number
    degree_status?: StringWithAggregatesFilter | string
    study_year?: IntWithAggregatesFilter | number
    index_no?: IntWithAggregatesFilter | number
    reg_no?: StringWithAggregatesFilter | string
    degree_prog?: StringWithAggregatesFilter | string
    address?: StringWithAggregatesFilter | string
    contact_no?: StringWithAggregatesFilter | string
    another_cont_no?: StringWithAggregatesFilter | string
    payment_voucher?: StringWithAggregatesFilter | string
  }

  export type maWhereInput = {
    AND?: Enumerable<maWhereInput>
    OR?: Enumerable<maWhereInput>
    NOT?: Enumerable<maWhereInput>
    MA_id?: IntFilter | number
    user_id?: IntFilter | number
    staff_id?: IntFilter | number
    office_id?: StringFilter | string
    letter_id?: IntFilter | number
  }

  export type maOrderByWithRelationInput = {
    MA_id?: SortOrder
    user_id?: SortOrder
    staff_id?: SortOrder
    office_id?: SortOrder
    letter_id?: SortOrder
  }

  export type maWhereUniqueInput = {
    MA_id?: number
  }

  export type maOrderByWithAggregationInput = {
    MA_id?: SortOrder
    user_id?: SortOrder
    staff_id?: SortOrder
    office_id?: SortOrder
    letter_id?: SortOrder
    _count?: maCountOrderByAggregateInput
    _avg?: maAvgOrderByAggregateInput
    _max?: maMaxOrderByAggregateInput
    _min?: maMinOrderByAggregateInput
    _sum?: maSumOrderByAggregateInput
  }

  export type maScalarWhereWithAggregatesInput = {
    AND?: Enumerable<maScalarWhereWithAggregatesInput>
    OR?: Enumerable<maScalarWhereWithAggregatesInput>
    NOT?: Enumerable<maScalarWhereWithAggregatesInput>
    MA_id?: IntWithAggregatesFilter | number
    user_id?: IntWithAggregatesFilter | number
    staff_id?: IntWithAggregatesFilter | number
    office_id?: StringWithAggregatesFilter | string
    letter_id?: IntWithAggregatesFilter | number
  }

  export type mis_reportWhereInput = {
    AND?: Enumerable<mis_reportWhereInput>
    OR?: Enumerable<mis_reportWhereInput>
    NOT?: Enumerable<mis_reportWhereInput>
    mis_id?: IntFilter | number
    report_id?: IntFilter | number
  }

  export type mis_reportOrderByWithRelationInput = {
    mis_id?: SortOrder
    report_id?: SortOrder
  }

  export type mis_reportWhereUniqueInput = {
    mis_id?: number
  }

  export type mis_reportOrderByWithAggregationInput = {
    mis_id?: SortOrder
    report_id?: SortOrder
    _count?: mis_reportCountOrderByAggregateInput
    _avg?: mis_reportAvgOrderByAggregateInput
    _max?: mis_reportMaxOrderByAggregateInput
    _min?: mis_reportMinOrderByAggregateInput
    _sum?: mis_reportSumOrderByAggregateInput
  }

  export type mis_reportScalarWhereWithAggregatesInput = {
    AND?: Enumerable<mis_reportScalarWhereWithAggregatesInput>
    OR?: Enumerable<mis_reportScalarWhereWithAggregatesInput>
    NOT?: Enumerable<mis_reportScalarWhereWithAggregatesInput>
    mis_id?: IntWithAggregatesFilter | number
    report_id?: IntWithAggregatesFilter | number
  }

  export type paper_marksWhereInput = {
    AND?: Enumerable<paper_marksWhereInput>
    OR?: Enumerable<paper_marksWhereInput>
    NOT?: Enumerable<paper_marksWhereInput>
    paper_id?: IntFilter | number
    sub_marks?: IntFilter | number
    total_marks?: IntFilter | number
    paper_precentage?: IntFilter | number
    mark_id?: IntFilter | number
  }

  export type paper_marksOrderByWithRelationInput = {
    paper_id?: SortOrder
    sub_marks?: SortOrder
    total_marks?: SortOrder
    paper_precentage?: SortOrder
    mark_id?: SortOrder
  }

  export type paper_marksWhereUniqueInput = {
    paper_id?: number
  }

  export type paper_marksOrderByWithAggregationInput = {
    paper_id?: SortOrder
    sub_marks?: SortOrder
    total_marks?: SortOrder
    paper_precentage?: SortOrder
    mark_id?: SortOrder
    _count?: paper_marksCountOrderByAggregateInput
    _avg?: paper_marksAvgOrderByAggregateInput
    _max?: paper_marksMaxOrderByAggregateInput
    _min?: paper_marksMinOrderByAggregateInput
    _sum?: paper_marksSumOrderByAggregateInput
  }

  export type paper_marksScalarWhereWithAggregatesInput = {
    AND?: Enumerable<paper_marksScalarWhereWithAggregatesInput>
    OR?: Enumerable<paper_marksScalarWhereWithAggregatesInput>
    NOT?: Enumerable<paper_marksScalarWhereWithAggregatesInput>
    paper_id?: IntWithAggregatesFilter | number
    sub_marks?: IntWithAggregatesFilter | number
    total_marks?: IntWithAggregatesFilter | number
    paper_precentage?: IntWithAggregatesFilter | number
    mark_id?: IntWithAggregatesFilter | number
  }

  export type paper_questionWhereInput = {
    AND?: Enumerable<paper_questionWhereInput>
    OR?: Enumerable<paper_questionWhereInput>
    NOT?: Enumerable<paper_questionWhereInput>
    exam_paper_id?: IntFilter | number
    course_code?: StringFilter | string
    course_name?: StringFilter | string
    question_no?: IntFilter | number
    exam_sem_id?: IntFilter | number
  }

  export type paper_questionOrderByWithRelationInput = {
    exam_paper_id?: SortOrder
    course_code?: SortOrder
    course_name?: SortOrder
    question_no?: SortOrder
    exam_sem_id?: SortOrder
  }

  export type paper_questionWhereUniqueInput = {
    exam_paper_id?: number
  }

  export type paper_questionOrderByWithAggregationInput = {
    exam_paper_id?: SortOrder
    course_code?: SortOrder
    course_name?: SortOrder
    question_no?: SortOrder
    exam_sem_id?: SortOrder
    _count?: paper_questionCountOrderByAggregateInput
    _avg?: paper_questionAvgOrderByAggregateInput
    _max?: paper_questionMaxOrderByAggregateInput
    _min?: paper_questionMinOrderByAggregateInput
    _sum?: paper_questionSumOrderByAggregateInput
  }

  export type paper_questionScalarWhereWithAggregatesInput = {
    AND?: Enumerable<paper_questionScalarWhereWithAggregatesInput>
    OR?: Enumerable<paper_questionScalarWhereWithAggregatesInput>
    NOT?: Enumerable<paper_questionScalarWhereWithAggregatesInput>
    exam_paper_id?: IntWithAggregatesFilter | number
    course_code?: StringWithAggregatesFilter | string
    course_name?: StringWithAggregatesFilter | string
    question_no?: IntWithAggregatesFilter | number
    exam_sem_id?: IntWithAggregatesFilter | number
  }

  export type paymentWhereInput = {
    AND?: Enumerable<paymentWhereInput>
    OR?: Enumerable<paymentWhereInput>
    NOT?: Enumerable<paymentWhereInput>
    payment_id?: IntFilter | number
    payment_date?: DateTimeFilter | Date | string
    amount?: IntFilter | number
    status?: StringFilter | string
    index_no?: IntFilter | number
    ac_year_ID?: IntFilter | number
  }

  export type paymentOrderByWithRelationInput = {
    payment_id?: SortOrder
    payment_date?: SortOrder
    amount?: SortOrder
    status?: SortOrder
    index_no?: SortOrder
    ac_year_ID?: SortOrder
  }

  export type paymentWhereUniqueInput = {
    payment_id?: number
  }

  export type paymentOrderByWithAggregationInput = {
    payment_id?: SortOrder
    payment_date?: SortOrder
    amount?: SortOrder
    status?: SortOrder
    index_no?: SortOrder
    ac_year_ID?: SortOrder
    _count?: paymentCountOrderByAggregateInput
    _avg?: paymentAvgOrderByAggregateInput
    _max?: paymentMaxOrderByAggregateInput
    _min?: paymentMinOrderByAggregateInput
    _sum?: paymentSumOrderByAggregateInput
  }

  export type paymentScalarWhereWithAggregatesInput = {
    AND?: Enumerable<paymentScalarWhereWithAggregatesInput>
    OR?: Enumerable<paymentScalarWhereWithAggregatesInput>
    NOT?: Enumerable<paymentScalarWhereWithAggregatesInput>
    payment_id?: IntWithAggregatesFilter | number
    payment_date?: DateTimeWithAggregatesFilter | Date | string
    amount?: IntWithAggregatesFilter | number
    status?: StringWithAggregatesFilter | string
    index_no?: IntWithAggregatesFilter | number
    ac_year_ID?: IntWithAggregatesFilter | number
  }

  export type repeat_courseWhereInput = {
    AND?: Enumerable<repeat_courseWhereInput>
    OR?: Enumerable<repeat_courseWhereInput>
    NOT?: Enumerable<repeat_courseWhereInput>
    rc_id?: IntFilter | number
    course_code?: StringFilter | string
    course_name?: StringFilter | string
    year?: IntFilter | number
    semester?: StringFilter | string
  }

  export type repeat_courseOrderByWithRelationInput = {
    rc_id?: SortOrder
    course_code?: SortOrder
    course_name?: SortOrder
    year?: SortOrder
    semester?: SortOrder
  }

  export type repeat_courseWhereUniqueInput = {
    rc_id?: number
  }

  export type repeat_courseOrderByWithAggregationInput = {
    rc_id?: SortOrder
    course_code?: SortOrder
    course_name?: SortOrder
    year?: SortOrder
    semester?: SortOrder
    _count?: repeat_courseCountOrderByAggregateInput
    _avg?: repeat_courseAvgOrderByAggregateInput
    _max?: repeat_courseMaxOrderByAggregateInput
    _min?: repeat_courseMinOrderByAggregateInput
    _sum?: repeat_courseSumOrderByAggregateInput
  }

  export type repeat_courseScalarWhereWithAggregatesInput = {
    AND?: Enumerable<repeat_courseScalarWhereWithAggregatesInput>
    OR?: Enumerable<repeat_courseScalarWhereWithAggregatesInput>
    NOT?: Enumerable<repeat_courseScalarWhereWithAggregatesInput>
    rc_id?: IntWithAggregatesFilter | number
    course_code?: StringWithAggregatesFilter | string
    course_name?: StringWithAggregatesFilter | string
    year?: IntWithAggregatesFilter | number
    semester?: StringWithAggregatesFilter | string
  }

  export type reportWhereInput = {
    AND?: Enumerable<reportWhereInput>
    OR?: Enumerable<reportWhereInput>
    NOT?: Enumerable<reportWhereInput>
    report_id?: IntFilter | number
    course_name?: StringFilter | string
    course_code?: StringFilter | string
    year?: IntFilter | number
    semester?: StringFilter | string
    exam_sem_id?: IntFilter | number
  }

  export type reportOrderByWithRelationInput = {
    report_id?: SortOrder
    course_name?: SortOrder
    course_code?: SortOrder
    year?: SortOrder
    semester?: SortOrder
    exam_sem_id?: SortOrder
  }

  export type reportWhereUniqueInput = {
    report_id?: number
  }

  export type reportOrderByWithAggregationInput = {
    report_id?: SortOrder
    course_name?: SortOrder
    course_code?: SortOrder
    year?: SortOrder
    semester?: SortOrder
    exam_sem_id?: SortOrder
    _count?: reportCountOrderByAggregateInput
    _avg?: reportAvgOrderByAggregateInput
    _max?: reportMaxOrderByAggregateInput
    _min?: reportMinOrderByAggregateInput
    _sum?: reportSumOrderByAggregateInput
  }

  export type reportScalarWhereWithAggregatesInput = {
    AND?: Enumerable<reportScalarWhereWithAggregatesInput>
    OR?: Enumerable<reportScalarWhereWithAggregatesInput>
    NOT?: Enumerable<reportScalarWhereWithAggregatesInput>
    report_id?: IntWithAggregatesFilter | number
    course_name?: StringWithAggregatesFilter | string
    course_code?: StringWithAggregatesFilter | string
    year?: IntWithAggregatesFilter | number
    semester?: StringWithAggregatesFilter | string
    exam_sem_id?: IntWithAggregatesFilter | number
  }

  export type sarWhereInput = {
    AND?: Enumerable<sarWhereInput>
    OR?: Enumerable<sarWhereInput>
    NOT?: Enumerable<sarWhereInput>
    SAR_id?: IntFilter | number
    user_id?: IntFilter | number
    staff_id?: IntFilter | number
    office_id?: IntFilter | number
  }

  export type sarOrderByWithRelationInput = {
    SAR_id?: SortOrder
    user_id?: SortOrder
    staff_id?: SortOrder
    office_id?: SortOrder
  }

  export type sarWhereUniqueInput = {
    SAR_id?: number
  }

  export type sarOrderByWithAggregationInput = {
    SAR_id?: SortOrder
    user_id?: SortOrder
    staff_id?: SortOrder
    office_id?: SortOrder
    _count?: sarCountOrderByAggregateInput
    _avg?: sarAvgOrderByAggregateInput
    _max?: sarMaxOrderByAggregateInput
    _min?: sarMinOrderByAggregateInput
    _sum?: sarSumOrderByAggregateInput
  }

  export type sarScalarWhereWithAggregatesInput = {
    AND?: Enumerable<sarScalarWhereWithAggregatesInput>
    OR?: Enumerable<sarScalarWhereWithAggregatesInput>
    NOT?: Enumerable<sarScalarWhereWithAggregatesInput>
    SAR_id?: IntWithAggregatesFilter | number
    user_id?: IntWithAggregatesFilter | number
    staff_id?: IntWithAggregatesFilter | number
    office_id?: IntWithAggregatesFilter | number
  }

  export type staffWhereInput = {
    AND?: Enumerable<staffWhereInput>
    OR?: Enumerable<staffWhereInput>
    NOT?: Enumerable<staffWhereInput>
    staff_id?: IntFilter | number
    user_id?: IntFilter | number
  }

  export type staffOrderByWithRelationInput = {
    staff_id?: SortOrder
    user_id?: SortOrder
  }

  export type staffWhereUniqueInput = {
    staff_id?: number
  }

  export type staffOrderByWithAggregationInput = {
    staff_id?: SortOrder
    user_id?: SortOrder
    _count?: staffCountOrderByAggregateInput
    _avg?: staffAvgOrderByAggregateInput
    _max?: staffMaxOrderByAggregateInput
    _min?: staffMinOrderByAggregateInput
    _sum?: staffSumOrderByAggregateInput
  }

  export type staffScalarWhereWithAggregatesInput = {
    AND?: Enumerable<staffScalarWhereWithAggregatesInput>
    OR?: Enumerable<staffScalarWhereWithAggregatesInput>
    NOT?: Enumerable<staffScalarWhereWithAggregatesInput>
    staff_id?: IntWithAggregatesFilter | number
    user_id?: IntWithAggregatesFilter | number
  }

  export type studentWhereInput = {
    AND?: Enumerable<studentWhereInput>
    OR?: Enumerable<studentWhereInput>
    NOT?: Enumerable<studentWhereInput>
    index_no?: IntFilter | number
    user_id?: IntFilter | number
    nic?: StringFilter | string
    gender?: StringFilter | string
    initials?: StringFilter | string
    title?: StringFilter | string
    general_eng?: StringFilter | string
    district_no?: StringFilter | string
    intake?: StringFilter | string
    reg_no?: StringFilter | string
    telep_1?: StringFilter | string
    telep_2?: StringFilter | string
    address_no?: StringFilter | string
    address_city?: StringFilter | string
    address_street?: StringFilter | string
    address_4?: StringFilter | string
    student_temp_no?: IntFilter | number
    district_name?: StringFilter | string
    name_initial?: StringFilter | string
    full_name?: StringFilter | string
    syllabus?: StringFilter | string
    AL_index_no?: IntFilter | number
    rank?: IntFilter | number
    GPA?: IntFilter | number
    ac_year_ID?: IntFilter | number
  }

  export type studentOrderByWithRelationInput = {
    index_no?: SortOrder
    user_id?: SortOrder
    nic?: SortOrder
    gender?: SortOrder
    initials?: SortOrder
    title?: SortOrder
    general_eng?: SortOrder
    district_no?: SortOrder
    intake?: SortOrder
    reg_no?: SortOrder
    telep_1?: SortOrder
    telep_2?: SortOrder
    address_no?: SortOrder
    address_city?: SortOrder
    address_street?: SortOrder
    address_4?: SortOrder
    student_temp_no?: SortOrder
    district_name?: SortOrder
    name_initial?: SortOrder
    full_name?: SortOrder
    syllabus?: SortOrder
    AL_index_no?: SortOrder
    rank?: SortOrder
    GPA?: SortOrder
    ac_year_ID?: SortOrder
  }

  export type studentWhereUniqueInput = {
    index_no?: number
  }

  export type studentOrderByWithAggregationInput = {
    index_no?: SortOrder
    user_id?: SortOrder
    nic?: SortOrder
    gender?: SortOrder
    initials?: SortOrder
    title?: SortOrder
    general_eng?: SortOrder
    district_no?: SortOrder
    intake?: SortOrder
    reg_no?: SortOrder
    telep_1?: SortOrder
    telep_2?: SortOrder
    address_no?: SortOrder
    address_city?: SortOrder
    address_street?: SortOrder
    address_4?: SortOrder
    student_temp_no?: SortOrder
    district_name?: SortOrder
    name_initial?: SortOrder
    full_name?: SortOrder
    syllabus?: SortOrder
    AL_index_no?: SortOrder
    rank?: SortOrder
    GPA?: SortOrder
    ac_year_ID?: SortOrder
    _count?: studentCountOrderByAggregateInput
    _avg?: studentAvgOrderByAggregateInput
    _max?: studentMaxOrderByAggregateInput
    _min?: studentMinOrderByAggregateInput
    _sum?: studentSumOrderByAggregateInput
  }

  export type studentScalarWhereWithAggregatesInput = {
    AND?: Enumerable<studentScalarWhereWithAggregatesInput>
    OR?: Enumerable<studentScalarWhereWithAggregatesInput>
    NOT?: Enumerable<studentScalarWhereWithAggregatesInput>
    index_no?: IntWithAggregatesFilter | number
    user_id?: IntWithAggregatesFilter | number
    nic?: StringWithAggregatesFilter | string
    gender?: StringWithAggregatesFilter | string
    initials?: StringWithAggregatesFilter | string
    title?: StringWithAggregatesFilter | string
    general_eng?: StringWithAggregatesFilter | string
    district_no?: StringWithAggregatesFilter | string
    intake?: StringWithAggregatesFilter | string
    reg_no?: StringWithAggregatesFilter | string
    telep_1?: StringWithAggregatesFilter | string
    telep_2?: StringWithAggregatesFilter | string
    address_no?: StringWithAggregatesFilter | string
    address_city?: StringWithAggregatesFilter | string
    address_street?: StringWithAggregatesFilter | string
    address_4?: StringWithAggregatesFilter | string
    student_temp_no?: IntWithAggregatesFilter | number
    district_name?: StringWithAggregatesFilter | string
    name_initial?: StringWithAggregatesFilter | string
    full_name?: StringWithAggregatesFilter | string
    syllabus?: StringWithAggregatesFilter | string
    AL_index_no?: IntWithAggregatesFilter | number
    rank?: IntWithAggregatesFilter | number
    GPA?: IntWithAggregatesFilter | number
    ac_year_ID?: IntWithAggregatesFilter | number
  }

  export type subject_reportWhereInput = {
    AND?: Enumerable<subject_reportWhereInput>
    OR?: Enumerable<subject_reportWhereInput>
    NOT?: Enumerable<subject_reportWhereInput>
    subject_id?: IntFilter | number
    no_of_student?: IntFilter | number
    report_id?: IntFilter | number
  }

  export type subject_reportOrderByWithRelationInput = {
    subject_id?: SortOrder
    no_of_student?: SortOrder
    report_id?: SortOrder
  }

  export type subject_reportWhereUniqueInput = {
    subject_id?: number
  }

  export type subject_reportOrderByWithAggregationInput = {
    subject_id?: SortOrder
    no_of_student?: SortOrder
    report_id?: SortOrder
    _count?: subject_reportCountOrderByAggregateInput
    _avg?: subject_reportAvgOrderByAggregateInput
    _max?: subject_reportMaxOrderByAggregateInput
    _min?: subject_reportMinOrderByAggregateInput
    _sum?: subject_reportSumOrderByAggregateInput
  }

  export type subject_reportScalarWhereWithAggregatesInput = {
    AND?: Enumerable<subject_reportScalarWhereWithAggregatesInput>
    OR?: Enumerable<subject_reportScalarWhereWithAggregatesInput>
    NOT?: Enumerable<subject_reportScalarWhereWithAggregatesInput>
    subject_id?: IntWithAggregatesFilter | number
    no_of_student?: IntWithAggregatesFilter | number
    report_id?: IntWithAggregatesFilter | number
  }

  export type system_pagesWhereInput = {
    AND?: Enumerable<system_pagesWhereInput>
    OR?: Enumerable<system_pagesWhereInput>
    NOT?: Enumerable<system_pagesWhereInput>
    page_id?: IntFilter | number
    content?: StringFilter | string
    admin_id?: IntFilter | number
  }

  export type system_pagesOrderByWithRelationInput = {
    page_id?: SortOrder
    content?: SortOrder
    admin_id?: SortOrder
  }

  export type system_pagesWhereUniqueInput = {
    page_id?: number
  }

  export type system_pagesOrderByWithAggregationInput = {
    page_id?: SortOrder
    content?: SortOrder
    admin_id?: SortOrder
    _count?: system_pagesCountOrderByAggregateInput
    _avg?: system_pagesAvgOrderByAggregateInput
    _max?: system_pagesMaxOrderByAggregateInput
    _min?: system_pagesMinOrderByAggregateInput
    _sum?: system_pagesSumOrderByAggregateInput
  }

  export type system_pagesScalarWhereWithAggregatesInput = {
    AND?: Enumerable<system_pagesScalarWhereWithAggregatesInput>
    OR?: Enumerable<system_pagesScalarWhereWithAggregatesInput>
    NOT?: Enumerable<system_pagesScalarWhereWithAggregatesInput>
    page_id?: IntWithAggregatesFilter | number
    content?: StringWithAggregatesFilter | string
    admin_id?: IntWithAggregatesFilter | number
  }

  export type transcriptWhereInput = {
    AND?: Enumerable<transcriptWhereInput>
    OR?: Enumerable<transcriptWhereInput>
    NOT?: Enumerable<transcriptWhereInput>
    transcript_id?: IntFilter | number
    letter_id?: IntFilter | number
  }

  export type transcriptOrderByWithRelationInput = {
    transcript_id?: SortOrder
    letter_id?: SortOrder
  }

  export type transcriptWhereUniqueInput = {
    transcript_id?: number
  }

  export type transcriptOrderByWithAggregationInput = {
    transcript_id?: SortOrder
    letter_id?: SortOrder
    _count?: transcriptCountOrderByAggregateInput
    _avg?: transcriptAvgOrderByAggregateInput
    _max?: transcriptMaxOrderByAggregateInput
    _min?: transcriptMinOrderByAggregateInput
    _sum?: transcriptSumOrderByAggregateInput
  }

  export type transcriptScalarWhereWithAggregatesInput = {
    AND?: Enumerable<transcriptScalarWhereWithAggregatesInput>
    OR?: Enumerable<transcriptScalarWhereWithAggregatesInput>
    NOT?: Enumerable<transcriptScalarWhereWithAggregatesInput>
    transcript_id?: IntWithAggregatesFilter | number
    letter_id?: IntWithAggregatesFilter | number
  }

  export type userWhereInput = {
    AND?: Enumerable<userWhereInput>
    OR?: Enumerable<userWhereInput>
    NOT?: Enumerable<userWhereInput>
    user_id?: IntFilter | number
    user_name?: StringFilter | string
    password?: StringFilter | string
    email?: StringFilter | string
    user_type?: StringFilter | string
    f_name?: StringFilter | string
    l_name?: StringFilter | string
    profile_pic?: StringNullableFilter | string | null
  }

  export type userOrderByWithRelationInput = {
    user_id?: SortOrder
    user_name?: SortOrder
    password?: SortOrder
    email?: SortOrder
    user_type?: SortOrder
    f_name?: SortOrder
    l_name?: SortOrder
    profile_pic?: SortOrder
  }

  export type userWhereUniqueInput = {
    user_id?: number
    user_name?: string
    email?: string
  }

  export type userOrderByWithAggregationInput = {
    user_id?: SortOrder
    user_name?: SortOrder
    password?: SortOrder
    email?: SortOrder
    user_type?: SortOrder
    f_name?: SortOrder
    l_name?: SortOrder
    profile_pic?: SortOrder
    _count?: userCountOrderByAggregateInput
    _avg?: userAvgOrderByAggregateInput
    _max?: userMaxOrderByAggregateInput
    _min?: userMinOrderByAggregateInput
    _sum?: userSumOrderByAggregateInput
  }

  export type userScalarWhereWithAggregatesInput = {
    AND?: Enumerable<userScalarWhereWithAggregatesInput>
    OR?: Enumerable<userScalarWhereWithAggregatesInput>
    NOT?: Enumerable<userScalarWhereWithAggregatesInput>
    user_id?: IntWithAggregatesFilter | number
    user_name?: StringWithAggregatesFilter | string
    password?: StringWithAggregatesFilter | string
    email?: StringWithAggregatesFilter | string
    user_type?: StringWithAggregatesFilter | string
    f_name?: StringWithAggregatesFilter | string
    l_name?: StringWithAggregatesFilter | string
    profile_pic?: StringNullableWithAggregatesFilter | string | null
  }

  export type academic_yearCreateInput = {
    no_of_student: number
    year: number
  }

  export type academic_yearUncheckedCreateInput = {
    ac_year_ID?: number
    no_of_student: number
    year: number
  }

  export type academic_yearUpdateInput = {
    no_of_student?: IntFieldUpdateOperationsInput | number
    year?: IntFieldUpdateOperationsInput | number
  }

  export type academic_yearUncheckedUpdateInput = {
    ac_year_ID?: IntFieldUpdateOperationsInput | number
    no_of_student?: IntFieldUpdateOperationsInput | number
    year?: IntFieldUpdateOperationsInput | number
  }

  export type academic_yearCreateManyInput = {
    ac_year_ID?: number
    no_of_student: number
    year: number
  }

  export type academic_yearUpdateManyMutationInput = {
    no_of_student?: IntFieldUpdateOperationsInput | number
    year?: IntFieldUpdateOperationsInput | number
  }

  export type academic_yearUncheckedUpdateManyInput = {
    ac_year_ID?: IntFieldUpdateOperationsInput | number
    no_of_student?: IntFieldUpdateOperationsInput | number
    year?: IntFieldUpdateOperationsInput | number
  }

  export type admissionCreateInput = {
    exam_hall: string
    course_name: string
    course_code: string
    exan_date: Date | string
    exam_time: Date | string
    attendence_verify: string
  }

  export type admissionUncheckedCreateInput = {
    admission_id?: number
    exam_hall: string
    course_name: string
    course_code: string
    exan_date: Date | string
    exam_time: Date | string
    attendence_verify: string
  }

  export type admissionUpdateInput = {
    exam_hall?: StringFieldUpdateOperationsInput | string
    course_name?: StringFieldUpdateOperationsInput | string
    course_code?: StringFieldUpdateOperationsInput | string
    exan_date?: DateTimeFieldUpdateOperationsInput | Date | string
    exam_time?: DateTimeFieldUpdateOperationsInput | Date | string
    attendence_verify?: StringFieldUpdateOperationsInput | string
  }

  export type admissionUncheckedUpdateInput = {
    admission_id?: IntFieldUpdateOperationsInput | number
    exam_hall?: StringFieldUpdateOperationsInput | string
    course_name?: StringFieldUpdateOperationsInput | string
    course_code?: StringFieldUpdateOperationsInput | string
    exan_date?: DateTimeFieldUpdateOperationsInput | Date | string
    exam_time?: DateTimeFieldUpdateOperationsInput | Date | string
    attendence_verify?: StringFieldUpdateOperationsInput | string
  }

  export type admissionCreateManyInput = {
    admission_id?: number
    exam_hall: string
    course_name: string
    course_code: string
    exan_date: Date | string
    exam_time: Date | string
    attendence_verify: string
  }

  export type admissionUpdateManyMutationInput = {
    exam_hall?: StringFieldUpdateOperationsInput | string
    course_name?: StringFieldUpdateOperationsInput | string
    course_code?: StringFieldUpdateOperationsInput | string
    exan_date?: DateTimeFieldUpdateOperationsInput | Date | string
    exam_time?: DateTimeFieldUpdateOperationsInput | Date | string
    attendence_verify?: StringFieldUpdateOperationsInput | string
  }

  export type admissionUncheckedUpdateManyInput = {
    admission_id?: IntFieldUpdateOperationsInput | number
    exam_hall?: StringFieldUpdateOperationsInput | string
    course_name?: StringFieldUpdateOperationsInput | string
    course_code?: StringFieldUpdateOperationsInput | string
    exan_date?: DateTimeFieldUpdateOperationsInput | Date | string
    exam_time?: DateTimeFieldUpdateOperationsInput | Date | string
    attendence_verify?: StringFieldUpdateOperationsInput | string
  }

  export type announcementCreateInput = {
    content: string
    admin_id: number
  }

  export type announcementUncheckedCreateInput = {
    annou_id?: number
    content: string
    admin_id: number
  }

  export type announcementUpdateInput = {
    content?: StringFieldUpdateOperationsInput | string
    admin_id?: IntFieldUpdateOperationsInput | number
  }

  export type announcementUncheckedUpdateInput = {
    annou_id?: IntFieldUpdateOperationsInput | number
    content?: StringFieldUpdateOperationsInput | string
    admin_id?: IntFieldUpdateOperationsInput | number
  }

  export type announcementCreateManyInput = {
    annou_id?: number
    content: string
    admin_id: number
  }

  export type announcementUpdateManyMutationInput = {
    content?: StringFieldUpdateOperationsInput | string
    admin_id?: IntFieldUpdateOperationsInput | number
  }

  export type announcementUncheckedUpdateManyInput = {
    annou_id?: IntFieldUpdateOperationsInput | number
    content?: StringFieldUpdateOperationsInput | string
    admin_id?: IntFieldUpdateOperationsInput | number
  }

  export type assign_marksCreateInput = {
    sub_marks: number
    total_marks: number
    assign_precentage: number
    mark_id: number
  }

  export type assign_marksUncheckedCreateInput = {
    assigment_id?: number
    sub_marks: number
    total_marks: number
    assign_precentage: number
    mark_id: number
  }

  export type assign_marksUpdateInput = {
    sub_marks?: IntFieldUpdateOperationsInput | number
    total_marks?: IntFieldUpdateOperationsInput | number
    assign_precentage?: IntFieldUpdateOperationsInput | number
    mark_id?: IntFieldUpdateOperationsInput | number
  }

  export type assign_marksUncheckedUpdateInput = {
    assigment_id?: IntFieldUpdateOperationsInput | number
    sub_marks?: IntFieldUpdateOperationsInput | number
    total_marks?: IntFieldUpdateOperationsInput | number
    assign_precentage?: IntFieldUpdateOperationsInput | number
    mark_id?: IntFieldUpdateOperationsInput | number
  }

  export type assign_marksCreateManyInput = {
    assigment_id?: number
    sub_marks: number
    total_marks: number
    assign_precentage: number
    mark_id: number
  }

  export type assign_marksUpdateManyMutationInput = {
    sub_marks?: IntFieldUpdateOperationsInput | number
    total_marks?: IntFieldUpdateOperationsInput | number
    assign_precentage?: IntFieldUpdateOperationsInput | number
    mark_id?: IntFieldUpdateOperationsInput | number
  }

  export type assign_marksUncheckedUpdateManyInput = {
    assigment_id?: IntFieldUpdateOperationsInput | number
    sub_marks?: IntFieldUpdateOperationsInput | number
    total_marks?: IntFieldUpdateOperationsInput | number
    assign_precentage?: IntFieldUpdateOperationsInput | number
    mark_id?: IntFieldUpdateOperationsInput | number
  }

  export type assignmentsCreateInput = {
    name: string
    description: string
    contribution: number
    lecturer_id: number
    course_id: number
  }

  export type assignmentsUncheckedCreateInput = {
    assignment_id?: number
    name: string
    description: string
    contribution: number
    lecturer_id: number
    course_id: number
  }

  export type assignmentsUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    contribution?: IntFieldUpdateOperationsInput | number
    lecturer_id?: IntFieldUpdateOperationsInput | number
    course_id?: IntFieldUpdateOperationsInput | number
  }

  export type assignmentsUncheckedUpdateInput = {
    assignment_id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    contribution?: IntFieldUpdateOperationsInput | number
    lecturer_id?: IntFieldUpdateOperationsInput | number
    course_id?: IntFieldUpdateOperationsInput | number
  }

  export type assignmentsCreateManyInput = {
    assignment_id?: number
    name: string
    description: string
    contribution: number
    lecturer_id: number
    course_id: number
  }

  export type assignmentsUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    contribution?: IntFieldUpdateOperationsInput | number
    lecturer_id?: IntFieldUpdateOperationsInput | number
    course_id?: IntFieldUpdateOperationsInput | number
  }

  export type assignmentsUncheckedUpdateManyInput = {
    assignment_id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    contribution?: IntFieldUpdateOperationsInput | number
    lecturer_id?: IntFieldUpdateOperationsInput | number
    course_id?: IntFieldUpdateOperationsInput | number
  }

  export type confirmCreateInput = {
    letter_id: number
  }

  export type confirmUncheckedCreateInput = {
    confirm_id?: number
    letter_id: number
  }

  export type confirmUpdateInput = {
    letter_id?: IntFieldUpdateOperationsInput | number
  }

  export type confirmUncheckedUpdateInput = {
    confirm_id?: IntFieldUpdateOperationsInput | number
    letter_id?: IntFieldUpdateOperationsInput | number
  }

  export type confirmCreateManyInput = {
    confirm_id?: number
    letter_id: number
  }

  export type confirmUpdateManyMutationInput = {
    letter_id?: IntFieldUpdateOperationsInput | number
  }

  export type confirmUncheckedUpdateManyInput = {
    confirm_id?: IntFieldUpdateOperationsInput | number
    letter_id?: IntFieldUpdateOperationsInput | number
  }

  export type courseCreateInput = {
    year: number
    semester: string
    course_name: string
    course_code: string
    lecture_name: string
    ac_year_ID: number
  }

  export type courseUncheckedCreateInput = {
    course_id?: number
    year: number
    semester: string
    course_name: string
    course_code: string
    lecture_name: string
    ac_year_ID: number
  }

  export type courseUpdateInput = {
    year?: IntFieldUpdateOperationsInput | number
    semester?: StringFieldUpdateOperationsInput | string
    course_name?: StringFieldUpdateOperationsInput | string
    course_code?: StringFieldUpdateOperationsInput | string
    lecture_name?: StringFieldUpdateOperationsInput | string
    ac_year_ID?: IntFieldUpdateOperationsInput | number
  }

  export type courseUncheckedUpdateInput = {
    course_id?: IntFieldUpdateOperationsInput | number
    year?: IntFieldUpdateOperationsInput | number
    semester?: StringFieldUpdateOperationsInput | string
    course_name?: StringFieldUpdateOperationsInput | string
    course_code?: StringFieldUpdateOperationsInput | string
    lecture_name?: StringFieldUpdateOperationsInput | string
    ac_year_ID?: IntFieldUpdateOperationsInput | number
  }

  export type courseCreateManyInput = {
    course_id?: number
    year: number
    semester: string
    course_name: string
    course_code: string
    lecture_name: string
    ac_year_ID: number
  }

  export type courseUpdateManyMutationInput = {
    year?: IntFieldUpdateOperationsInput | number
    semester?: StringFieldUpdateOperationsInput | string
    course_name?: StringFieldUpdateOperationsInput | string
    course_code?: StringFieldUpdateOperationsInput | string
    lecture_name?: StringFieldUpdateOperationsInput | string
    ac_year_ID?: IntFieldUpdateOperationsInput | number
  }

  export type courseUncheckedUpdateManyInput = {
    course_id?: IntFieldUpdateOperationsInput | number
    year?: IntFieldUpdateOperationsInput | number
    semester?: StringFieldUpdateOperationsInput | string
    course_name?: StringFieldUpdateOperationsInput | string
    course_code?: StringFieldUpdateOperationsInput | string
    lecture_name?: StringFieldUpdateOperationsInput | string
    ac_year_ID?: IntFieldUpdateOperationsInput | number
  }

  export type directorCreateInput = {
    user_id: number
  }

  export type directorUncheckedCreateInput = {
    director_id?: number
    user_id: number
  }

  export type directorUpdateInput = {
    user_id?: IntFieldUpdateOperationsInput | number
  }

  export type directorUncheckedUpdateInput = {
    director_id?: IntFieldUpdateOperationsInput | number
    user_id?: IntFieldUpdateOperationsInput | number
  }

  export type directorCreateManyInput = {
    director_id?: number
    user_id: number
  }

  export type directorUpdateManyMutationInput = {
    user_id?: IntFieldUpdateOperationsInput | number
  }

  export type directorUncheckedUpdateManyInput = {
    director_id?: IntFieldUpdateOperationsInput | number
    user_id?: IntFieldUpdateOperationsInput | number
  }

  export type examCreateInput = {
    semester: number
    year: number
  }

  export type examUncheckedCreateInput = {
    exam_sem_id?: number
    semester: number
    year: number
  }

  export type examUpdateInput = {
    semester?: IntFieldUpdateOperationsInput | number
    year?: IntFieldUpdateOperationsInput | number
  }

  export type examUncheckedUpdateInput = {
    exam_sem_id?: IntFieldUpdateOperationsInput | number
    semester?: IntFieldUpdateOperationsInput | number
    year?: IntFieldUpdateOperationsInput | number
  }

  export type examCreateManyInput = {
    exam_sem_id?: number
    semester: number
    year: number
  }

  export type examUpdateManyMutationInput = {
    semester?: IntFieldUpdateOperationsInput | number
    year?: IntFieldUpdateOperationsInput | number
  }

  export type examUncheckedUpdateManyInput = {
    exam_sem_id?: IntFieldUpdateOperationsInput | number
    semester?: IntFieldUpdateOperationsInput | number
    year?: IntFieldUpdateOperationsInput | number
  }

  export type exam_markCreateInput = {
    course_code: string
    course_name: string
    grade: string
    total_mark: number
    director_status: string
    head_of_exam_status: string
    exam_sem_id: number
    director_id: number
    head_of_exam_id: number
    index_no: number
  }

  export type exam_markUncheckedCreateInput = {
    mark_id?: number
    course_code: string
    course_name: string
    grade: string
    total_mark: number
    director_status: string
    head_of_exam_status: string
    exam_sem_id: number
    director_id: number
    head_of_exam_id: number
    index_no: number
  }

  export type exam_markUpdateInput = {
    course_code?: StringFieldUpdateOperationsInput | string
    course_name?: StringFieldUpdateOperationsInput | string
    grade?: StringFieldUpdateOperationsInput | string
    total_mark?: IntFieldUpdateOperationsInput | number
    director_status?: StringFieldUpdateOperationsInput | string
    head_of_exam_status?: StringFieldUpdateOperationsInput | string
    exam_sem_id?: IntFieldUpdateOperationsInput | number
    director_id?: IntFieldUpdateOperationsInput | number
    head_of_exam_id?: IntFieldUpdateOperationsInput | number
    index_no?: IntFieldUpdateOperationsInput | number
  }

  export type exam_markUncheckedUpdateInput = {
    mark_id?: IntFieldUpdateOperationsInput | number
    course_code?: StringFieldUpdateOperationsInput | string
    course_name?: StringFieldUpdateOperationsInput | string
    grade?: StringFieldUpdateOperationsInput | string
    total_mark?: IntFieldUpdateOperationsInput | number
    director_status?: StringFieldUpdateOperationsInput | string
    head_of_exam_status?: StringFieldUpdateOperationsInput | string
    exam_sem_id?: IntFieldUpdateOperationsInput | number
    director_id?: IntFieldUpdateOperationsInput | number
    head_of_exam_id?: IntFieldUpdateOperationsInput | number
    index_no?: IntFieldUpdateOperationsInput | number
  }

  export type exam_markCreateManyInput = {
    mark_id?: number
    course_code: string
    course_name: string
    grade: string
    total_mark: number
    director_status: string
    head_of_exam_status: string
    exam_sem_id: number
    director_id: number
    head_of_exam_id: number
    index_no: number
  }

  export type exam_markUpdateManyMutationInput = {
    course_code?: StringFieldUpdateOperationsInput | string
    course_name?: StringFieldUpdateOperationsInput | string
    grade?: StringFieldUpdateOperationsInput | string
    total_mark?: IntFieldUpdateOperationsInput | number
    director_status?: StringFieldUpdateOperationsInput | string
    head_of_exam_status?: StringFieldUpdateOperationsInput | string
    exam_sem_id?: IntFieldUpdateOperationsInput | number
    director_id?: IntFieldUpdateOperationsInput | number
    head_of_exam_id?: IntFieldUpdateOperationsInput | number
    index_no?: IntFieldUpdateOperationsInput | number
  }

  export type exam_markUncheckedUpdateManyInput = {
    mark_id?: IntFieldUpdateOperationsInput | number
    course_code?: StringFieldUpdateOperationsInput | string
    course_name?: StringFieldUpdateOperationsInput | string
    grade?: StringFieldUpdateOperationsInput | string
    total_mark?: IntFieldUpdateOperationsInput | number
    director_status?: StringFieldUpdateOperationsInput | string
    head_of_exam_status?: StringFieldUpdateOperationsInput | string
    exam_sem_id?: IntFieldUpdateOperationsInput | number
    director_id?: IntFieldUpdateOperationsInput | number
    head_of_exam_id?: IntFieldUpdateOperationsInput | number
    index_no?: IntFieldUpdateOperationsInput | number
  }

  export type exam_timetableCreateInput = {
    exam_date: Date | string
    exam_time: Date | string
    course_code: string
    course_name: string
    exam_sem_id: number
  }

  export type exam_timetableUncheckedCreateInput = {
    timetable_id?: number
    exam_date: Date | string
    exam_time: Date | string
    course_code: string
    course_name: string
    exam_sem_id: number
  }

  export type exam_timetableUpdateInput = {
    exam_date?: DateTimeFieldUpdateOperationsInput | Date | string
    exam_time?: DateTimeFieldUpdateOperationsInput | Date | string
    course_code?: StringFieldUpdateOperationsInput | string
    course_name?: StringFieldUpdateOperationsInput | string
    exam_sem_id?: IntFieldUpdateOperationsInput | number
  }

  export type exam_timetableUncheckedUpdateInput = {
    timetable_id?: IntFieldUpdateOperationsInput | number
    exam_date?: DateTimeFieldUpdateOperationsInput | Date | string
    exam_time?: DateTimeFieldUpdateOperationsInput | Date | string
    course_code?: StringFieldUpdateOperationsInput | string
    course_name?: StringFieldUpdateOperationsInput | string
    exam_sem_id?: IntFieldUpdateOperationsInput | number
  }

  export type exam_timetableCreateManyInput = {
    timetable_id?: number
    exam_date: Date | string
    exam_time: Date | string
    course_code: string
    course_name: string
    exam_sem_id: number
  }

  export type exam_timetableUpdateManyMutationInput = {
    exam_date?: DateTimeFieldUpdateOperationsInput | Date | string
    exam_time?: DateTimeFieldUpdateOperationsInput | Date | string
    course_code?: StringFieldUpdateOperationsInput | string
    course_name?: StringFieldUpdateOperationsInput | string
    exam_sem_id?: IntFieldUpdateOperationsInput | number
  }

  export type exam_timetableUncheckedUpdateManyInput = {
    timetable_id?: IntFieldUpdateOperationsInput | number
    exam_date?: DateTimeFieldUpdateOperationsInput | Date | string
    exam_time?: DateTimeFieldUpdateOperationsInput | Date | string
    course_code?: StringFieldUpdateOperationsInput | string
    course_name?: StringFieldUpdateOperationsInput | string
    exam_sem_id?: IntFieldUpdateOperationsInput | number
  }

  export type head_of_exam_boardCreateInput = {
    user_id: number
    staff_id: number
  }

  export type head_of_exam_boardUncheckedCreateInput = {
    head_of_exam_ID?: number
    user_id: number
    staff_id: number
  }

  export type head_of_exam_boardUpdateInput = {
    user_id?: IntFieldUpdateOperationsInput | number
    staff_id?: IntFieldUpdateOperationsInput | number
  }

  export type head_of_exam_boardUncheckedUpdateInput = {
    head_of_exam_ID?: IntFieldUpdateOperationsInput | number
    user_id?: IntFieldUpdateOperationsInput | number
    staff_id?: IntFieldUpdateOperationsInput | number
  }

  export type head_of_exam_boardCreateManyInput = {
    head_of_exam_ID?: number
    user_id: number
    staff_id: number
  }

  export type head_of_exam_boardUpdateManyMutationInput = {
    user_id?: IntFieldUpdateOperationsInput | number
    staff_id?: IntFieldUpdateOperationsInput | number
  }

  export type head_of_exam_boardUncheckedUpdateManyInput = {
    head_of_exam_ID?: IntFieldUpdateOperationsInput | number
    user_id?: IntFieldUpdateOperationsInput | number
    staff_id?: IntFieldUpdateOperationsInput | number
  }

  export type lecture_questionCreateInput = {
    exam_paper_id: number
    lecture_id: number
  }

  export type lecture_questionUncheckedCreateInput = {
    exam_paper_id: number
    lecture_id: number
  }

  export type lecture_questionUpdateInput = {
    exam_paper_id?: IntFieldUpdateOperationsInput | number
    lecture_id?: IntFieldUpdateOperationsInput | number
  }

  export type lecture_questionUncheckedUpdateInput = {
    exam_paper_id?: IntFieldUpdateOperationsInput | number
    lecture_id?: IntFieldUpdateOperationsInput | number
  }

  export type lecture_questionCreateManyInput = {
    exam_paper_id: number
    lecture_id: number
  }

  export type lecture_questionUpdateManyMutationInput = {
    exam_paper_id?: IntFieldUpdateOperationsInput | number
    lecture_id?: IntFieldUpdateOperationsInput | number
  }

  export type lecture_questionUncheckedUpdateManyInput = {
    exam_paper_id?: IntFieldUpdateOperationsInput | number
    lecture_id?: IntFieldUpdateOperationsInput | number
  }

  export type lecturerCreateInput = {
    degree: string
    user_id: number
  }

  export type lecturerUncheckedCreateInput = {
    lecturer_id?: number
    degree: string
    user_id: number
  }

  export type lecturerUpdateInput = {
    degree?: StringFieldUpdateOperationsInput | string
    user_id?: IntFieldUpdateOperationsInput | number
  }

  export type lecturerUncheckedUpdateInput = {
    lecturer_id?: IntFieldUpdateOperationsInput | number
    degree?: StringFieldUpdateOperationsInput | string
    user_id?: IntFieldUpdateOperationsInput | number
  }

  export type lecturerCreateManyInput = {
    lecturer_id?: number
    degree: string
    user_id: number
  }

  export type lecturerUpdateManyMutationInput = {
    degree?: StringFieldUpdateOperationsInput | string
    user_id?: IntFieldUpdateOperationsInput | number
  }

  export type lecturerUncheckedUpdateManyInput = {
    lecturer_id?: IntFieldUpdateOperationsInput | number
    degree?: StringFieldUpdateOperationsInput | string
    user_id?: IntFieldUpdateOperationsInput | number
  }

  export type lecturer_coursesCreateInput = {
    user_id: number
    course_id: number
  }

  export type lecturer_coursesUncheckedCreateInput = {
    user_id: number
    course_id: number
  }

  export type lecturer_coursesUpdateInput = {
    user_id?: IntFieldUpdateOperationsInput | number
    course_id?: IntFieldUpdateOperationsInput | number
  }

  export type lecturer_coursesUncheckedUpdateInput = {
    user_id?: IntFieldUpdateOperationsInput | number
    course_id?: IntFieldUpdateOperationsInput | number
  }

  export type lecturer_coursesCreateManyInput = {
    user_id: number
    course_id: number
  }

  export type lecturer_coursesUpdateManyMutationInput = {
    user_id?: IntFieldUpdateOperationsInput | number
    course_id?: IntFieldUpdateOperationsInput | number
  }

  export type lecturer_coursesUncheckedUpdateManyInput = {
    user_id?: IntFieldUpdateOperationsInput | number
    course_id?: IntFieldUpdateOperationsInput | number
  }

  export type letterCreateInput = {
    email: string
    another_email: string
    final_quali: string
    id_no: string
    duration: number
    degree_status: string
    study_year: number
    index_no: number
    reg_no: string
    degree_prog: string
    address: string
    contact_no: string
    another_cont_no: string
    payment_voucher: string
  }

  export type letterUncheckedCreateInput = {
    letter_id?: number
    email: string
    another_email: string
    final_quali: string
    id_no: string
    duration: number
    degree_status: string
    study_year: number
    index_no: number
    reg_no: string
    degree_prog: string
    address: string
    contact_no: string
    another_cont_no: string
    payment_voucher: string
  }

  export type letterUpdateInput = {
    email?: StringFieldUpdateOperationsInput | string
    another_email?: StringFieldUpdateOperationsInput | string
    final_quali?: StringFieldUpdateOperationsInput | string
    id_no?: StringFieldUpdateOperationsInput | string
    duration?: IntFieldUpdateOperationsInput | number
    degree_status?: StringFieldUpdateOperationsInput | string
    study_year?: IntFieldUpdateOperationsInput | number
    index_no?: IntFieldUpdateOperationsInput | number
    reg_no?: StringFieldUpdateOperationsInput | string
    degree_prog?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    contact_no?: StringFieldUpdateOperationsInput | string
    another_cont_no?: StringFieldUpdateOperationsInput | string
    payment_voucher?: StringFieldUpdateOperationsInput | string
  }

  export type letterUncheckedUpdateInput = {
    letter_id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    another_email?: StringFieldUpdateOperationsInput | string
    final_quali?: StringFieldUpdateOperationsInput | string
    id_no?: StringFieldUpdateOperationsInput | string
    duration?: IntFieldUpdateOperationsInput | number
    degree_status?: StringFieldUpdateOperationsInput | string
    study_year?: IntFieldUpdateOperationsInput | number
    index_no?: IntFieldUpdateOperationsInput | number
    reg_no?: StringFieldUpdateOperationsInput | string
    degree_prog?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    contact_no?: StringFieldUpdateOperationsInput | string
    another_cont_no?: StringFieldUpdateOperationsInput | string
    payment_voucher?: StringFieldUpdateOperationsInput | string
  }

  export type letterCreateManyInput = {
    letter_id?: number
    email: string
    another_email: string
    final_quali: string
    id_no: string
    duration: number
    degree_status: string
    study_year: number
    index_no: number
    reg_no: string
    degree_prog: string
    address: string
    contact_no: string
    another_cont_no: string
    payment_voucher: string
  }

  export type letterUpdateManyMutationInput = {
    email?: StringFieldUpdateOperationsInput | string
    another_email?: StringFieldUpdateOperationsInput | string
    final_quali?: StringFieldUpdateOperationsInput | string
    id_no?: StringFieldUpdateOperationsInput | string
    duration?: IntFieldUpdateOperationsInput | number
    degree_status?: StringFieldUpdateOperationsInput | string
    study_year?: IntFieldUpdateOperationsInput | number
    index_no?: IntFieldUpdateOperationsInput | number
    reg_no?: StringFieldUpdateOperationsInput | string
    degree_prog?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    contact_no?: StringFieldUpdateOperationsInput | string
    another_cont_no?: StringFieldUpdateOperationsInput | string
    payment_voucher?: StringFieldUpdateOperationsInput | string
  }

  export type letterUncheckedUpdateManyInput = {
    letter_id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    another_email?: StringFieldUpdateOperationsInput | string
    final_quali?: StringFieldUpdateOperationsInput | string
    id_no?: StringFieldUpdateOperationsInput | string
    duration?: IntFieldUpdateOperationsInput | number
    degree_status?: StringFieldUpdateOperationsInput | string
    study_year?: IntFieldUpdateOperationsInput | number
    index_no?: IntFieldUpdateOperationsInput | number
    reg_no?: StringFieldUpdateOperationsInput | string
    degree_prog?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    contact_no?: StringFieldUpdateOperationsInput | string
    another_cont_no?: StringFieldUpdateOperationsInput | string
    payment_voucher?: StringFieldUpdateOperationsInput | string
  }

  export type maCreateInput = {
    user_id: number
    staff_id: number
    office_id: string
    letter_id: number
  }

  export type maUncheckedCreateInput = {
    MA_id?: number
    user_id: number
    staff_id: number
    office_id: string
    letter_id: number
  }

  export type maUpdateInput = {
    user_id?: IntFieldUpdateOperationsInput | number
    staff_id?: IntFieldUpdateOperationsInput | number
    office_id?: StringFieldUpdateOperationsInput | string
    letter_id?: IntFieldUpdateOperationsInput | number
  }

  export type maUncheckedUpdateInput = {
    MA_id?: IntFieldUpdateOperationsInput | number
    user_id?: IntFieldUpdateOperationsInput | number
    staff_id?: IntFieldUpdateOperationsInput | number
    office_id?: StringFieldUpdateOperationsInput | string
    letter_id?: IntFieldUpdateOperationsInput | number
  }

  export type maCreateManyInput = {
    MA_id?: number
    user_id: number
    staff_id: number
    office_id: string
    letter_id: number
  }

  export type maUpdateManyMutationInput = {
    user_id?: IntFieldUpdateOperationsInput | number
    staff_id?: IntFieldUpdateOperationsInput | number
    office_id?: StringFieldUpdateOperationsInput | string
    letter_id?: IntFieldUpdateOperationsInput | number
  }

  export type maUncheckedUpdateManyInput = {
    MA_id?: IntFieldUpdateOperationsInput | number
    user_id?: IntFieldUpdateOperationsInput | number
    staff_id?: IntFieldUpdateOperationsInput | number
    office_id?: StringFieldUpdateOperationsInput | string
    letter_id?: IntFieldUpdateOperationsInput | number
  }

  export type mis_reportCreateInput = {
    report_id: number
  }

  export type mis_reportUncheckedCreateInput = {
    mis_id?: number
    report_id: number
  }

  export type mis_reportUpdateInput = {
    report_id?: IntFieldUpdateOperationsInput | number
  }

  export type mis_reportUncheckedUpdateInput = {
    mis_id?: IntFieldUpdateOperationsInput | number
    report_id?: IntFieldUpdateOperationsInput | number
  }

  export type mis_reportCreateManyInput = {
    mis_id?: number
    report_id: number
  }

  export type mis_reportUpdateManyMutationInput = {
    report_id?: IntFieldUpdateOperationsInput | number
  }

  export type mis_reportUncheckedUpdateManyInput = {
    mis_id?: IntFieldUpdateOperationsInput | number
    report_id?: IntFieldUpdateOperationsInput | number
  }

  export type paper_marksCreateInput = {
    sub_marks: number
    total_marks: number
    paper_precentage: number
    mark_id: number
  }

  export type paper_marksUncheckedCreateInput = {
    paper_id?: number
    sub_marks: number
    total_marks: number
    paper_precentage: number
    mark_id: number
  }

  export type paper_marksUpdateInput = {
    sub_marks?: IntFieldUpdateOperationsInput | number
    total_marks?: IntFieldUpdateOperationsInput | number
    paper_precentage?: IntFieldUpdateOperationsInput | number
    mark_id?: IntFieldUpdateOperationsInput | number
  }

  export type paper_marksUncheckedUpdateInput = {
    paper_id?: IntFieldUpdateOperationsInput | number
    sub_marks?: IntFieldUpdateOperationsInput | number
    total_marks?: IntFieldUpdateOperationsInput | number
    paper_precentage?: IntFieldUpdateOperationsInput | number
    mark_id?: IntFieldUpdateOperationsInput | number
  }

  export type paper_marksCreateManyInput = {
    paper_id?: number
    sub_marks: number
    total_marks: number
    paper_precentage: number
    mark_id: number
  }

  export type paper_marksUpdateManyMutationInput = {
    sub_marks?: IntFieldUpdateOperationsInput | number
    total_marks?: IntFieldUpdateOperationsInput | number
    paper_precentage?: IntFieldUpdateOperationsInput | number
    mark_id?: IntFieldUpdateOperationsInput | number
  }

  export type paper_marksUncheckedUpdateManyInput = {
    paper_id?: IntFieldUpdateOperationsInput | number
    sub_marks?: IntFieldUpdateOperationsInput | number
    total_marks?: IntFieldUpdateOperationsInput | number
    paper_precentage?: IntFieldUpdateOperationsInput | number
    mark_id?: IntFieldUpdateOperationsInput | number
  }

  export type paper_questionCreateInput = {
    course_code: string
    course_name: string
    question_no: number
    exam_sem_id: number
  }

  export type paper_questionUncheckedCreateInput = {
    exam_paper_id?: number
    course_code: string
    course_name: string
    question_no: number
    exam_sem_id: number
  }

  export type paper_questionUpdateInput = {
    course_code?: StringFieldUpdateOperationsInput | string
    course_name?: StringFieldUpdateOperationsInput | string
    question_no?: IntFieldUpdateOperationsInput | number
    exam_sem_id?: IntFieldUpdateOperationsInput | number
  }

  export type paper_questionUncheckedUpdateInput = {
    exam_paper_id?: IntFieldUpdateOperationsInput | number
    course_code?: StringFieldUpdateOperationsInput | string
    course_name?: StringFieldUpdateOperationsInput | string
    question_no?: IntFieldUpdateOperationsInput | number
    exam_sem_id?: IntFieldUpdateOperationsInput | number
  }

  export type paper_questionCreateManyInput = {
    exam_paper_id?: number
    course_code: string
    course_name: string
    question_no: number
    exam_sem_id: number
  }

  export type paper_questionUpdateManyMutationInput = {
    course_code?: StringFieldUpdateOperationsInput | string
    course_name?: StringFieldUpdateOperationsInput | string
    question_no?: IntFieldUpdateOperationsInput | number
    exam_sem_id?: IntFieldUpdateOperationsInput | number
  }

  export type paper_questionUncheckedUpdateManyInput = {
    exam_paper_id?: IntFieldUpdateOperationsInput | number
    course_code?: StringFieldUpdateOperationsInput | string
    course_name?: StringFieldUpdateOperationsInput | string
    question_no?: IntFieldUpdateOperationsInput | number
    exam_sem_id?: IntFieldUpdateOperationsInput | number
  }

  export type paymentCreateInput = {
    payment_date: Date | string
    amount: number
    status: string
    index_no: number
    ac_year_ID: number
  }

  export type paymentUncheckedCreateInput = {
    payment_id?: number
    payment_date: Date | string
    amount: number
    status: string
    index_no: number
    ac_year_ID: number
  }

  export type paymentUpdateInput = {
    payment_date?: DateTimeFieldUpdateOperationsInput | Date | string
    amount?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    index_no?: IntFieldUpdateOperationsInput | number
    ac_year_ID?: IntFieldUpdateOperationsInput | number
  }

  export type paymentUncheckedUpdateInput = {
    payment_id?: IntFieldUpdateOperationsInput | number
    payment_date?: DateTimeFieldUpdateOperationsInput | Date | string
    amount?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    index_no?: IntFieldUpdateOperationsInput | number
    ac_year_ID?: IntFieldUpdateOperationsInput | number
  }

  export type paymentCreateManyInput = {
    payment_id?: number
    payment_date: Date | string
    amount: number
    status: string
    index_no: number
    ac_year_ID: number
  }

  export type paymentUpdateManyMutationInput = {
    payment_date?: DateTimeFieldUpdateOperationsInput | Date | string
    amount?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    index_no?: IntFieldUpdateOperationsInput | number
    ac_year_ID?: IntFieldUpdateOperationsInput | number
  }

  export type paymentUncheckedUpdateManyInput = {
    payment_id?: IntFieldUpdateOperationsInput | number
    payment_date?: DateTimeFieldUpdateOperationsInput | Date | string
    amount?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    index_no?: IntFieldUpdateOperationsInput | number
    ac_year_ID?: IntFieldUpdateOperationsInput | number
  }

  export type repeat_courseCreateInput = {
    course_code: string
    course_name: string
    year: number
    semester: string
  }

  export type repeat_courseUncheckedCreateInput = {
    rc_id?: number
    course_code: string
    course_name: string
    year: number
    semester: string
  }

  export type repeat_courseUpdateInput = {
    course_code?: StringFieldUpdateOperationsInput | string
    course_name?: StringFieldUpdateOperationsInput | string
    year?: IntFieldUpdateOperationsInput | number
    semester?: StringFieldUpdateOperationsInput | string
  }

  export type repeat_courseUncheckedUpdateInput = {
    rc_id?: IntFieldUpdateOperationsInput | number
    course_code?: StringFieldUpdateOperationsInput | string
    course_name?: StringFieldUpdateOperationsInput | string
    year?: IntFieldUpdateOperationsInput | number
    semester?: StringFieldUpdateOperationsInput | string
  }

  export type repeat_courseCreateManyInput = {
    rc_id?: number
    course_code: string
    course_name: string
    year: number
    semester: string
  }

  export type repeat_courseUpdateManyMutationInput = {
    course_code?: StringFieldUpdateOperationsInput | string
    course_name?: StringFieldUpdateOperationsInput | string
    year?: IntFieldUpdateOperationsInput | number
    semester?: StringFieldUpdateOperationsInput | string
  }

  export type repeat_courseUncheckedUpdateManyInput = {
    rc_id?: IntFieldUpdateOperationsInput | number
    course_code?: StringFieldUpdateOperationsInput | string
    course_name?: StringFieldUpdateOperationsInput | string
    year?: IntFieldUpdateOperationsInput | number
    semester?: StringFieldUpdateOperationsInput | string
  }

  export type reportCreateInput = {
    course_name: string
    course_code: string
    year: number
    semester: string
    exam_sem_id: number
  }

  export type reportUncheckedCreateInput = {
    report_id?: number
    course_name: string
    course_code: string
    year: number
    semester: string
    exam_sem_id: number
  }

  export type reportUpdateInput = {
    course_name?: StringFieldUpdateOperationsInput | string
    course_code?: StringFieldUpdateOperationsInput | string
    year?: IntFieldUpdateOperationsInput | number
    semester?: StringFieldUpdateOperationsInput | string
    exam_sem_id?: IntFieldUpdateOperationsInput | number
  }

  export type reportUncheckedUpdateInput = {
    report_id?: IntFieldUpdateOperationsInput | number
    course_name?: StringFieldUpdateOperationsInput | string
    course_code?: StringFieldUpdateOperationsInput | string
    year?: IntFieldUpdateOperationsInput | number
    semester?: StringFieldUpdateOperationsInput | string
    exam_sem_id?: IntFieldUpdateOperationsInput | number
  }

  export type reportCreateManyInput = {
    report_id?: number
    course_name: string
    course_code: string
    year: number
    semester: string
    exam_sem_id: number
  }

  export type reportUpdateManyMutationInput = {
    course_name?: StringFieldUpdateOperationsInput | string
    course_code?: StringFieldUpdateOperationsInput | string
    year?: IntFieldUpdateOperationsInput | number
    semester?: StringFieldUpdateOperationsInput | string
    exam_sem_id?: IntFieldUpdateOperationsInput | number
  }

  export type reportUncheckedUpdateManyInput = {
    report_id?: IntFieldUpdateOperationsInput | number
    course_name?: StringFieldUpdateOperationsInput | string
    course_code?: StringFieldUpdateOperationsInput | string
    year?: IntFieldUpdateOperationsInput | number
    semester?: StringFieldUpdateOperationsInput | string
    exam_sem_id?: IntFieldUpdateOperationsInput | number
  }

  export type sarCreateInput = {
    user_id: number
    staff_id: number
    office_id: number
  }

  export type sarUncheckedCreateInput = {
    SAR_id?: number
    user_id: number
    staff_id: number
    office_id: number
  }

  export type sarUpdateInput = {
    user_id?: IntFieldUpdateOperationsInput | number
    staff_id?: IntFieldUpdateOperationsInput | number
    office_id?: IntFieldUpdateOperationsInput | number
  }

  export type sarUncheckedUpdateInput = {
    SAR_id?: IntFieldUpdateOperationsInput | number
    user_id?: IntFieldUpdateOperationsInput | number
    staff_id?: IntFieldUpdateOperationsInput | number
    office_id?: IntFieldUpdateOperationsInput | number
  }

  export type sarCreateManyInput = {
    SAR_id?: number
    user_id: number
    staff_id: number
    office_id: number
  }

  export type sarUpdateManyMutationInput = {
    user_id?: IntFieldUpdateOperationsInput | number
    staff_id?: IntFieldUpdateOperationsInput | number
    office_id?: IntFieldUpdateOperationsInput | number
  }

  export type sarUncheckedUpdateManyInput = {
    SAR_id?: IntFieldUpdateOperationsInput | number
    user_id?: IntFieldUpdateOperationsInput | number
    staff_id?: IntFieldUpdateOperationsInput | number
    office_id?: IntFieldUpdateOperationsInput | number
  }

  export type staffCreateInput = {
    user_id: number
  }

  export type staffUncheckedCreateInput = {
    staff_id?: number
    user_id: number
  }

  export type staffUpdateInput = {
    user_id?: IntFieldUpdateOperationsInput | number
  }

  export type staffUncheckedUpdateInput = {
    staff_id?: IntFieldUpdateOperationsInput | number
    user_id?: IntFieldUpdateOperationsInput | number
  }

  export type staffCreateManyInput = {
    staff_id?: number
    user_id: number
  }

  export type staffUpdateManyMutationInput = {
    user_id?: IntFieldUpdateOperationsInput | number
  }

  export type staffUncheckedUpdateManyInput = {
    staff_id?: IntFieldUpdateOperationsInput | number
    user_id?: IntFieldUpdateOperationsInput | number
  }

  export type studentCreateInput = {
    user_id: number
    nic: string
    gender: string
    initials: string
    title: string
    general_eng: string
    district_no: string
    intake: string
    reg_no: string
    telep_1: string
    telep_2: string
    address_no: string
    address_city: string
    address_street: string
    address_4: string
    student_temp_no: number
    district_name: string
    name_initial: string
    full_name: string
    syllabus: string
    AL_index_no: number
    rank: number
    GPA: number
    ac_year_ID: number
  }

  export type studentUncheckedCreateInput = {
    index_no?: number
    user_id: number
    nic: string
    gender: string
    initials: string
    title: string
    general_eng: string
    district_no: string
    intake: string
    reg_no: string
    telep_1: string
    telep_2: string
    address_no: string
    address_city: string
    address_street: string
    address_4: string
    student_temp_no: number
    district_name: string
    name_initial: string
    full_name: string
    syllabus: string
    AL_index_no: number
    rank: number
    GPA: number
    ac_year_ID: number
  }

  export type studentUpdateInput = {
    user_id?: IntFieldUpdateOperationsInput | number
    nic?: StringFieldUpdateOperationsInput | string
    gender?: StringFieldUpdateOperationsInput | string
    initials?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    general_eng?: StringFieldUpdateOperationsInput | string
    district_no?: StringFieldUpdateOperationsInput | string
    intake?: StringFieldUpdateOperationsInput | string
    reg_no?: StringFieldUpdateOperationsInput | string
    telep_1?: StringFieldUpdateOperationsInput | string
    telep_2?: StringFieldUpdateOperationsInput | string
    address_no?: StringFieldUpdateOperationsInput | string
    address_city?: StringFieldUpdateOperationsInput | string
    address_street?: StringFieldUpdateOperationsInput | string
    address_4?: StringFieldUpdateOperationsInput | string
    student_temp_no?: IntFieldUpdateOperationsInput | number
    district_name?: StringFieldUpdateOperationsInput | string
    name_initial?: StringFieldUpdateOperationsInput | string
    full_name?: StringFieldUpdateOperationsInput | string
    syllabus?: StringFieldUpdateOperationsInput | string
    AL_index_no?: IntFieldUpdateOperationsInput | number
    rank?: IntFieldUpdateOperationsInput | number
    GPA?: IntFieldUpdateOperationsInput | number
    ac_year_ID?: IntFieldUpdateOperationsInput | number
  }

  export type studentUncheckedUpdateInput = {
    index_no?: IntFieldUpdateOperationsInput | number
    user_id?: IntFieldUpdateOperationsInput | number
    nic?: StringFieldUpdateOperationsInput | string
    gender?: StringFieldUpdateOperationsInput | string
    initials?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    general_eng?: StringFieldUpdateOperationsInput | string
    district_no?: StringFieldUpdateOperationsInput | string
    intake?: StringFieldUpdateOperationsInput | string
    reg_no?: StringFieldUpdateOperationsInput | string
    telep_1?: StringFieldUpdateOperationsInput | string
    telep_2?: StringFieldUpdateOperationsInput | string
    address_no?: StringFieldUpdateOperationsInput | string
    address_city?: StringFieldUpdateOperationsInput | string
    address_street?: StringFieldUpdateOperationsInput | string
    address_4?: StringFieldUpdateOperationsInput | string
    student_temp_no?: IntFieldUpdateOperationsInput | number
    district_name?: StringFieldUpdateOperationsInput | string
    name_initial?: StringFieldUpdateOperationsInput | string
    full_name?: StringFieldUpdateOperationsInput | string
    syllabus?: StringFieldUpdateOperationsInput | string
    AL_index_no?: IntFieldUpdateOperationsInput | number
    rank?: IntFieldUpdateOperationsInput | number
    GPA?: IntFieldUpdateOperationsInput | number
    ac_year_ID?: IntFieldUpdateOperationsInput | number
  }

  export type studentCreateManyInput = {
    index_no?: number
    user_id: number
    nic: string
    gender: string
    initials: string
    title: string
    general_eng: string
    district_no: string
    intake: string
    reg_no: string
    telep_1: string
    telep_2: string
    address_no: string
    address_city: string
    address_street: string
    address_4: string
    student_temp_no: number
    district_name: string
    name_initial: string
    full_name: string
    syllabus: string
    AL_index_no: number
    rank: number
    GPA: number
    ac_year_ID: number
  }

  export type studentUpdateManyMutationInput = {
    user_id?: IntFieldUpdateOperationsInput | number
    nic?: StringFieldUpdateOperationsInput | string
    gender?: StringFieldUpdateOperationsInput | string
    initials?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    general_eng?: StringFieldUpdateOperationsInput | string
    district_no?: StringFieldUpdateOperationsInput | string
    intake?: StringFieldUpdateOperationsInput | string
    reg_no?: StringFieldUpdateOperationsInput | string
    telep_1?: StringFieldUpdateOperationsInput | string
    telep_2?: StringFieldUpdateOperationsInput | string
    address_no?: StringFieldUpdateOperationsInput | string
    address_city?: StringFieldUpdateOperationsInput | string
    address_street?: StringFieldUpdateOperationsInput | string
    address_4?: StringFieldUpdateOperationsInput | string
    student_temp_no?: IntFieldUpdateOperationsInput | number
    district_name?: StringFieldUpdateOperationsInput | string
    name_initial?: StringFieldUpdateOperationsInput | string
    full_name?: StringFieldUpdateOperationsInput | string
    syllabus?: StringFieldUpdateOperationsInput | string
    AL_index_no?: IntFieldUpdateOperationsInput | number
    rank?: IntFieldUpdateOperationsInput | number
    GPA?: IntFieldUpdateOperationsInput | number
    ac_year_ID?: IntFieldUpdateOperationsInput | number
  }

  export type studentUncheckedUpdateManyInput = {
    index_no?: IntFieldUpdateOperationsInput | number
    user_id?: IntFieldUpdateOperationsInput | number
    nic?: StringFieldUpdateOperationsInput | string
    gender?: StringFieldUpdateOperationsInput | string
    initials?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    general_eng?: StringFieldUpdateOperationsInput | string
    district_no?: StringFieldUpdateOperationsInput | string
    intake?: StringFieldUpdateOperationsInput | string
    reg_no?: StringFieldUpdateOperationsInput | string
    telep_1?: StringFieldUpdateOperationsInput | string
    telep_2?: StringFieldUpdateOperationsInput | string
    address_no?: StringFieldUpdateOperationsInput | string
    address_city?: StringFieldUpdateOperationsInput | string
    address_street?: StringFieldUpdateOperationsInput | string
    address_4?: StringFieldUpdateOperationsInput | string
    student_temp_no?: IntFieldUpdateOperationsInput | number
    district_name?: StringFieldUpdateOperationsInput | string
    name_initial?: StringFieldUpdateOperationsInput | string
    full_name?: StringFieldUpdateOperationsInput | string
    syllabus?: StringFieldUpdateOperationsInput | string
    AL_index_no?: IntFieldUpdateOperationsInput | number
    rank?: IntFieldUpdateOperationsInput | number
    GPA?: IntFieldUpdateOperationsInput | number
    ac_year_ID?: IntFieldUpdateOperationsInput | number
  }

  export type subject_reportCreateInput = {
    no_of_student: number
    report_id: number
  }

  export type subject_reportUncheckedCreateInput = {
    subject_id?: number
    no_of_student: number
    report_id: number
  }

  export type subject_reportUpdateInput = {
    no_of_student?: IntFieldUpdateOperationsInput | number
    report_id?: IntFieldUpdateOperationsInput | number
  }

  export type subject_reportUncheckedUpdateInput = {
    subject_id?: IntFieldUpdateOperationsInput | number
    no_of_student?: IntFieldUpdateOperationsInput | number
    report_id?: IntFieldUpdateOperationsInput | number
  }

  export type subject_reportCreateManyInput = {
    subject_id?: number
    no_of_student: number
    report_id: number
  }

  export type subject_reportUpdateManyMutationInput = {
    no_of_student?: IntFieldUpdateOperationsInput | number
    report_id?: IntFieldUpdateOperationsInput | number
  }

  export type subject_reportUncheckedUpdateManyInput = {
    subject_id?: IntFieldUpdateOperationsInput | number
    no_of_student?: IntFieldUpdateOperationsInput | number
    report_id?: IntFieldUpdateOperationsInput | number
  }

  export type system_pagesCreateInput = {
    content: string
    admin_id: number
  }

  export type system_pagesUncheckedCreateInput = {
    page_id?: number
    content: string
    admin_id: number
  }

  export type system_pagesUpdateInput = {
    content?: StringFieldUpdateOperationsInput | string
    admin_id?: IntFieldUpdateOperationsInput | number
  }

  export type system_pagesUncheckedUpdateInput = {
    page_id?: IntFieldUpdateOperationsInput | number
    content?: StringFieldUpdateOperationsInput | string
    admin_id?: IntFieldUpdateOperationsInput | number
  }

  export type system_pagesCreateManyInput = {
    page_id?: number
    content: string
    admin_id: number
  }

  export type system_pagesUpdateManyMutationInput = {
    content?: StringFieldUpdateOperationsInput | string
    admin_id?: IntFieldUpdateOperationsInput | number
  }

  export type system_pagesUncheckedUpdateManyInput = {
    page_id?: IntFieldUpdateOperationsInput | number
    content?: StringFieldUpdateOperationsInput | string
    admin_id?: IntFieldUpdateOperationsInput | number
  }

  export type transcriptCreateInput = {
    letter_id: number
  }

  export type transcriptUncheckedCreateInput = {
    transcript_id?: number
    letter_id: number
  }

  export type transcriptUpdateInput = {
    letter_id?: IntFieldUpdateOperationsInput | number
  }

  export type transcriptUncheckedUpdateInput = {
    transcript_id?: IntFieldUpdateOperationsInput | number
    letter_id?: IntFieldUpdateOperationsInput | number
  }

  export type transcriptCreateManyInput = {
    transcript_id?: number
    letter_id: number
  }

  export type transcriptUpdateManyMutationInput = {
    letter_id?: IntFieldUpdateOperationsInput | number
  }

  export type transcriptUncheckedUpdateManyInput = {
    transcript_id?: IntFieldUpdateOperationsInput | number
    letter_id?: IntFieldUpdateOperationsInput | number
  }

  export type userCreateInput = {
    user_name: string
    password: string
    email: string
    user_type: string
    f_name: string
    l_name: string
    profile_pic?: string | null
  }

  export type userUncheckedCreateInput = {
    user_id?: number
    user_name: string
    password: string
    email: string
    user_type: string
    f_name: string
    l_name: string
    profile_pic?: string | null
  }

  export type userUpdateInput = {
    user_name?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    user_type?: StringFieldUpdateOperationsInput | string
    f_name?: StringFieldUpdateOperationsInput | string
    l_name?: StringFieldUpdateOperationsInput | string
    profile_pic?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type userUncheckedUpdateInput = {
    user_id?: IntFieldUpdateOperationsInput | number
    user_name?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    user_type?: StringFieldUpdateOperationsInput | string
    f_name?: StringFieldUpdateOperationsInput | string
    l_name?: StringFieldUpdateOperationsInput | string
    profile_pic?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type userCreateManyInput = {
    user_id?: number
    user_name: string
    password: string
    email: string
    user_type: string
    f_name: string
    l_name: string
    profile_pic?: string | null
  }

  export type userUpdateManyMutationInput = {
    user_name?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    user_type?: StringFieldUpdateOperationsInput | string
    f_name?: StringFieldUpdateOperationsInput | string
    l_name?: StringFieldUpdateOperationsInput | string
    profile_pic?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type userUncheckedUpdateManyInput = {
    user_id?: IntFieldUpdateOperationsInput | number
    user_name?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    user_type?: StringFieldUpdateOperationsInput | string
    f_name?: StringFieldUpdateOperationsInput | string
    l_name?: StringFieldUpdateOperationsInput | string
    profile_pic?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type IntFilter = {
    equals?: number
    in?: Enumerable<number>
    notIn?: Enumerable<number>
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntFilter | number
  }

  export type academic_yearCountOrderByAggregateInput = {
    ac_year_ID?: SortOrder
    no_of_student?: SortOrder
    year?: SortOrder
  }

  export type academic_yearAvgOrderByAggregateInput = {
    ac_year_ID?: SortOrder
    no_of_student?: SortOrder
    year?: SortOrder
  }

  export type academic_yearMaxOrderByAggregateInput = {
    ac_year_ID?: SortOrder
    no_of_student?: SortOrder
    year?: SortOrder
  }

  export type academic_yearMinOrderByAggregateInput = {
    ac_year_ID?: SortOrder
    no_of_student?: SortOrder
    year?: SortOrder
  }

  export type academic_yearSumOrderByAggregateInput = {
    ac_year_ID?: SortOrder
    no_of_student?: SortOrder
    year?: SortOrder
  }

  export type IntWithAggregatesFilter = {
    equals?: number
    in?: Enumerable<number>
    notIn?: Enumerable<number>
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntWithAggregatesFilter | number
    _count?: NestedIntFilter
    _avg?: NestedFloatFilter
    _sum?: NestedIntFilter
    _min?: NestedIntFilter
    _max?: NestedIntFilter
  }

  export type StringFilter = {
    equals?: string
    in?: Enumerable<string>
    notIn?: Enumerable<string>
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    not?: NestedStringFilter | string
  }

  export type DateTimeFilter = {
    equals?: Date | string
    in?: Enumerable<Date> | Enumerable<string>
    notIn?: Enumerable<Date> | Enumerable<string>
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeFilter | Date | string
  }

  export type admissionCountOrderByAggregateInput = {
    admission_id?: SortOrder
    exam_hall?: SortOrder
    course_name?: SortOrder
    course_code?: SortOrder
    exan_date?: SortOrder
    exam_time?: SortOrder
    attendence_verify?: SortOrder
  }

  export type admissionAvgOrderByAggregateInput = {
    admission_id?: SortOrder
  }

  export type admissionMaxOrderByAggregateInput = {
    admission_id?: SortOrder
    exam_hall?: SortOrder
    course_name?: SortOrder
    course_code?: SortOrder
    exan_date?: SortOrder
    exam_time?: SortOrder
    attendence_verify?: SortOrder
  }

  export type admissionMinOrderByAggregateInput = {
    admission_id?: SortOrder
    exam_hall?: SortOrder
    course_name?: SortOrder
    course_code?: SortOrder
    exan_date?: SortOrder
    exam_time?: SortOrder
    attendence_verify?: SortOrder
  }

  export type admissionSumOrderByAggregateInput = {
    admission_id?: SortOrder
  }

  export type StringWithAggregatesFilter = {
    equals?: string
    in?: Enumerable<string>
    notIn?: Enumerable<string>
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    not?: NestedStringWithAggregatesFilter | string
    _count?: NestedIntFilter
    _min?: NestedStringFilter
    _max?: NestedStringFilter
  }

  export type DateTimeWithAggregatesFilter = {
    equals?: Date | string
    in?: Enumerable<Date> | Enumerable<string>
    notIn?: Enumerable<Date> | Enumerable<string>
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeWithAggregatesFilter | Date | string
    _count?: NestedIntFilter
    _min?: NestedDateTimeFilter
    _max?: NestedDateTimeFilter
  }

  export type announcementCountOrderByAggregateInput = {
    annou_id?: SortOrder
    content?: SortOrder
    admin_id?: SortOrder
  }

  export type announcementAvgOrderByAggregateInput = {
    annou_id?: SortOrder
    admin_id?: SortOrder
  }

  export type announcementMaxOrderByAggregateInput = {
    annou_id?: SortOrder
    content?: SortOrder
    admin_id?: SortOrder
  }

  export type announcementMinOrderByAggregateInput = {
    annou_id?: SortOrder
    content?: SortOrder
    admin_id?: SortOrder
  }

  export type announcementSumOrderByAggregateInput = {
    annou_id?: SortOrder
    admin_id?: SortOrder
  }

  export type assign_marksCountOrderByAggregateInput = {
    assigment_id?: SortOrder
    sub_marks?: SortOrder
    total_marks?: SortOrder
    assign_precentage?: SortOrder
    mark_id?: SortOrder
  }

  export type assign_marksAvgOrderByAggregateInput = {
    assigment_id?: SortOrder
    sub_marks?: SortOrder
    total_marks?: SortOrder
    assign_precentage?: SortOrder
    mark_id?: SortOrder
  }

  export type assign_marksMaxOrderByAggregateInput = {
    assigment_id?: SortOrder
    sub_marks?: SortOrder
    total_marks?: SortOrder
    assign_precentage?: SortOrder
    mark_id?: SortOrder
  }

  export type assign_marksMinOrderByAggregateInput = {
    assigment_id?: SortOrder
    sub_marks?: SortOrder
    total_marks?: SortOrder
    assign_precentage?: SortOrder
    mark_id?: SortOrder
  }

  export type assign_marksSumOrderByAggregateInput = {
    assigment_id?: SortOrder
    sub_marks?: SortOrder
    total_marks?: SortOrder
    assign_precentage?: SortOrder
    mark_id?: SortOrder
  }

  export type assignmentsCountOrderByAggregateInput = {
    assignment_id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    contribution?: SortOrder
    lecturer_id?: SortOrder
    course_id?: SortOrder
  }

  export type assignmentsAvgOrderByAggregateInput = {
    assignment_id?: SortOrder
    contribution?: SortOrder
    lecturer_id?: SortOrder
    course_id?: SortOrder
  }

  export type assignmentsMaxOrderByAggregateInput = {
    assignment_id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    contribution?: SortOrder
    lecturer_id?: SortOrder
    course_id?: SortOrder
  }

  export type assignmentsMinOrderByAggregateInput = {
    assignment_id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    contribution?: SortOrder
    lecturer_id?: SortOrder
    course_id?: SortOrder
  }

  export type assignmentsSumOrderByAggregateInput = {
    assignment_id?: SortOrder
    contribution?: SortOrder
    lecturer_id?: SortOrder
    course_id?: SortOrder
  }

  export type confirmCountOrderByAggregateInput = {
    confirm_id?: SortOrder
    letter_id?: SortOrder
  }

  export type confirmAvgOrderByAggregateInput = {
    confirm_id?: SortOrder
    letter_id?: SortOrder
  }

  export type confirmMaxOrderByAggregateInput = {
    confirm_id?: SortOrder
    letter_id?: SortOrder
  }

  export type confirmMinOrderByAggregateInput = {
    confirm_id?: SortOrder
    letter_id?: SortOrder
  }

  export type confirmSumOrderByAggregateInput = {
    confirm_id?: SortOrder
    letter_id?: SortOrder
  }

  export type courseCountOrderByAggregateInput = {
    course_id?: SortOrder
    year?: SortOrder
    semester?: SortOrder
    course_name?: SortOrder
    course_code?: SortOrder
    lecture_name?: SortOrder
    ac_year_ID?: SortOrder
  }

  export type courseAvgOrderByAggregateInput = {
    course_id?: SortOrder
    year?: SortOrder
    ac_year_ID?: SortOrder
  }

  export type courseMaxOrderByAggregateInput = {
    course_id?: SortOrder
    year?: SortOrder
    semester?: SortOrder
    course_name?: SortOrder
    course_code?: SortOrder
    lecture_name?: SortOrder
    ac_year_ID?: SortOrder
  }

  export type courseMinOrderByAggregateInput = {
    course_id?: SortOrder
    year?: SortOrder
    semester?: SortOrder
    course_name?: SortOrder
    course_code?: SortOrder
    lecture_name?: SortOrder
    ac_year_ID?: SortOrder
  }

  export type courseSumOrderByAggregateInput = {
    course_id?: SortOrder
    year?: SortOrder
    ac_year_ID?: SortOrder
  }

  export type directorCountOrderByAggregateInput = {
    director_id?: SortOrder
    user_id?: SortOrder
  }

  export type directorAvgOrderByAggregateInput = {
    director_id?: SortOrder
    user_id?: SortOrder
  }

  export type directorMaxOrderByAggregateInput = {
    director_id?: SortOrder
    user_id?: SortOrder
  }

  export type directorMinOrderByAggregateInput = {
    director_id?: SortOrder
    user_id?: SortOrder
  }

  export type directorSumOrderByAggregateInput = {
    director_id?: SortOrder
    user_id?: SortOrder
  }

  export type examCountOrderByAggregateInput = {
    exam_sem_id?: SortOrder
    semester?: SortOrder
    year?: SortOrder
  }

  export type examAvgOrderByAggregateInput = {
    exam_sem_id?: SortOrder
    semester?: SortOrder
    year?: SortOrder
  }

  export type examMaxOrderByAggregateInput = {
    exam_sem_id?: SortOrder
    semester?: SortOrder
    year?: SortOrder
  }

  export type examMinOrderByAggregateInput = {
    exam_sem_id?: SortOrder
    semester?: SortOrder
    year?: SortOrder
  }

  export type examSumOrderByAggregateInput = {
    exam_sem_id?: SortOrder
    semester?: SortOrder
    year?: SortOrder
  }

  export type exam_markCountOrderByAggregateInput = {
    mark_id?: SortOrder
    course_code?: SortOrder
    course_name?: SortOrder
    grade?: SortOrder
    total_mark?: SortOrder
    director_status?: SortOrder
    head_of_exam_status?: SortOrder
    exam_sem_id?: SortOrder
    director_id?: SortOrder
    head_of_exam_id?: SortOrder
    index_no?: SortOrder
  }

  export type exam_markAvgOrderByAggregateInput = {
    mark_id?: SortOrder
    total_mark?: SortOrder
    exam_sem_id?: SortOrder
    director_id?: SortOrder
    head_of_exam_id?: SortOrder
    index_no?: SortOrder
  }

  export type exam_markMaxOrderByAggregateInput = {
    mark_id?: SortOrder
    course_code?: SortOrder
    course_name?: SortOrder
    grade?: SortOrder
    total_mark?: SortOrder
    director_status?: SortOrder
    head_of_exam_status?: SortOrder
    exam_sem_id?: SortOrder
    director_id?: SortOrder
    head_of_exam_id?: SortOrder
    index_no?: SortOrder
  }

  export type exam_markMinOrderByAggregateInput = {
    mark_id?: SortOrder
    course_code?: SortOrder
    course_name?: SortOrder
    grade?: SortOrder
    total_mark?: SortOrder
    director_status?: SortOrder
    head_of_exam_status?: SortOrder
    exam_sem_id?: SortOrder
    director_id?: SortOrder
    head_of_exam_id?: SortOrder
    index_no?: SortOrder
  }

  export type exam_markSumOrderByAggregateInput = {
    mark_id?: SortOrder
    total_mark?: SortOrder
    exam_sem_id?: SortOrder
    director_id?: SortOrder
    head_of_exam_id?: SortOrder
    index_no?: SortOrder
  }

  export type exam_timetableCountOrderByAggregateInput = {
    timetable_id?: SortOrder
    exam_date?: SortOrder
    exam_time?: SortOrder
    course_code?: SortOrder
    course_name?: SortOrder
    exam_sem_id?: SortOrder
  }

  export type exam_timetableAvgOrderByAggregateInput = {
    timetable_id?: SortOrder
    exam_sem_id?: SortOrder
  }

  export type exam_timetableMaxOrderByAggregateInput = {
    timetable_id?: SortOrder
    exam_date?: SortOrder
    exam_time?: SortOrder
    course_code?: SortOrder
    course_name?: SortOrder
    exam_sem_id?: SortOrder
  }

  export type exam_timetableMinOrderByAggregateInput = {
    timetable_id?: SortOrder
    exam_date?: SortOrder
    exam_time?: SortOrder
    course_code?: SortOrder
    course_name?: SortOrder
    exam_sem_id?: SortOrder
  }

  export type exam_timetableSumOrderByAggregateInput = {
    timetable_id?: SortOrder
    exam_sem_id?: SortOrder
  }

  export type head_of_exam_boardCountOrderByAggregateInput = {
    head_of_exam_ID?: SortOrder
    user_id?: SortOrder
    staff_id?: SortOrder
  }

  export type head_of_exam_boardAvgOrderByAggregateInput = {
    head_of_exam_ID?: SortOrder
    user_id?: SortOrder
    staff_id?: SortOrder
  }

  export type head_of_exam_boardMaxOrderByAggregateInput = {
    head_of_exam_ID?: SortOrder
    user_id?: SortOrder
    staff_id?: SortOrder
  }

  export type head_of_exam_boardMinOrderByAggregateInput = {
    head_of_exam_ID?: SortOrder
    user_id?: SortOrder
    staff_id?: SortOrder
  }

  export type head_of_exam_boardSumOrderByAggregateInput = {
    head_of_exam_ID?: SortOrder
    user_id?: SortOrder
    staff_id?: SortOrder
  }

  export type lecture_questionCountOrderByAggregateInput = {
    exam_paper_id?: SortOrder
    lecture_id?: SortOrder
  }

  export type lecture_questionAvgOrderByAggregateInput = {
    exam_paper_id?: SortOrder
    lecture_id?: SortOrder
  }

  export type lecture_questionMaxOrderByAggregateInput = {
    exam_paper_id?: SortOrder
    lecture_id?: SortOrder
  }

  export type lecture_questionMinOrderByAggregateInput = {
    exam_paper_id?: SortOrder
    lecture_id?: SortOrder
  }

  export type lecture_questionSumOrderByAggregateInput = {
    exam_paper_id?: SortOrder
    lecture_id?: SortOrder
  }

  export type lecturerCountOrderByAggregateInput = {
    lecturer_id?: SortOrder
    degree?: SortOrder
    user_id?: SortOrder
  }

  export type lecturerAvgOrderByAggregateInput = {
    lecturer_id?: SortOrder
    user_id?: SortOrder
  }

  export type lecturerMaxOrderByAggregateInput = {
    lecturer_id?: SortOrder
    degree?: SortOrder
    user_id?: SortOrder
  }

  export type lecturerMinOrderByAggregateInput = {
    lecturer_id?: SortOrder
    degree?: SortOrder
    user_id?: SortOrder
  }

  export type lecturerSumOrderByAggregateInput = {
    lecturer_id?: SortOrder
    user_id?: SortOrder
  }

  export type lecturer_coursesUser_idCourse_idCompoundUniqueInput = {
    user_id: number
    course_id: number
  }

  export type lecturer_coursesCountOrderByAggregateInput = {
    user_id?: SortOrder
    course_id?: SortOrder
  }

  export type lecturer_coursesAvgOrderByAggregateInput = {
    user_id?: SortOrder
    course_id?: SortOrder
  }

  export type lecturer_coursesMaxOrderByAggregateInput = {
    user_id?: SortOrder
    course_id?: SortOrder
  }

  export type lecturer_coursesMinOrderByAggregateInput = {
    user_id?: SortOrder
    course_id?: SortOrder
  }

  export type lecturer_coursesSumOrderByAggregateInput = {
    user_id?: SortOrder
    course_id?: SortOrder
  }

  export type letterCountOrderByAggregateInput = {
    letter_id?: SortOrder
    email?: SortOrder
    another_email?: SortOrder
    final_quali?: SortOrder
    id_no?: SortOrder
    duration?: SortOrder
    degree_status?: SortOrder
    study_year?: SortOrder
    index_no?: SortOrder
    reg_no?: SortOrder
    degree_prog?: SortOrder
    address?: SortOrder
    contact_no?: SortOrder
    another_cont_no?: SortOrder
    payment_voucher?: SortOrder
  }

  export type letterAvgOrderByAggregateInput = {
    letter_id?: SortOrder
    duration?: SortOrder
    study_year?: SortOrder
    index_no?: SortOrder
  }

  export type letterMaxOrderByAggregateInput = {
    letter_id?: SortOrder
    email?: SortOrder
    another_email?: SortOrder
    final_quali?: SortOrder
    id_no?: SortOrder
    duration?: SortOrder
    degree_status?: SortOrder
    study_year?: SortOrder
    index_no?: SortOrder
    reg_no?: SortOrder
    degree_prog?: SortOrder
    address?: SortOrder
    contact_no?: SortOrder
    another_cont_no?: SortOrder
    payment_voucher?: SortOrder
  }

  export type letterMinOrderByAggregateInput = {
    letter_id?: SortOrder
    email?: SortOrder
    another_email?: SortOrder
    final_quali?: SortOrder
    id_no?: SortOrder
    duration?: SortOrder
    degree_status?: SortOrder
    study_year?: SortOrder
    index_no?: SortOrder
    reg_no?: SortOrder
    degree_prog?: SortOrder
    address?: SortOrder
    contact_no?: SortOrder
    another_cont_no?: SortOrder
    payment_voucher?: SortOrder
  }

  export type letterSumOrderByAggregateInput = {
    letter_id?: SortOrder
    duration?: SortOrder
    study_year?: SortOrder
    index_no?: SortOrder
  }

  export type maCountOrderByAggregateInput = {
    MA_id?: SortOrder
    user_id?: SortOrder
    staff_id?: SortOrder
    office_id?: SortOrder
    letter_id?: SortOrder
  }

  export type maAvgOrderByAggregateInput = {
    MA_id?: SortOrder
    user_id?: SortOrder
    staff_id?: SortOrder
    letter_id?: SortOrder
  }

  export type maMaxOrderByAggregateInput = {
    MA_id?: SortOrder
    user_id?: SortOrder
    staff_id?: SortOrder
    office_id?: SortOrder
    letter_id?: SortOrder
  }

  export type maMinOrderByAggregateInput = {
    MA_id?: SortOrder
    user_id?: SortOrder
    staff_id?: SortOrder
    office_id?: SortOrder
    letter_id?: SortOrder
  }

  export type maSumOrderByAggregateInput = {
    MA_id?: SortOrder
    user_id?: SortOrder
    staff_id?: SortOrder
    letter_id?: SortOrder
  }

  export type mis_reportCountOrderByAggregateInput = {
    mis_id?: SortOrder
    report_id?: SortOrder
  }

  export type mis_reportAvgOrderByAggregateInput = {
    mis_id?: SortOrder
    report_id?: SortOrder
  }

  export type mis_reportMaxOrderByAggregateInput = {
    mis_id?: SortOrder
    report_id?: SortOrder
  }

  export type mis_reportMinOrderByAggregateInput = {
    mis_id?: SortOrder
    report_id?: SortOrder
  }

  export type mis_reportSumOrderByAggregateInput = {
    mis_id?: SortOrder
    report_id?: SortOrder
  }

  export type paper_marksCountOrderByAggregateInput = {
    paper_id?: SortOrder
    sub_marks?: SortOrder
    total_marks?: SortOrder
    paper_precentage?: SortOrder
    mark_id?: SortOrder
  }

  export type paper_marksAvgOrderByAggregateInput = {
    paper_id?: SortOrder
    sub_marks?: SortOrder
    total_marks?: SortOrder
    paper_precentage?: SortOrder
    mark_id?: SortOrder
  }

  export type paper_marksMaxOrderByAggregateInput = {
    paper_id?: SortOrder
    sub_marks?: SortOrder
    total_marks?: SortOrder
    paper_precentage?: SortOrder
    mark_id?: SortOrder
  }

  export type paper_marksMinOrderByAggregateInput = {
    paper_id?: SortOrder
    sub_marks?: SortOrder
    total_marks?: SortOrder
    paper_precentage?: SortOrder
    mark_id?: SortOrder
  }

  export type paper_marksSumOrderByAggregateInput = {
    paper_id?: SortOrder
    sub_marks?: SortOrder
    total_marks?: SortOrder
    paper_precentage?: SortOrder
    mark_id?: SortOrder
  }

  export type paper_questionCountOrderByAggregateInput = {
    exam_paper_id?: SortOrder
    course_code?: SortOrder
    course_name?: SortOrder
    question_no?: SortOrder
    exam_sem_id?: SortOrder
  }

  export type paper_questionAvgOrderByAggregateInput = {
    exam_paper_id?: SortOrder
    question_no?: SortOrder
    exam_sem_id?: SortOrder
  }

  export type paper_questionMaxOrderByAggregateInput = {
    exam_paper_id?: SortOrder
    course_code?: SortOrder
    course_name?: SortOrder
    question_no?: SortOrder
    exam_sem_id?: SortOrder
  }

  export type paper_questionMinOrderByAggregateInput = {
    exam_paper_id?: SortOrder
    course_code?: SortOrder
    course_name?: SortOrder
    question_no?: SortOrder
    exam_sem_id?: SortOrder
  }

  export type paper_questionSumOrderByAggregateInput = {
    exam_paper_id?: SortOrder
    question_no?: SortOrder
    exam_sem_id?: SortOrder
  }

  export type paymentCountOrderByAggregateInput = {
    payment_id?: SortOrder
    payment_date?: SortOrder
    amount?: SortOrder
    status?: SortOrder
    index_no?: SortOrder
    ac_year_ID?: SortOrder
  }

  export type paymentAvgOrderByAggregateInput = {
    payment_id?: SortOrder
    amount?: SortOrder
    index_no?: SortOrder
    ac_year_ID?: SortOrder
  }

  export type paymentMaxOrderByAggregateInput = {
    payment_id?: SortOrder
    payment_date?: SortOrder
    amount?: SortOrder
    status?: SortOrder
    index_no?: SortOrder
    ac_year_ID?: SortOrder
  }

  export type paymentMinOrderByAggregateInput = {
    payment_id?: SortOrder
    payment_date?: SortOrder
    amount?: SortOrder
    status?: SortOrder
    index_no?: SortOrder
    ac_year_ID?: SortOrder
  }

  export type paymentSumOrderByAggregateInput = {
    payment_id?: SortOrder
    amount?: SortOrder
    index_no?: SortOrder
    ac_year_ID?: SortOrder
  }

  export type repeat_courseCountOrderByAggregateInput = {
    rc_id?: SortOrder
    course_code?: SortOrder
    course_name?: SortOrder
    year?: SortOrder
    semester?: SortOrder
  }

  export type repeat_courseAvgOrderByAggregateInput = {
    rc_id?: SortOrder
    year?: SortOrder
  }

  export type repeat_courseMaxOrderByAggregateInput = {
    rc_id?: SortOrder
    course_code?: SortOrder
    course_name?: SortOrder
    year?: SortOrder
    semester?: SortOrder
  }

  export type repeat_courseMinOrderByAggregateInput = {
    rc_id?: SortOrder
    course_code?: SortOrder
    course_name?: SortOrder
    year?: SortOrder
    semester?: SortOrder
  }

  export type repeat_courseSumOrderByAggregateInput = {
    rc_id?: SortOrder
    year?: SortOrder
  }

  export type reportCountOrderByAggregateInput = {
    report_id?: SortOrder
    course_name?: SortOrder
    course_code?: SortOrder
    year?: SortOrder
    semester?: SortOrder
    exam_sem_id?: SortOrder
  }

  export type reportAvgOrderByAggregateInput = {
    report_id?: SortOrder
    year?: SortOrder
    exam_sem_id?: SortOrder
  }

  export type reportMaxOrderByAggregateInput = {
    report_id?: SortOrder
    course_name?: SortOrder
    course_code?: SortOrder
    year?: SortOrder
    semester?: SortOrder
    exam_sem_id?: SortOrder
  }

  export type reportMinOrderByAggregateInput = {
    report_id?: SortOrder
    course_name?: SortOrder
    course_code?: SortOrder
    year?: SortOrder
    semester?: SortOrder
    exam_sem_id?: SortOrder
  }

  export type reportSumOrderByAggregateInput = {
    report_id?: SortOrder
    year?: SortOrder
    exam_sem_id?: SortOrder
  }

  export type sarCountOrderByAggregateInput = {
    SAR_id?: SortOrder
    user_id?: SortOrder
    staff_id?: SortOrder
    office_id?: SortOrder
  }

  export type sarAvgOrderByAggregateInput = {
    SAR_id?: SortOrder
    user_id?: SortOrder
    staff_id?: SortOrder
    office_id?: SortOrder
  }

  export type sarMaxOrderByAggregateInput = {
    SAR_id?: SortOrder
    user_id?: SortOrder
    staff_id?: SortOrder
    office_id?: SortOrder
  }

  export type sarMinOrderByAggregateInput = {
    SAR_id?: SortOrder
    user_id?: SortOrder
    staff_id?: SortOrder
    office_id?: SortOrder
  }

  export type sarSumOrderByAggregateInput = {
    SAR_id?: SortOrder
    user_id?: SortOrder
    staff_id?: SortOrder
    office_id?: SortOrder
  }

  export type staffCountOrderByAggregateInput = {
    staff_id?: SortOrder
    user_id?: SortOrder
  }

  export type staffAvgOrderByAggregateInput = {
    staff_id?: SortOrder
    user_id?: SortOrder
  }

  export type staffMaxOrderByAggregateInput = {
    staff_id?: SortOrder
    user_id?: SortOrder
  }

  export type staffMinOrderByAggregateInput = {
    staff_id?: SortOrder
    user_id?: SortOrder
  }

  export type staffSumOrderByAggregateInput = {
    staff_id?: SortOrder
    user_id?: SortOrder
  }

  export type studentCountOrderByAggregateInput = {
    index_no?: SortOrder
    user_id?: SortOrder
    nic?: SortOrder
    gender?: SortOrder
    initials?: SortOrder
    title?: SortOrder
    general_eng?: SortOrder
    district_no?: SortOrder
    intake?: SortOrder
    reg_no?: SortOrder
    telep_1?: SortOrder
    telep_2?: SortOrder
    address_no?: SortOrder
    address_city?: SortOrder
    address_street?: SortOrder
    address_4?: SortOrder
    student_temp_no?: SortOrder
    district_name?: SortOrder
    name_initial?: SortOrder
    full_name?: SortOrder
    syllabus?: SortOrder
    AL_index_no?: SortOrder
    rank?: SortOrder
    GPA?: SortOrder
    ac_year_ID?: SortOrder
  }

  export type studentAvgOrderByAggregateInput = {
    index_no?: SortOrder
    user_id?: SortOrder
    student_temp_no?: SortOrder
    AL_index_no?: SortOrder
    rank?: SortOrder
    GPA?: SortOrder
    ac_year_ID?: SortOrder
  }

  export type studentMaxOrderByAggregateInput = {
    index_no?: SortOrder
    user_id?: SortOrder
    nic?: SortOrder
    gender?: SortOrder
    initials?: SortOrder
    title?: SortOrder
    general_eng?: SortOrder
    district_no?: SortOrder
    intake?: SortOrder
    reg_no?: SortOrder
    telep_1?: SortOrder
    telep_2?: SortOrder
    address_no?: SortOrder
    address_city?: SortOrder
    address_street?: SortOrder
    address_4?: SortOrder
    student_temp_no?: SortOrder
    district_name?: SortOrder
    name_initial?: SortOrder
    full_name?: SortOrder
    syllabus?: SortOrder
    AL_index_no?: SortOrder
    rank?: SortOrder
    GPA?: SortOrder
    ac_year_ID?: SortOrder
  }

  export type studentMinOrderByAggregateInput = {
    index_no?: SortOrder
    user_id?: SortOrder
    nic?: SortOrder
    gender?: SortOrder
    initials?: SortOrder
    title?: SortOrder
    general_eng?: SortOrder
    district_no?: SortOrder
    intake?: SortOrder
    reg_no?: SortOrder
    telep_1?: SortOrder
    telep_2?: SortOrder
    address_no?: SortOrder
    address_city?: SortOrder
    address_street?: SortOrder
    address_4?: SortOrder
    student_temp_no?: SortOrder
    district_name?: SortOrder
    name_initial?: SortOrder
    full_name?: SortOrder
    syllabus?: SortOrder
    AL_index_no?: SortOrder
    rank?: SortOrder
    GPA?: SortOrder
    ac_year_ID?: SortOrder
  }

  export type studentSumOrderByAggregateInput = {
    index_no?: SortOrder
    user_id?: SortOrder
    student_temp_no?: SortOrder
    AL_index_no?: SortOrder
    rank?: SortOrder
    GPA?: SortOrder
    ac_year_ID?: SortOrder
  }

  export type subject_reportCountOrderByAggregateInput = {
    subject_id?: SortOrder
    no_of_student?: SortOrder
    report_id?: SortOrder
  }

  export type subject_reportAvgOrderByAggregateInput = {
    subject_id?: SortOrder
    no_of_student?: SortOrder
    report_id?: SortOrder
  }

  export type subject_reportMaxOrderByAggregateInput = {
    subject_id?: SortOrder
    no_of_student?: SortOrder
    report_id?: SortOrder
  }

  export type subject_reportMinOrderByAggregateInput = {
    subject_id?: SortOrder
    no_of_student?: SortOrder
    report_id?: SortOrder
  }

  export type subject_reportSumOrderByAggregateInput = {
    subject_id?: SortOrder
    no_of_student?: SortOrder
    report_id?: SortOrder
  }

  export type system_pagesCountOrderByAggregateInput = {
    page_id?: SortOrder
    content?: SortOrder
    admin_id?: SortOrder
  }

  export type system_pagesAvgOrderByAggregateInput = {
    page_id?: SortOrder
    admin_id?: SortOrder
  }

  export type system_pagesMaxOrderByAggregateInput = {
    page_id?: SortOrder
    content?: SortOrder
    admin_id?: SortOrder
  }

  export type system_pagesMinOrderByAggregateInput = {
    page_id?: SortOrder
    content?: SortOrder
    admin_id?: SortOrder
  }

  export type system_pagesSumOrderByAggregateInput = {
    page_id?: SortOrder
    admin_id?: SortOrder
  }

  export type transcriptCountOrderByAggregateInput = {
    transcript_id?: SortOrder
    letter_id?: SortOrder
  }

  export type transcriptAvgOrderByAggregateInput = {
    transcript_id?: SortOrder
    letter_id?: SortOrder
  }

  export type transcriptMaxOrderByAggregateInput = {
    transcript_id?: SortOrder
    letter_id?: SortOrder
  }

  export type transcriptMinOrderByAggregateInput = {
    transcript_id?: SortOrder
    letter_id?: SortOrder
  }

  export type transcriptSumOrderByAggregateInput = {
    transcript_id?: SortOrder
    letter_id?: SortOrder
  }

  export type StringNullableFilter = {
    equals?: string | null
    in?: Enumerable<string> | null
    notIn?: Enumerable<string> | null
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    not?: NestedStringNullableFilter | string | null
  }

  export type userCountOrderByAggregateInput = {
    user_id?: SortOrder
    user_name?: SortOrder
    password?: SortOrder
    email?: SortOrder
    user_type?: SortOrder
    f_name?: SortOrder
    l_name?: SortOrder
    profile_pic?: SortOrder
  }

  export type userAvgOrderByAggregateInput = {
    user_id?: SortOrder
  }

  export type userMaxOrderByAggregateInput = {
    user_id?: SortOrder
    user_name?: SortOrder
    password?: SortOrder
    email?: SortOrder
    user_type?: SortOrder
    f_name?: SortOrder
    l_name?: SortOrder
    profile_pic?: SortOrder
  }

  export type userMinOrderByAggregateInput = {
    user_id?: SortOrder
    user_name?: SortOrder
    password?: SortOrder
    email?: SortOrder
    user_type?: SortOrder
    f_name?: SortOrder
    l_name?: SortOrder
    profile_pic?: SortOrder
  }

  export type userSumOrderByAggregateInput = {
    user_id?: SortOrder
  }

  export type StringNullableWithAggregatesFilter = {
    equals?: string | null
    in?: Enumerable<string> | null
    notIn?: Enumerable<string> | null
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    not?: NestedStringNullableWithAggregatesFilter | string | null
    _count?: NestedIntNullableFilter
    _min?: NestedStringNullableFilter
    _max?: NestedStringNullableFilter
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type NestedIntFilter = {
    equals?: number
    in?: Enumerable<number>
    notIn?: Enumerable<number>
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntFilter | number
  }

  export type NestedIntWithAggregatesFilter = {
    equals?: number
    in?: Enumerable<number>
    notIn?: Enumerable<number>
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntWithAggregatesFilter | number
    _count?: NestedIntFilter
    _avg?: NestedFloatFilter
    _sum?: NestedIntFilter
    _min?: NestedIntFilter
    _max?: NestedIntFilter
  }

  export type NestedFloatFilter = {
    equals?: number
    in?: Enumerable<number>
    notIn?: Enumerable<number>
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedFloatFilter | number
  }

  export type NestedStringFilter = {
    equals?: string
    in?: Enumerable<string>
    notIn?: Enumerable<string>
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    not?: NestedStringFilter | string
  }

  export type NestedDateTimeFilter = {
    equals?: Date | string
    in?: Enumerable<Date> | Enumerable<string>
    notIn?: Enumerable<Date> | Enumerable<string>
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeFilter | Date | string
  }

  export type NestedStringWithAggregatesFilter = {
    equals?: string
    in?: Enumerable<string>
    notIn?: Enumerable<string>
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    not?: NestedStringWithAggregatesFilter | string
    _count?: NestedIntFilter
    _min?: NestedStringFilter
    _max?: NestedStringFilter
  }

  export type NestedDateTimeWithAggregatesFilter = {
    equals?: Date | string
    in?: Enumerable<Date> | Enumerable<string>
    notIn?: Enumerable<Date> | Enumerable<string>
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeWithAggregatesFilter | Date | string
    _count?: NestedIntFilter
    _min?: NestedDateTimeFilter
    _max?: NestedDateTimeFilter
  }

  export type NestedStringNullableFilter = {
    equals?: string | null
    in?: Enumerable<string> | null
    notIn?: Enumerable<string> | null
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    not?: NestedStringNullableFilter | string | null
  }

  export type NestedStringNullableWithAggregatesFilter = {
    equals?: string | null
    in?: Enumerable<string> | null
    notIn?: Enumerable<string> | null
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    not?: NestedStringNullableWithAggregatesFilter | string | null
    _count?: NestedIntNullableFilter
    _min?: NestedStringNullableFilter
    _max?: NestedStringNullableFilter
  }

  export type NestedIntNullableFilter = {
    equals?: number | null
    in?: Enumerable<number> | null
    notIn?: Enumerable<number> | null
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntNullableFilter | number | null
  }



  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}